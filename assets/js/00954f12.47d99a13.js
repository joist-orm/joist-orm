"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9729],{2656:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>o});var a=t(4246),i=t(1670);const s={title:"Entity Manager",sidebar_position:1},l=void 0,d={id:"features/entity-manager",title:"Entity Manager",description:"Joist's EntityManager is how entities are loaded from & saved to the database.",source:"@site/docs/features/entity-manager.md",sourceDirName:"features",slug:"/features/entity-manager",permalink:"/docs/features/entity-manager",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/features/entity-manager.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Entity Manager",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"JSONB Fields",permalink:"/docs/modeling/jsonb-fields"},next:{title:"Loading Entities",permalink:"/docs/features/loading-entities"}},r={},o=[{value:"Features",id:"features",level:2},{value:"Auto-Batch Updates",id:"auto-batch-updates",level:3},{value:"API",id:"api",level:2},{value:"<code>#create</code>",id:"create",level:3},{value:"<code>#createOrUpdatePartial</code>",id:"createorupdatepartial",level:3},{value:"<code>#setPartial</code>",id:"setpartial",level:3},{value:"Updating a field",id:"updating-a-field",level:3},{value:"<code>#delete</code>",id:"delete",level:3},{value:"<code>#load</code>",id:"load",level:3},{value:"<code>#loadAll</code>",id:"loadall",level:3},{value:"<code>#loadAllIfExists</code>",id:"loadallifexists",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Joist's ",(0,a.jsx)(n.code,{children:"EntityManager"})," is how entities are loaded from & saved to the database."]}),"\n",(0,a.jsxs)(n.p,{children:["Each request should get its own ",(0,a.jsx)(n.code,{children:"EntityManager"}),", which will coordinate loading & saving entities for that request, effectively acting as a Unit of Work for the request (see ",(0,a.jsx)(n.a,{href:"../advanced/unit-of-work",children:"Unit of Work"})," for more details)."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["This means that entities must be loaded from the ",(0,a.jsx)(n.code,{children:"EntityManager"}),", i.e. via ",(0,a.jsx)(n.code,{children:"em.load(Author, 1)"}),", and not from methods on ",(0,a.jsx)(n.code,{children:"Author"}),", i.e. like the prototypical ActiveRecord ",(0,a.jsx)(n.code,{children:"Author.find_by_id(1)"})," methods in Rails."]})}),"\n",(0,a.jsxs)(n.p,{children:["All work is made off of the Joist entity manager. When ",(0,a.jsx)(n.code,{children:".flush()"})," is called on the entity manager, Joist will perform all the hooks and validation checks before writing to the database. Flush can be called multiple times as work is done an entities."]}),"\n",(0,a.jsx)(n.p,{children:"For example:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const em = newEntityManager();\nconst author = new Author(em, { firstName: "a1" });\nawait em.flush();\nauthor.firstName = "a2";\nawait em.flush();\n'})}),"\n",(0,a.jsx)(n.h2,{id:"features",children:"Features"}),"\n",(0,a.jsx)(n.h3,{id:"auto-batch-updates",children:"Auto-Batch Updates"}),"\n",(0,a.jsxs)(n.p,{children:["Initially using an ",(0,a.jsx)(n.code,{children:"EntityManager"})," can feel awkward, especially for saving changes via ",(0,a.jsx)(n.code,{children:"em.flush()"})," because you \"don't see\", don't type out, the individual ",(0,a.jsx)(n.code,{children:"INSERT"})," / ",(0,a.jsx)(n.code,{children:"UPDATE"})," / ",(0,a.jsx)(n.code,{children:"DELETE"})," SQL calls that Joist issues for each entity."]}),"\n",(0,a.jsx)(n.p,{children:"However, letting Joist handle this means it can apply your SQL changes in the most efficient manner possible:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"It first opens a transaction so call mutations are made atomically"}),"\n",(0,a.jsxs)(n.li,{children:['It then issues a single "assign new ids" ',(0,a.jsx)(n.code,{children:"SELECT"})," statement to get ids for any newly-inserted entities, from their respective sequences."]}),"\n",(0,a.jsxs)(n.li,{children:["Next it issues 1 batch-insert/batch-update/batch-delete statement for each entity type that's created/updated/deleted.","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["We automatically leverage Postgres's ",(0,a.jsx)(n.code,{children:"DEFERRED FOREIGN KEY"})," constraints to avoid entity-insert ordering issues"]}),"\n",(0,a.jsx)(n.li,{children:"The batching logic will use multiple batches if needed, depending on the number of rows & columns being updated (to stay under PostgreSQL's max parameter limit)"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["Finally, ",(0,a.jsx)(n.code,{children:"COMMIT"})," all the changes"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"api",children:"API"}),"\n",(0,a.jsx)(n.h3,{id:"create",children:(0,a.jsx)(n.code,{children:"#create"})}),"\n",(0,a.jsx)(n.p,{children:"Load an instance of a given entity and id"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const em = newEntityManager();\nconst a = await em.create(Author, { email: 'foo@bar.com' });\n"})}),"\n",(0,a.jsx)(n.p,{children:"Optionally, another way to create an entity is to do:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const em = newEntityManager();\nconst a = new Author(em, { firstName: "a1", address: { street: "123 Main" } });\n'})}),"\n",(0,a.jsx)(n.h3,{id:"createorupdatepartial",children:(0,a.jsx)(n.code,{children:"#createOrUpdatePartial"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const em = newEntityManager();\nconst a1 = await em.createOrUpdatePartial(Author, { firstName: "a1" });\n'})}),"\n",(0,a.jsx)(n.h3,{id:"setpartial",children:(0,a.jsx)(n.code,{children:"#setPartial"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const em = newEntityManager();\nconst a1 = em.create(Author, { firstName: "a1" });\na1.setPartial({ firstName: \'a:2 });\n'})}),"\n",(0,a.jsx)(n.h3,{id:"updating-a-field",children:"Updating a field"}),"\n",(0,a.jsx)(n.p,{children:"Another option to updating is setting the field directly."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const em = newEntityManager();\nconst author = new Author(em, { firstName: "a1" });\nawait em.flush();\nauthor.firstName = "a2";\nawait em.flush();\n'})}),"\n",(0,a.jsx)(n.h3,{id:"delete",children:(0,a.jsx)(n.code,{children:"#delete"})}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const em = newEntityManager();\nconst a1 = await em.load(Author, "1");\nem.delete(a1);\n'})}),"\n",(0,a.jsx)(n.h3,{id:"load",children:(0,a.jsx)(n.code,{children:"#load"})}),"\n",(0,a.jsx)(n.p,{children:"Load an instance of a given entity and id."}),"\n",(0,a.jsxs)(n.p,{children:["This will return the existing ",(0,a.jsx)(n.code,{children:"Author:1"})," instance if it's already been loaded from the database."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const em = newEntityManager();\nconst a = await em.load(Author, "a:1");\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Returns","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Entity if found"}),"\n",(0,a.jsxs)(n.li,{children:["throws ",(0,a.jsx)(n.code,{children:"Error"})," if not"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"loadall",children:(0,a.jsx)(n.code,{children:"#loadAll"})}),"\n",(0,a.jsx)(n.p,{children:"Load multiple instances of a given entity and ids, and fails if any id does not exist."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const em = newEntityManager();\nconst a = await em.loadAll(Author, ["a:1", "a:2"]);\n'})}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Returns","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Array of entities if found"}),"\n",(0,a.jsxs)(n.li,{children:["throws ",(0,a.jsx)(n.code,{children:"Error"})," if not"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"loadallifexists",children:(0,a.jsx)(n.code,{children:"#loadAllIfExists"})}),"\n",(0,a.jsx)(n.p,{children:"Load multiple instances of a given entity and ids, and ignores ids that don't exist."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const em = newEntityManager();\nconst a = await em.loadAllIfExists(Author, ["a:1", "a:2"]);\n'})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>d,a:()=>l});var a=t(7378);const i={},s=a.createContext(i);function l(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);