"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[836],{2334:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>n,metadata:()=>a,toc:()=>c});var o=s(4246),i=s(1670);const n={title:"FAQ",position:10},r=void 0,a={id:"faq",title:"FAQ",description:"What databases does Joist support?",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/docs/faq",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/faq.md",tags:[],version:"current",frontMatter:{title:"FAQ",position:10},sidebar:"tutorialSidebar",previous:{title:"graphql-filters",permalink:"/docs/advanced/graphql-filters"},next:{title:"Test Factories",permalink:"/docs/testing/test-factories"}},d={},c=[{value:"What databases does Joist support?",id:"what-databases-does-joist-support",level:2},{value:"Why are relations modeled as objects?",id:"why-are-relations-modeled-as-objects",level:2},{value:"Why must properties be explicitly typed?",id:"why-must-properties-be-explicitly-typed",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h2,{id:"what-databases-does-joist-support",children:"What databases does Joist support?"}),"\n",(0,o.jsxs)(t.p,{children:["Currently only Postgres; see ",(0,o.jsx)(t.a,{href:"https://github.com/joist-orm/joist-orm/issues/636",children:"support other databases"}),"."]}),"\n",(0,o.jsx)(t.h2,{id:"why-are-relations-modeled-as-objects",children:"Why are relations modeled as objects?"}),"\n",(0,o.jsxs)(t.p,{children:["In Joist, relations are modeled as wrapper objects, i.e. ",(0,o.jsx)(t.code,{children:"Author.books"})," is not a raw array like ",(0,o.jsx)(t.code,{children:"Book[]"}),", but instead a ",(0,o.jsx)(t.code,{children:"Collection<Author, Book[]>"})," that must have ",(0,o.jsx)(t.code,{children:".load()"})," and ",(0,o.jsx)(t.code,{children:".get"})," called on it."]}),"\n",(0,o.jsx)(t.p,{children:"This can initially feel awkward, but it provides a truly type-safe API, given that relations may-or-may not be loaded from the database, and instead are incrementally into memory."}),"\n",(0,o.jsx)(t.p,{children:"This is often how business logic wants to interact with the domain model--a continual incremental loading of data as needed, as conditional codepaths are executed, instead of an endpoint/program exhaustively knowing up-front exactly what data will be necessary."}),"\n",(0,o.jsxs)(t.p,{children:["If performance is a concern (loading thousands of entities with many custom properties), Joist provides a ",(0,o.jsx)(t.a,{href:"/docs/advanced/transform-properties",children:"ts-patch transform"})," to rewrite the properties as lazy getters in production builds."]}),"\n",(0,o.jsx)(t.h2,{id:"why-must-properties-be-explicitly-typed",children:"Why must properties be explicitly typed?"}),"\n",(0,o.jsxs)(t.p,{children:["When declaring custom properties on entities, currently the fields must be explicitly typed, i.e. the ",(0,o.jsx)(t.code,{children:"Collection<Author, BookReview>"})," in the following example is required:"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-typescript",children:"export class Author extends AuthorCodegen {\n  readonly reviews: Collection<Author, BookReview> = hasManyThrough((author) => author.books.reviews);\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Obviously as TypeScript fans, we'd love to have these field types inferred, and just do ",(0,o.jsx)(t.code,{children:"readonly reviews = hasManyThrough"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Unfortunately, given how interconnected the types of a domain model are, and how sophisticated custom properties can rely on cross-entity typing, attempting to infer the field types quickly leads to the TypeScript compiler failing with cyclic dependency errors, i.e. the ",(0,o.jsx)(t.code,{children:"Author"}),"'s fields can only be inferred if ",(0,o.jsx)(t.code,{children:"Book"})," is first typed, but ",(0,o.jsx)(t.code,{children:"Book"}),"'s fields can only be inferred if ",(0,o.jsx)(t.code,{children:"Author"})," is first typed."]}),"\n",(0,o.jsx)(t.p,{children:"And adding explicit field types short-circuits these cyclic dependency."})]})}function p(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},1670:(e,t,s)=>{s.d(t,{Z:()=>a,a:()=>r});var o=s(7378);const i={},n=o.createContext(i);function r(e){const t=o.useContext(n);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),o.createElement(n.Provider,{value:t},e.children)}}}]);