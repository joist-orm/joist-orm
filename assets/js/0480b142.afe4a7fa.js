"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[836],{2334:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>n,metadata:()=>d,toc:()=>a});var s=o(4246),i=o(1670);const n={title:"FAQ",position:10},r=void 0,d={id:"faq",title:"FAQ",description:"Why Joist?",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/docs/faq",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/faq.md",tags:[],version:"current",frontMatter:{title:"FAQ",position:10},sidebar:"tutorialSidebar",previous:{title:"graphql-filters",permalink:"/docs/advanced/graphql-filters"},next:{title:"Test Factories",permalink:"/docs/testing/test-factories"}},l={},a=[{value:"Why Joist?",id:"why-joist",level:2},{value:"What databases does Joist support?",id:"what-databases-does-joist-support",level:2},{value:"Why are relations modeled as objects?",id:"why-are-relations-modeled-as-objects",level:2},{value:"Why must properties be explicitly typed?",id:"why-must-properties-be-explicitly-typed",level:2},{value:"Does Joist require <code>temporal-polyfill</code>?",id:"does-joist-require-temporal-polyfill",level:2}];function c(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"why-joist",children:"Why Joist?"}),"\n",(0,s.jsxs)(t.p,{children:["See ",(0,s.jsx)(t.a,{href:"./why-joist",children:"Why Joist"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"what-databases-does-joist-support",children:"What databases does Joist support?"}),"\n",(0,s.jsxs)(t.p,{children:["Currently only Postgres; see ",(0,s.jsx)(t.a,{href:"https://github.com/joist-orm/joist-orm/issues/636",children:"support other databases"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"why-are-relations-modeled-as-objects",children:"Why are relations modeled as objects?"}),"\n",(0,s.jsxs)(t.p,{children:["In Joist, relations are modeled as wrapper objects, i.e. ",(0,s.jsx)(t.code,{children:"Author.books"})," is not a raw array like ",(0,s.jsx)(t.code,{children:"Book[]"}),", but instead a ",(0,s.jsx)(t.code,{children:"Collection<Author, Book[]>"})," that must have ",(0,s.jsx)(t.code,{children:".load()"})," and ",(0,s.jsx)(t.code,{children:".get"})," called on it."]}),"\n",(0,s.jsx)(t.p,{children:"This can initially feel awkward, but it provides a truly type-safe API, given that relations may-or-may not be loaded from the database, and instead are incrementally into memory."}),"\n",(0,s.jsx)(t.p,{children:"This is often how business logic wants to interact with the domain model--a continual incremental loading of data as needed, as conditional codepaths are executed, instead of an endpoint/program exhaustively knowing up-front exactly what data will be necessary."}),"\n",(0,s.jsxs)(t.p,{children:["If performance is a concern (loading thousands of entities with many custom properties), Joist provides a ",(0,s.jsx)(t.a,{href:"/docs/advanced/transform-properties",children:"ts-patch transform"})," to rewrite the properties as lazy getters in production builds."]}),"\n",(0,s.jsx)(t.h2,{id:"why-must-properties-be-explicitly-typed",children:"Why must properties be explicitly typed?"}),"\n",(0,s.jsxs)(t.p,{children:["When declaring custom properties on entities, currently the fields must be explicitly typed, i.e. the ",(0,s.jsx)(t.code,{children:"Collection<Author, BookReview>"})," in the following example is required:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"export class Author extends AuthorCodegen {\n  readonly reviews: Collection<Author, BookReview> = hasManyThrough((author) => author.books.reviews);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Obviously as TypeScript fans, we'd love to have these field types inferred, and just do ",(0,s.jsx)(t.code,{children:"readonly reviews = hasManyThrough"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Unfortunately, given how interconnected the types of a domain model are, and how sophisticated custom properties can rely on cross-entity typing, attempting to infer the field types quickly leads to the TypeScript compiler failing with cyclic dependency errors, i.e. the ",(0,s.jsx)(t.code,{children:"Author"}),"'s fields can only be inferred if ",(0,s.jsx)(t.code,{children:"Book"})," is first typed, but ",(0,s.jsx)(t.code,{children:"Book"}),"'s fields can only be inferred if ",(0,s.jsx)(t.code,{children:"Author"})," is first typed."]}),"\n",(0,s.jsx)(t.p,{children:"And adding explicit field types short-circuits these cyclic dependency."}),"\n",(0,s.jsxs)(t.h2,{id:"does-joist-require-temporal-polyfill",children:["Does Joist require ",(0,s.jsx)(t.code,{children:"temporal-polyfill"}),"?"]}),"\n",(0,s.jsxs)(t.p,{children:["No. Joist has optional support for the upcoming JS temporal API; you can opt-in to it by setting ",(0,s.jsx)(t.code,{children:'temporal: "true"'})," in ",(0,s.jsx)(t.code,{children:"joist-config.json"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If you'd like to keep using ",(0,s.jsx)(t.code,{children:"Date"}),", there are no runtime dependencies on ",(0,s.jsx)(t.code,{children:"temporal-polyfill"}),", but if you get errors like:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"node_modules/joist-orm/build/utils.d.ts:1:56 - error TS2307: Cannot find module 'temporal-polyfill' or its corresponding type declarations.\n\n1 import type { Intl, Temporal, toTemporalInstant } from \"temporal-polyfill\";\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Then you either need to enable ",(0,s.jsx)(t.code,{children:'skipLibCheck: "true"'})," in your ",(0,s.jsx)(t.code,{children:"tsconfig.json"})," (recommended, as this disables unnecessary type-checking of your dependency's ",(0,s.jsx)(t.code,{children:"*.ts"})," code), or install ",(0,s.jsx)(t.code,{children:"temporal-polyfill"})," as a ",(0,s.jsx)(t.code,{children:"devDependency"}),"."]})]})}function p(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1670:(e,t,o)=>{o.d(t,{Z:()=>d,a:()=>r});var s=o(7378);const i={},n=s.createContext(i);function r(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);