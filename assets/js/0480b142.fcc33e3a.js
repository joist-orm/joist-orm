"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[836],{2334:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>n,metadata:()=>r,toc:()=>d});var s=i(4246),o=i(1670);const n={title:"FAQ",position:10},a=void 0,r={id:"faq",title:"FAQ",description:"Why use Entities & Mutable Classes?",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/docs/faq",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/faq.md",tags:[],version:"current",frontMatter:{title:"FAQ",position:10},sidebar:"tutorialSidebar",previous:{title:"graphql-filters",permalink:"/docs/advanced/graphql-filters"},next:{title:"Test Factories",permalink:"/docs/testing/test-factories"}},l={},d=[{value:"Why use Entities &amp; Mutable Classes?",id:"why-use-entities--mutable-classes",level:2},{value:"What databases does Joist support?",id:"what-databases-does-joist-support",level:2},{value:"Why are relations modeled as objects?",id:"why-are-relations-modeled-as-objects",level:2},{value:"Can&#39;t I just use Zod for validations in my controller?",id:"cant-i-just-use-zod-for-validations-in-my-controller",level:2},{value:"Does Joist over-fetch data from the database?",id:"does-joist-over-fetch-data-from-the-database",level:2},{value:"Why must properties be explicitly typed?",id:"why-must-properties-be-explicitly-typed",level:2},{value:"Does Joist require <code>temporal-polyfill</code>?",id:"does-joist-require-temporal-polyfill",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"why-use-entities--mutable-classes",children:"Why use Entities & Mutable Classes?"}),"\n",(0,s.jsxs)(t.p,{children:["See ",(0,s.jsx)(t.a,{href:"/docs/modeling/why-entities",children:"Why Entities"}),', and the "Why Classes" and "Why Mutability" sections.']}),"\n",(0,s.jsx)(t.p,{children:'A tldr is that we think mutable entities is the most ergonomic way to indicate "this how you would like the world to look" (i.e. "I want two new books, this old book archived, and the author\'s name changed"), by making potentially multiple mutations to the entity graph.'}),"\n",(0,s.jsxs)(t.p,{children:["After which, Joist's ",(0,s.jsx)(t.code,{children:"em.flush"}),' will ensure this "new proposed graph", as an aggregate, in still valid, and then commit all your changes to the database atomically.']}),"\n",(0,s.jsxs)(t.p,{children:["Also note that ",(0,s.jsx)(t.code,{children:"em.flush"}),' enforces "temporary immutability" during its lifecycle, specifically when running validation rules, by "locking" the entities to ensure they are not further mutated while being validated.']}),"\n",(0,s.jsxs)(t.p,{children:["(In a way, you can think of Joist's entities as an ",(0,s.jsx)(t.a,{href:"https://immerjs.github.io/immer/",children:"Immer"})," for your data model--i.e. the database itself progresses through a series of atomic, immutable states (transactions), and Joist's entities are just an ergonomic way to declare what you want the next state to be.)"]}),"\n",(0,s.jsx)(t.h2,{id:"what-databases-does-joist-support",children:"What databases does Joist support?"}),"\n",(0,s.jsxs)(t.p,{children:["Currently only Postgres; see ",(0,s.jsx)(t.a,{href:"https://github.com/joist-orm/joist-orm/issues/636",children:"support other databases"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"why-are-relations-modeled-as-objects",children:"Why are relations modeled as objects?"}),"\n",(0,s.jsxs)(t.p,{children:["In Joist, relations are modeled as wrapper objects, i.e. ",(0,s.jsx)(t.code,{children:"Author.books"})," is not a raw array like ",(0,s.jsx)(t.code,{children:"Book[]"}),", but instead a ",(0,s.jsx)(t.code,{children:"Collection<Author, Book[]>"})," that must have ",(0,s.jsx)(t.code,{children:".load()"})," and ",(0,s.jsx)(t.code,{children:".get"})," called on it."]}),"\n",(0,s.jsx)(t.p,{children:"This can initially feel awkward, but it provides a truly type-safe API, given that relations may-or-may not be loaded from the database, and instead are incrementally into memory."}),"\n",(0,s.jsx)(t.p,{children:"This is often how business logic wants to interact with the domain model--a continual incremental loading of data as needed, as conditional codepaths are executed, instead of an endpoint/program exhaustively knowing up-front exactly what data will be necessary."}),"\n",(0,s.jsxs)(t.p,{children:["If performance is a concern (loading thousands of entities with many custom properties), Joist provides a ",(0,s.jsx)(t.a,{href:"/docs/advanced/transform-properties",children:"ts-patch transform"})," to rewrite the properties as lazy getters in production builds."]}),"\n",(0,s.jsx)(t.h2,{id:"cant-i-just-use-zod-for-validations-in-my-controller",children:"Can't I just use Zod for validations in my controller?"}),"\n",(0,s.jsxs)(t.p,{children:['Zod works great for crossing the "untyped blob" to "typed POJO" divide, and Joist actually supports Zod for ',(0,s.jsx)(t.code,{children:"jsonb"}),' columns, which is a similar "untyped jsonb to typed POJO" use case.']}),"\n",(0,s.jsx)(t.p,{children:'However, Zod can only validate fields directly on the "typed input" itself--is this email field a valid email regex, is the required first name field filled in.'}),"\n",(0,s.jsxs)(t.p,{children:["This is fine, but Zod can't validate all the ",(0,s.jsx)(t.em,{children:"other"})," fields in your domain model that now might need revalidated--i.e. maybe the author's ",(0,s.jsx)(t.code,{children:"age"})," field changed, so now validate that they're verified, or updating a purchase order line item's ",(0,s.jsx)(t.code,{children:"amount"})," cannot make the total order's ",(0,s.jsx)(t.code,{children:"amount"})," negative."]}),"\n",(0,s.jsxs)(t.p,{children:['Joist\'s domain model makes it easy to declaratively setup these "cross-field", "cross-entity" business variants, that are more than just ',(0,s.jsx)(t.code,{children:"z.string().max(20)"}),", and then ensure they are ",(0,s.jsx)(t.em,{children:"always"})," enforced, regardless of which controller initiated the mutation."]}),"\n",(0,s.jsxs)(t.admonition,{type:"tip",children:[(0,s.jsx)(t.p,{children:'Joist works particularly well with GraphQL, because GraphQL servers handle the basic "untyped blob -> typed mutation" conversion & checks, similar to what Zod can provide, but they do it "for free" using the GraphQL schema.'}),(0,s.jsxs)(t.p,{children:["Then each mutation can use the already-typed input POJO to update the domain model (typically through upsert-capable methods like ",(0,s.jsx)(t.code,{children:"em.createOrUpdatePartial"}),'), and then defer all "business variant" validations to the domain model itself.']}),(0,s.jsx)(t.p,{children:'In our experience, this split of responsibilities is very robust, and leads to small, idiomatic mutation resolvers, much inline with the Rails "fat model, skinny controller" pattern.'})]}),"\n",(0,s.jsx)(t.h2,{id:"does-joist-over-fetch-data-from-the-database",children:"Does Joist over-fetch data from the database?"}),"\n",(0,s.jsx)(t.p,{children:"When Joist loads an entity, it does loads of the columns; we've found in practice, for relational databases that load the whole row from disk anyway, this is not a significant performance concern."}),"\n",(0,s.jsxs)(t.p,{children:['That said, all of Joist\'s "backend reactivity" features, like reactive validation rules & reactive fields, use field-level precision in whether they fire or not. For example, an ',(0,s.jsx)(t.code,{children:"Author"})," rule that watches ",(0,s.jsx)(t.code,{children:"{ books: title }"})," will not trigger when one of it's book changes its ",(0,s.jsx)(t.code,{children:"book.status"})," value."]}),"\n",(0,s.jsxs)(t.p,{children:["Also, if you have endpoints that require summarizing a lot of children data, Joist's ",(0,s.jsx)(t.a,{href:"https://joist-orm.io/docs/modeling/reactive-fields#async-reactive-fields",children:"reactive fields"})," are an extremely robust way for keeping materialized columns up-to-date (i.e. tracking ",(0,s.jsx)(t.code,{children:"Bill.totalPaid"})," and ",(0,s.jsx)(t.code,{children:"Bill.totalUnpaid"})," columns that sum child ",(0,s.jsx)(t.code,{children:"BillLineItem"})," rows, for fast, easy sorting & filtering."]}),"\n",(0,s.jsxs)(t.p,{children:['Finally, Joist does not have a dogmatic "all queries ',(0,s.jsx)(t.em,{children:"must"}),' be done via the ORM" stance. It\'s perfectly fine to use Joist\'s "object graph navigation" and ',(0,s.jsx)(t.code,{children:"em.find"})," for 90-95% of your queries (that would be very boilerplate SQL queries), and then use a lower-level query builder for the remaining 10%."]}),"\n",(0,s.jsx)(t.admonition,{type:"tip",children:(0,s.jsxs)(t.p,{children:["We do have an idea for ",(0,s.jsx)(t.a,{href:"https://github.com/joist-orm/joist-orm/issues/178",children:"lazy column"}),' support, if you have particularly large columns that should not be fetched by default. We should be able to use Joist\'s existing "conditionally loaded relations" trick to apply ot "conditionally loaded columns", but have not implemented this yet.']})}),"\n",(0,s.jsx)(t.h2,{id:"why-must-properties-be-explicitly-typed",children:"Why must properties be explicitly typed?"}),"\n",(0,s.jsxs)(t.p,{children:["When declaring custom properties on entities, currently the fields must be explicitly typed, i.e. the ",(0,s.jsx)(t.code,{children:"Collection<Author, BookReview>"})," in the following example is required:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"export class Author extends AuthorCodegen {\n  readonly reviews: Collection<Author, BookReview> = hasManyThrough((author) => author.books.reviews);\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Obviously as TypeScript fans, we'd love to have these field types inferred, and just do ",(0,s.jsx)(t.code,{children:"readonly reviews = hasManyThrough"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["Unfortunately, given how interconnected the types of a domain model are, and how sophisticated custom properties can rely on cross-entity typing, attempting to infer the field types quickly leads to the TypeScript compiler failing with cyclic dependency errors, i.e. the ",(0,s.jsx)(t.code,{children:"Author"}),"'s fields can only be inferred if ",(0,s.jsx)(t.code,{children:"Book"})," is first typed, but ",(0,s.jsx)(t.code,{children:"Book"}),"'s fields can only be inferred if ",(0,s.jsx)(t.code,{children:"Author"})," is first typed."]}),"\n",(0,s.jsx)(t.p,{children:"And adding explicit field types short-circuits these cyclic dependency."}),"\n",(0,s.jsxs)(t.h2,{id:"does-joist-require-temporal-polyfill",children:["Does Joist require ",(0,s.jsx)(t.code,{children:"temporal-polyfill"}),"?"]}),"\n",(0,s.jsxs)(t.p,{children:["No. Joist has optional support for the upcoming JS temporal API; you can opt-in to it by setting ",(0,s.jsx)(t.code,{children:'temporal: "true"'})," in ",(0,s.jsx)(t.code,{children:"joist-config.json"}),"."]}),"\n",(0,s.jsxs)(t.p,{children:["If you'd like to keep using ",(0,s.jsx)(t.code,{children:"Date"}),", there are no runtime dependencies on ",(0,s.jsx)(t.code,{children:"temporal-polyfill"}),", but if you get errors like:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{children:"node_modules/joist-orm/build/utils.d.ts:1:56 - error TS2307: Cannot find module 'temporal-polyfill' or its corresponding type declarations.\n\n1 import type { Intl, Temporal, toTemporalInstant } from \"temporal-polyfill\";\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Then you either need to enable ",(0,s.jsx)(t.code,{children:'skipLibCheck: "true"'})," in your ",(0,s.jsx)(t.code,{children:"tsconfig.json"})," (recommended, as this disables unnecessary type-checking of your dependency's ",(0,s.jsx)(t.code,{children:"*.ts"})," code), or install ",(0,s.jsx)(t.code,{children:"temporal-polyfill"})," as a ",(0,s.jsx)(t.code,{children:"devDependency"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1670:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>a});var s=i(7378);const o={},n=s.createContext(o);function a(e){const t=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);