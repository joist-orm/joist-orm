"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7229],{3908:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var s=t(4246),n=t(1670);const o={title:"Why Entities?",sidebar_position:0},a=void 0,r={id:"modeling/why-entities",title:"Why Entities?",description:"One of Joist's biggest differentiators is its focus on entities and domain modeling.",source:"@site/docs/modeling/why-entities.md",sourceDirName:"modeling",slug:"/modeling/why-entities",permalink:"/docs/modeling/why-entities",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/modeling/why-entities.md",tags:[],version:"current",sidebarPosition:0,frontMatter:{title:"Why Entities?",sidebar_position:0},sidebar:"tutorialSidebar",previous:{title:"No Ugly Queries",permalink:"/docs/goals/no-ugly-queries"},next:{title:"Fields",permalink:"/docs/modeling/fields"}},l={},d=[{value:"Tldr: Structure",id:"tldr-structure",level:2},{value:"Longer Answer",id:"longer-answer",level:2},{value:"Examples for Reads",id:"examples-for-reads",level:3},{value:"Examples for Writes",id:"examples-for-writes",level:3},{value:"Thinking in Graphs",id:"thinking-in-graphs",level:2},{value:"Why Classes?",id:"why-classes",level:2},{value:"Why Mutability?",id:"why-mutability",level:2},{value:"Target Market",id:"target-market",level:2}];function c(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,n.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(i.p,{children:["One of Joist's biggest differentiators is its focus on ",(0,s.jsx)(i.strong,{children:"entities"})," and ",(0,s.jsx)(i.strong,{children:"domain modeling"}),"."]}),"\n",(0,s.jsx)(i.h2,{id:"tldr-structure",children:"Tldr: Structure"}),"\n",(0,s.jsx)(i.p,{children:'The tldr of "Why Entities?" is that they provide a structure for your application\'s business logic, which means:'}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Derived fields/helper methods you calculate on the fly,"}),"\n",(0,s.jsx)(i.li,{children:"Validation rules you enforce before saving, and"}),"\n",(0,s.jsx)(i.li,{children:"Side effects you trigger after saving"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"These are fundamental aspects to all backends, regardless of whether your ORM uses POJOs, or entities, or raw SQL queries."}),"\n",(0,s.jsx)(i.p,{children:'Joist uses entities because, in our opinion, they provide very natural, intuitive guidance on where to put this business logic, that otherwise in "raw POJO from the database" ORMs, each application are must create its own structure in an adhoc/haphazard way.'}),"\n",(0,s.jsx)(i.h2,{id:"longer-answer",children:"Longer Answer"}),"\n",(0,s.jsxs)(i.p,{children:['Most modern ORMs in the JavaScript/TypeScript space focus on being "query builders", where each invocation in your code (a call into Prisma or Drizzle or Kysley) results in generally one invocation to your database, and you get back every database row as a dumb (meant in a good way) ',(0,s.jsx)(i.a,{href:"https://gist.github.com/kurtmilam/a1179741777ea6f88374286a640829cc",children:"POJO"}),"--no more, and no less."]}),"\n",(0,s.jsx)(i.p,{children:"And that is basically it--the organization of your business logic, application of validation rules, and side effects/reactivity (i.e. when row X updates, do Y) are outside their scope."}),"\n",(0,s.jsxs)(i.p,{children:['This can be good and bad: good in that they\'re simpler, more "like a library", but also bad in that now ',(0,s.jsx)(i.strong,{children:"your app has to have its own conventions"})," for organizing business logic, consistently applying validation rules, and managing side effects."]}),"\n",(0,s.jsxs)(i.p,{children:["Joist is different: its focus is not just queries, but building ",(0,s.jsx)(i.a,{href:"https://martinfowler.com/eaaCatalog/domainModel.html",children:"domain models"}),", with features, conventions, and patterns for organizing the business logic that application backends are generally expected to implement."]}),"\n",(0,s.jsx)(i.p,{children:'In this regard, Joist sits more on the "framework" side of the "library / framework" spectrum, although it can used for any backend, i.e. GraphQL or GRPC or old-school REST endpoints, so does not qualify as a true end-to-end framework like Rails.'}),"\n",(0,s.jsxs)(i.admonition,{type:"info",children:[(0,s.jsxs)(i.p,{children:["Ironically, query-builder ORMs like Drizzle tout their \"we're ",(0,s.jsx)(i.em,{children:"not"}),' a data framework" approach as a benefit, just as much as Joist touts its "we ',(0,s.jsx)(i.em,{children:"are"}),' a framework" approach as a benefit. :-)']}),(0,s.jsx)(i.p,{children:'So whether you want a Joist-style "framework/entity ORM", or Drizzle-style "library/query-builder ORM", is a matter of personal taste and project requirements.'}),(0,s.jsx)(i.p,{children:"Some of it comes down to trust: do you trust yourself to remember to apply validation rules & side effects consistently, in every endpoint, before you issue low-level SQL calls via Drizzle/Prisma/Kysley, or do you trust Joist's entities & abstractions to do that automatically for you, without becoming too magical & spooky-action-at-a-distance?"}),(0,s.jsxs)(i.p,{children:['Joist tries very hard to avoid the "too magical" pitfall, and make its behavior as unsurprising and idiomatic as possible (i.e. no N+1s, no complex queries), such that you quickly become to trust that ',(0,s.jsx)(i.code,{children:"em.flush"}),", ",(0,s.jsx)(i.code,{children:"em.find"}),', all "just do the right thing", and you can focus on providing business value.']}),(0,s.jsx)(i.p,{children:"So far, we believe we've succeeded, but again personal preference & project requirements plays a big role here."})]}),"\n",(0,s.jsxs)(i.admonition,{type:"tip",children:[(0,s.jsx)(i.p,{children:'Although not a true  "end-to-end framework" like Rails, Joist grew out of a GraphQL backend and so has several ergonomic features for that use-case, like evergreen schema & resolver scaffolding.'}),(0,s.jsx)(i.p,{children:"(todo: write this up and link to it)"})]}),"\n",(0,s.jsx)(i.h3,{id:"examples-for-reads",children:"Examples for Reads"}),"\n",(0,s.jsxs)(i.p,{children:['An example of Joist\'s "rich domain model" features is derived properties, which are calculations on top of your raw database values. For example a ',(0,s.jsx)(i.code,{children:"hasManyThrough"})," or ",(0,s.jsx)(i.code,{children:"hasAsyncProperty"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:'class Author extends AuthorCodegen {\n  readonly reviews: Collection<Author, BookReview> = hasMany((a) => a.books.reviews);\n  readonly totalRatings: AsyncProperty<Author, number> = hasAsyncProperty(\n    { books: "reviews" },\n    (a) => a.reviews.get.reduce((acc, r) => acc + r.rating, 0)\n  );\n}\n'})}),"\n",(0,s.jsxs)(i.p,{children:['Both of these are "utility methods" that can be reused across endpoints/logic in your app--Joist\'s domain model gives you a known/obvious place to put them, and also guarantees they can be calculated relatively cheaply (i.e. ',(0,s.jsx)(i.a,{href:"/docs/goals/avoiding-n-plus-1s",children:"without N+1s"}),") or easily materialized (i.e. ",(0,s.jsx)(i.a,{href:"/docs/modeling/reactive-fields",children:"reactive fields"}),")."]}),"\n",(0,s.jsxs)(i.p,{children:["The biggest win is that our business logic within these methods is written in ",(0,s.jsx)(i.strong,{children:"regular, ergonomic"})," TypeScript."]}),"\n",(0,s.jsx)(i.p,{children:'This contrasts with query-builder ORMs (and also "database-to-API" approaches like Hasura and PostGraphile), that focus solely on pulling data directly from the database, such that logic reuse must be pushed down into the database itself, and written as views, triggers, or stored procedures.'}),"\n",(0,s.jsxs)(i.admonition,{type:"info",children:[(0,s.jsxs)(i.p,{children:["When looking at the ",(0,s.jsx)(i.code,{children:"totalRatings"}),' example above, it can initially look weird to see the "this is just a ',(0,s.jsx)(i.code,{children:"SUM(rating)"}),'" logic in written in TypeScript, instead of being pushed down into the database as SQL, but the two key benefits are:']}),(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Once your business logic is more complex than a ",(0,s.jsx)(i.code,{children:"SUM"}),", it can be much easier to express in TypeScript than SQL, and"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Because the business logic is evaluated against in-memory entities, it can be called on not-yet-committed data, i.e. your pending in-memory changes (to a ",(0,s.jsx)(i.code,{children:"Book"})," or ",(0,s.jsx)(i.code,{children:"Author"}),") during a ",(0,s.jsx)(i.code,{children:"save"})," operation, by validation rules or other business logic & they're guaranteed to see the latest calculated values."]}),"\n",(0,s.jsx)(i.p,{children:"This is much easier than manually opening a transaction, flushing the WIP changes without commiting, then issuing queries to read the latest aggregates, do validation checks against those SQL-calculated aggregates, and then finally commit."}),"\n",(0,s.jsxs)(i.p,{children:["(Although if you really do need this functionality, Joist's ",(0,s.jsx)(i.a,{href:"/docs/modeling/reactive-fields#reactive-query-fields",children:"Reactive Query Fields"})," will orchestrate exactly this ",(0,s.jsx)(i.code,{children:"begin"})," + ",(0,s.jsx)(i.code,{children:"flush"})," + ",(0,s.jsx)(i.code,{children:"query"})," + ",(0,s.jsx)(i.code,{children:"flush"})," + ",(0,s.jsx)(i.code,{children:"commit"})," sequence for you, automatically, within an ",(0,s.jsx)(i.code,{children:"em.flush()"})," call)."]}),"\n"]}),"\n"]}),(0,s.jsxs)(i.p,{children:["That said, you can still do SQL-side ",(0,s.jsx)(i.code,{children:"SUM"}),"s and aggregates via custom SQL queries; that logic will just not be accessible to the rest of the Joist domain model."]})]}),"\n",(0,s.jsx)(i.h3,{id:"examples-for-writes",children:"Examples for Writes"}),"\n",(0,s.jsx)(i.p,{children:"On the write side, Joist's domain model approach also provides simple/obvious places to be validation rules and side effects."}),"\n",(0,s.jsx)(i.p,{children:'An example validation rule might be "the author first name and book title can never be the same string"; obviously this is contrived, but it shows a rule that needs to "watch" multiple entities:'}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:'import { authorConfig as config } from "./entities";\n\nclass Author extends AuthorCodegen {}\n\nconfig.addRule({ firstName: {}, books: "title" }, (a) => {\n  for (const book of a.books.get) {\n    if (a.firstName === book.title) {\n      throw new Error("Author first name and book title cannot be the same");\n     }\n  }\n});\n'})}),"\n",(0,s.jsxs)(i.p,{children:["Assuming writes go through Joist's domain model, ",(0,s.jsx)(i.strong,{children:"any update"})," to ",(0,s.jsx)(i.code,{children:"Author.firstName"})," or ",(0,s.jsx)(i.strong,{children:"any update"})," to a ",(0,s.jsx)(i.code,{children:"Book.title"})," or ",(0,s.jsxs)(i.strong,{children:["any ",(0,s.jsx)(i.code,{children:"Book"})," switching authors"]})," will fire this validation rule."]}),"\n",(0,s.jsxs)(i.p,{children:['This "',(0,s.jsx)(i.a,{href:"/docs/modeling/validation-rules#reactive-validation-rules",children:"backend reactivity"}),'" provides ',(0,s.jsx)(i.strong,{children:"extreme confidence"})," that your business rules will be enforced."]}),"\n",(0,s.jsxs)(i.p,{children:["This again contrasts with query builder ORMs, where it's your job to manually remember which validation rules, both on the current entity and other entities that might be affected, need to be checked, before issuing an ",(0,s.jsx)(i.code,{children:"INSERT"})," or ",(0,s.jsx)(i.code,{children:"UPDATE"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["Instead, domain-focused validation logic that would normally be scattered across endpoints (like ",(0,s.jsx)(i.code,{children:"saveAuthor"}),", ",(0,s.jsx)(i.code,{children:"createBook"})," and ",(0,s.jsx)(i.code,{children:"updateBook"}),"), and coupled/intermingled with each endpoint's core job of decoding/mapping the incoming payload, is put in an idiomatic location where it will always get invoked."]}),"\n",(0,s.jsx)(i.h2,{id:"thinking-in-graphs",children:"Thinking in Graphs"}),"\n",(0,s.jsx)(i.p,{children:'Beyond the reads & writes example, Joist fundamentally lets you "think in graphs" instead of "think in rows & columns".'}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsx)(i.p,{children:"This section needs flushed out more."})}),"\n",(0,s.jsx)(i.h2,{id:"why-classes",children:"Why Classes?"}),"\n",(0,s.jsx)(i.p,{children:'Joist\'s entities are classes, which often invokes a knee-jerk "anti-OOP" reaction.'}),"\n",(0,s.jsxs)(i.p,{children:["However, we primarily use the ",(0,s.jsx)(i.code,{children:"class Author extends AuthorCodegen"}),' pattern to "inject" code-generated getters & setters into entities, as the most ergonomic workflow we\'ve found so far.']}),"\n",(0,s.jsx)(i.p,{children:'The intent of Joist\'s entities is not to "encapsulate behavior" or "hide state" in traditional OOP sense--their job is precisely to expose state to clients/business logic.'}),"\n",(0,s.jsxs)(i.p,{children:['Additionally, we think "exposing ',(0,s.jsx)(i.em,{children:"abstracted"}),' state", i.e. helper methods that calculate cross-entity derived fields, is also a perfectly fine idea--TypeScript classes are a natural place for this logic to live, as the logic is effectively "overlaid on top" of the raw POJO coming back from the database.']}),"\n",(0,s.jsx)(i.h2,{id:"why-mutability",children:"Why Mutability?"}),"\n",(0,s.jsx)(i.p,{children:"The other potentially controversial aspect of Joist's entities is that they are mutable."}),"\n",(0,s.jsx)(i.p,{children:'This is because Joist\'s entities are meant to be "live" objects, that can be updated in memory, and then saved back to the database.'}),"\n",(0,s.jsx)(i.p,{children:"While can seem concerning, it's driven by following rationale, that you're either:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"In a query/read endpoint, and the entities will be effectively immutable,"}),"\n",(0,s.jsx)(i.li,{children:"In a mutation/save endpoint, and the point is to mutate entities anyway, and"}),"\n",(0,s.jsx)(i.li,{children:'For either read/save endpoints, it\'s very likely you\'ll want to reuse logic across both the "read path" and "write path", so have strictly separate "read types" and "write types" will be more cumbersome than helpful.'}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["Furthermore, Joist's ",(0,s.jsx)(i.code,{children:"em.flush"})," method is actually very strict, such that:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Initially, pre-",(0,s.jsx)(i.code,{children:"em.flush"}),', we want to allow easily the "morphing" the entities the graph\'s desired state,']}),"\n",(0,s.jsx)(i.p,{children:'(I.e. "morphing" is more than just a single column change on one isolated row--you might be creating several new child entities (attached to a parent), deleting others, and even mutating the parent itself, in one save endpoint, that all needs to be atomically committed.)'}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["But once ",(0,s.jsx)(i.code,{children:"em.flush"})," is called, and it's ran any hooks, all entities are ",(0,s.jsx)(i.strong,{children:"strictly locked"})," and become ",(0,s.jsx)(i.strong,{children:"effectively immutable"}),","]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["And then ",(0,s.jsx)(i.code,{children:"em.flush"})," runs validation rules against the now-immutable entities."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"In our opinion, this gives you the best of both worlds:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsxs)(i.li,{children:["We guarantee that entities will be ",(0,s.jsx)(i.strong,{children:"immutable while being validated"}),", but"]}),"\n",(0,s.jsx)(i.li,{children:"Before then, you can very ergonomically mutate your graph to the desired state."}),"\n"]}),"\n",(0,s.jsx)(i.h2,{id:"target-market",children:"Target Market"}),"\n",(0,s.jsxs)(i.p,{children:["Joist will work great for any (Postgres) database schema or (TypeScript) team, large or small. We take a lot of inspiration from ",(0,s.jsx)(i.a,{href:"https://guides.rubyonrails.org/active_record_basics.html",children:"ActiveRecord"}),", which of course has been used by many, many applications & teams of all sizes."]}),"\n",(0,s.jsxs)(i.p,{children:["That said, Joist is particularly suited to ",(0,s.jsx)(i.strong,{children:"moderately-to-very complicated business domains"}),"; i.e. stereotypical enterprise back-office systems are an ideal fit for Joist."]}),"\n",(0,s.jsx)(i.p,{children:'Joist\'s framework-style structure, and idiomatic ways of encoding cross-entity business invariants (reactive validation rules, reactive fields, and lifecycle hooks), are all purposefully built to manage the complexity of medium-to-large database schemas/domain models, where "just updating a few columns in this one database row" is insufficient.'})]})}function h(e={}){const{wrapper:i}={...(0,n.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1670:(e,i,t)=>{t.d(i,{Z:()=>r,a:()=>a});var s=t(7378);const n={},o=s.createContext(n);function a(e){const i=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(o.Provider,{value:i},e.children)}}}]);