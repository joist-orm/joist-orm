"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[577],{4436:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var t=o(4246),i=o(1670);const s={title:"Entity Cloning",sidebar_position:4},c=void 0,a={id:"advanced/cloning",title:"Entity Cloning",description:'Joist supports cloning entities, to easily implement feature requests like "duplicate this author", or "duplicate this author and all of their books".',source:"@site/docs/advanced/cloning.md",sourceDirName:"advanced",slug:"/advanced/cloning",permalink:"/docs/advanced/cloning",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/advanced/cloning.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Entity Cloning",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Soft Deletes",permalink:"/docs/advanced/soft-deletes"},next:{title:"Large Collections",permalink:"/docs/advanced/large-collections"}},l={},d=[{value:"Advanced Features",id:"advanced-features",level:3}];function r(e){const n={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:'Joist supports cloning entities, to easily implement feature requests like "duplicate this author", or "duplicate this author and all of their books".'}),"\n",(0,t.jsxs)(n.p,{children:["To clone an entity, call ",(0,t.jsx)(n.code,{children:"em.clone"})," and pass a load-hint of the subgraph you want to be included in the ",(0,t.jsx)(n.code,{children:"clone"})," operation."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, to clone an ",(0,t.jsx)(n.code,{children:"Author"})," plus all of their ",(0,t.jsx)(n.code,{children:"Book"}),"s and all of the ",(0,t.jsx)(n.code,{children:"Book"}),"'s ",(0,t.jsx)(n.code,{children:"BookReview"}),"s, you can call:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'const a1 = await em.load(Author, "a:1");\nconst a2 = await em.clone(a1, { books: "reviews" })\n'})}),"\n",(0,t.jsxs)(n.p,{children:["After the ",(0,t.jsx)(n.code,{children:"em.clone"})," is finished:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a2"})," will be a copy of ",(0,t.jsx)(n.code,{children:"a1"})," with all the same primitive field values, but a new primary key/new identity"]}),"\n",(0,t.jsxs)(n.li,{children:["Each ",(0,t.jsx)(n.code,{children:"Book"})," in ",(0,t.jsx)(n.code,{children:"a1.books"})," will have a new ",(0,t.jsx)(n.code,{children:"Book"})," instance created, and be correctly hooked up to ",(0,t.jsx)(n.code,{children:"a2"})," instead of the original ",(0,t.jsx)(n.code,{children:"a1"})]}),"\n",(0,t.jsxs)(n.li,{children:["Each ",(0,t.jsx)(n.code,{children:"BookReview"})," in each ",(0,t.jsx)(n.code,{children:"a1.books.reviews"})," will have a new ",(0,t.jsx)(n.code,{children:"BookReview"})," instance created, and again be correctly up to the right newly-created ",(0,t.jsx)(n.code,{children:"Book"})," instance in ",(0,t.jsx)(n.code,{children:"a2.books"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:['Besides setting the correct "parent" ',(0,t.jsx)(n.code,{children:"book.author"})," to ",(0,t.jsx)(n.code,{children:"a2"})," for each cloned child ",(0,t.jsx)(n.code,{children:"Book"}),", any other references/FKs in the newly-created entities that happened to point to also-cloned input entities (like ",(0,t.jsx)(n.code,{children:"a1.favoriteBook"})," pointing to ",(0,t.jsx)(n.code,{children:"a1.books.get[0]"}),") are adjusted to point to the correct/corresponding newly-cloned output entity."]}),"\n",(0,t.jsx)(n.p,{children:"Basically Joist will keep the subgraph of cloned entities intact."}),"\n",(0,t.jsx)(n.h3,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,t.jsxs)(n.p,{children:["When calling ",(0,t.jsx)(n.code,{children:"em.clone"}),", you can provide three config options to customize the behavior:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"opts.deep"})," is the load hint from above, i.e. ",(0,t.jsx)(n.code,{children:'{ books: "reviews" }'}),", that specifies the subgraph to clone."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"opts.skipIf"})," is a function that accepts an entity and returns ",(0,t.jsx)(n.code,{children:"true"})," if that entity should be skipped/not cloned:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:'// This will duplicate the author\'s books, but skip any book where the title includes `sea`\nconst duplicatedBooks = await em.clone(\n  author.books.get,\n  { skipIf: (original) => original.title.includes("sea") }\n);\n'})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"opts.postClone"})," is a function that accepts both the original entity and its new clone, to allow customizing to the clone:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-ts",children:"// This will duplicate the author's books, and assign them to a different author\nconst duplicatedBooks = await em.clone(\n  author.books.get,\n  { postClone: (_original, clone) => clone.author.set(author2) }\n);\n"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(r,{...e})}):r(e)}},1670:(e,n,o)=>{o.d(n,{Z:()=>a,a:()=>c});var t=o(7378);const i={},s=t.createContext(i);function c(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);