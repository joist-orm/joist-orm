"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9196],{3023:(e,n,o)=>{o.d(n,{R:()=>c,x:()=>l});var t=o(3696);const i={},s=t.createContext(i);function c(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(s.Provider,{value:n},e.children)}},3599:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"advanced/cloning","title":"Entity Cloning","description":"Joist supports cloning entities, to easily implement feature requests like \\"duplicate this author\\", or \\"duplicate this author and all of their books\\".","source":"@site/docs/advanced/cloning.md","sourceDirName":"advanced","slug":"/advanced/cloning","permalink":"/docs/advanced/cloning","draft":false,"unlisted":false,"editUrl":"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/advanced/cloning.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"title":"Entity Cloning","sidebar_position":4},"sidebar":"tutorialSidebar","previous":{"title":"Soft Deletes","permalink":"/docs/advanced/soft-deletes"},"next":{"title":"Large Collections","permalink":"/docs/advanced/large-collections"}}');var i=o(2540),s=o(3023);const c={title:"Entity Cloning",sidebar_position:4},l=void 0,a={},d=[{value:"Advanced Features",id:"advanced-features",level:3}];function r(e){const n={code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:'Joist supports cloning entities, to easily implement feature requests like "duplicate this author", or "duplicate this author and all of their books".'}),"\n",(0,i.jsxs)(n.p,{children:["To clone an entity, call ",(0,i.jsx)(n.code,{children:"em.clone"})," and pass a load-hint of the subgraph you want to be included in the ",(0,i.jsx)(n.code,{children:"clone"})," operation."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, to clone an ",(0,i.jsx)(n.code,{children:"Author"})," plus all of their ",(0,i.jsx)(n.code,{children:"Book"}),"s and all of the ",(0,i.jsx)(n.code,{children:"Book"}),"'s ",(0,i.jsx)(n.code,{children:"BookReview"}),"s, you can call:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const a1 = await em.load(Author, "a:1");\nconst a2 = await em.clone(a1, { books: "reviews" })\n'})}),"\n",(0,i.jsxs)(n.p,{children:["After the ",(0,i.jsx)(n.code,{children:"em.clone"})," is finished:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"a2"})," will be a copy of ",(0,i.jsx)(n.code,{children:"a1"})," with all the same primitive field values, but a new primary key/new identity"]}),"\n",(0,i.jsxs)(n.li,{children:["Each ",(0,i.jsx)(n.code,{children:"Book"})," in ",(0,i.jsx)(n.code,{children:"a1.books"})," will have a new ",(0,i.jsx)(n.code,{children:"Book"})," instance created, and be correctly hooked up to ",(0,i.jsx)(n.code,{children:"a2"})," instead of the original ",(0,i.jsx)(n.code,{children:"a1"})]}),"\n",(0,i.jsxs)(n.li,{children:["Each ",(0,i.jsx)(n.code,{children:"BookReview"})," in each ",(0,i.jsx)(n.code,{children:"a1.books.reviews"})," will have a new ",(0,i.jsx)(n.code,{children:"BookReview"})," instance created, and again be correctly up to the right newly-created ",(0,i.jsx)(n.code,{children:"Book"})," instance in ",(0,i.jsx)(n.code,{children:"a2.books"})]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:['Besides setting the correct "parent" ',(0,i.jsx)(n.code,{children:"book.author"})," to ",(0,i.jsx)(n.code,{children:"a2"})," for each cloned child ",(0,i.jsx)(n.code,{children:"Book"}),", any other references/FKs in the newly-created entities that happened to point to also-cloned input entities (like ",(0,i.jsx)(n.code,{children:"a1.favoriteBook"})," pointing to ",(0,i.jsx)(n.code,{children:"a1.books.get[0]"}),") are adjusted to point to the correct/corresponding newly-cloned output entity."]}),"\n",(0,i.jsx)(n.p,{children:"Basically Joist will keep the subgraph of cloned entities intact."}),"\n",(0,i.jsx)(n.h3,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,i.jsxs)(n.p,{children:["When calling ",(0,i.jsx)(n.code,{children:"em.clone"}),", you can provide three config options to customize the behavior:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"opts.deep"})," is the load hint from above, i.e. ",(0,i.jsx)(n.code,{children:'{ books: "reviews" }'}),", that specifies the subgraph to clone."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"opts.skipIf"})," is a function that accepts an entity and returns ",(0,i.jsx)(n.code,{children:"true"})," if that entity should be skipped/not cloned:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// This will duplicate the author\'s books, but skip any book where the title includes `sea`\nconst duplicatedBooks = await em.clone(\n  author.books.get,\n  { skipIf: (original) => original.title.includes("sea") }\n);\n'})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"opts.postClone"})," is a function that accepts both the original entity and its new clone, to allow customizing to the clone:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:"// This will duplicate the author's books, and assign them to a different author\nconst duplicatedBooks = await em.clone(\n  author.books.get,\n  { postClone: (_original, clone) => clone.author.set(author2) }\n);\n"})}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(r,{...e})}):r(e)}}}]);