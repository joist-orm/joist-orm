"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2611],{8080:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var i=n(4246),s=n(1670);const a={title:"Custom Jest Matcher",sidebar_position:4},o=void 0,r={id:"testing/entity-matcher",title:"Custom Jest Matcher",description:"Joist provides a toMatchEntity matcher for more pleasant assertions in Jest.",source:"@site/docs/testing/entity-matcher.md",sourceDirName:"testing",slug:"/testing/entity-matcher",permalink:"/docs/testing/entity-matcher",draft:!1,unlisted:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/testing/entity-matcher.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Custom Jest Matcher",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Fast Database Resets",permalink:"/docs/testing/fast-database-resets"},next:{title:"Test Utils",permalink:"/docs/testing/test-utils"}},c={},l=[{value:"Automatic Loading of Relations",id:"automatic-loading-of-relations",level:3},{value:"Prettier Output",id:"prettier-output",level:3},{value:"Installation",id:"installation",level:3}];function d(e){const t={admonition:"admonition",code:"code",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["Joist provides a ",(0,i.jsx)(t.code,{children:"toMatchEntity"})," matcher for more pleasant assertions in Jest."]}),"\n",(0,i.jsx)(t.p,{children:"There are two main benefits:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Automatic loading of relations"}),"\n",(0,i.jsx)(t.li,{children:"Prettier actual vs. expected output"}),"\n"]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["To use ",(0,i.jsx)(t.code,{children:"toMatchEntity"}),", you must have ",(0,i.jsx)(t.code,{children:"joist-test-utils"})," installed, which is not installed by default with Joist."]})}),"\n",(0,i.jsx)(t.h3,{id:"automatic-loading-of-relations",children:"Automatic Loading of Relations"}),"\n",(0,i.jsx)(t.p,{children:'A potentially unwieldy pattern in tests is asserting against a "subtree" of data that was not initially loaded, i.e.:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"const a1 = newAuthor(em);\n// Invoke something that adds books with reviews\nawait addBooksAndReviews(a1);\n// Because a1 is New we can access `books.get`, so this is easy...\nexpect(a1.books.get.length).toEqual(2);\n// But beyond that, we can't drill into each book's reviews\n// Compile error\nexpect(a1.books.get[0].reviews.get[0].title).toEqual(\"title\");\n"})}),"\n",(0,i.jsxs)(t.p,{children:["And so test code would have to explicitly load what it wants to assert against, either with a separate ",(0,i.jsx)(t.code,{children:"await b1.reviews.load()"}),' for each individual relation (which can be tedious), or by declaring a "2nd version" of the entity with a ',(0,i.jsx)(t.code,{children:"populate"})," load hint (which is better but also awkward):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'const a1 = newAuthor(em);\n// Invoke something that adds books with reviews\nawait addBooksAndReviews(a1);\n// Preload the subtree of data we want to assert against\nconst a1_2 = await a1.populate({ books: "reviews" });\n// Now we can use get\nexpect(a1_2.books.get.length).toEqual(2);\nexpect(a1_2.books.get[0].reviews.get[0].title).toEqual("title");\n'})}),"\n",(0,i.jsxs)(t.p,{children:["As a third option, ",(0,i.jsx)(t.code,{children:"toMatchEntity"})," provides a ",(0,i.jsx)(t.code,{children:"toMatchObject"}),"-style API so that a test can idiomatically declare what the subtree of data should be:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'const a1 = newAuthor(em);\n// Invoke something that adds books with reviews\nawait addBooksAndReviews(a1);\nexpect(a1).toMatchEntity({\n  books: [\n    {\n      title: "b1",\n      reviews: [{ rating: 5 }],\n    },\n    {\n      title: "b2",\n      reviews: [{ rating: 4 }, { rating: -2 }],\n    },\n  ],\n});\n'})}),"\n",(0,i.jsxs)(t.p,{children:['The upshot is that we get to assert against the entity "as if it\'s JSON" or "just data", and then ',(0,i.jsx)(t.code,{children:"toMatchEntity"})," takes care of loading the various references and collections."]}),"\n",(0,i.jsx)(t.h3,{id:"prettier-output",children:"Prettier Output"}),"\n",(0,i.jsxs)(t.p,{children:["Sometimes when entities are included in Jest failures, i.e. by Jest's native ",(0,i.jsx)(t.code,{children:"toMatchObject"}),', the Jest console output is ugly b/c Jest prints the internal implementation of the entity object (i.e. a failure for "expected ',(0,i.jsx)(t.code,{children:"a1"}),'" ends up printing the ',(0,i.jsx)(t.code,{children:"a1.books"})," field, which is actually a ",(0,i.jsx)(t.code,{children:"OneToManyCollection"})," with various internal flags/state, all of which are included in the output)."]}),"\n",(0,i.jsxs)(t.p,{children:["Even with ~3-4 entities in a native ",(0,i.jsx)(t.code,{children:"toMatchObject"})," assertion, the output can get long and hard to visually parse."]}),"\n",(0,i.jsxs)(t.p,{children:["Instead, ",(0,i.jsx)(t.code,{children:"toMatchEntity"}),' abbreviates each entity as simply its tagged id, so output for an assertion failure of "the collection expected two books of ',(0,i.jsx)(t.code,{children:"b:1"})," and ",(0,i.jsx)(t.code,{children:"b:2"})," but only had one ",(0,i.jsx)(t.code,{children:"b:2"}),'" will look like:']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:'- Expected  - 0\n+ Received  + 1\n\n  Object {</>\n    "books": Array [\n+     "b:1",\n      "b:2",\n    ],\n  }\n`);\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Note that if an entity is new, i.e. the test has not done ",(0,i.jsx)(t.code,{children:"em.flush"})," (which is fine, tests should only ",(0,i.jsx)(t.code,{children:"em.flush"})," if really necessary, to be as fast & lightweight as possible), the abbreviation for an unsaved ",(0,i.jsx)(t.code,{children:"Book"}),' will be a "test id" of ',(0,i.jsx)(t.code,{children:"b#1"})," where ",(0,i.jsx)(t.code,{children:"b"})," is the entity's tag, and the ",(0,i.jsx)(t.code,{children:"#1"})," is the index of that particular entity within the ",(0,i.jsx)(t.code,{children:"EntityManager"}),"'s entities of that type."]}),"\n",(0,i.jsx)(t.h3,{id:"installation",children:"Installation"}),"\n",(0,i.jsxs)(t.p,{children:["In your ",(0,i.jsx)(t.code,{children:"setupTests.ts"}),", add:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'import { toMatchEntity } from "joist-test-utils";\n\nexpect.extend({ toMatchEntity });\n'})})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1670:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var i=n(7378);const s={},a=i.createContext(s);function o(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);