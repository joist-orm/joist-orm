"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[592],{4951:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var i=t(4246),s=t(1670);const l={title:"Partial Update APIs"},a=void 0,o={id:"features/partial-update-apis",title:"Partial Update APIs",description:'Joist has built-in support for building "partial update"-style APIs on top of your domain model.',source:"@site/docs/features/partial-update-apis.md",sourceDirName:"features",slug:"/features/partial-update-apis",permalink:"/docs/features/partial-update-apis",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/features/partial-update-apis.md",tags:[],version:"current",frontMatter:{title:"Partial Update APIs"},sidebar:"tutorialSidebar",previous:{title:"Cascading Deletes",permalink:"/docs/features/cascade-deletes"},next:{title:"Unit of Work",permalink:"/docs/advanced/unit-of-work"}},r={},d=[{value:"Unsetting Fields with <code>null</code> Marker",id:"unsetting-fields-with-null-marker",level:2},{value:"Saving Parents with Children",id:"saving-parents-with-children",level:2},{value:"Incremental Collection Updates",id:"incremental-collection-updates",level:2},{value:"Legacy Incremental Collection Updates",id:"legacy-incremental-collection-updates",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:'Joist has built-in support for building "partial update"-style APIs on top of your domain model.'}),"\n",(0,i.jsx)(n.p,{children:"Partial update APIs, whether they are implemented over REST or GraphQL or GRPC, typically follow the conventions of:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A create or update can include only a subset of fields, and any field not included in the subset is left as-is"}),"\n",(0,i.jsxs)(n.li,{children:["An update can use ",(0,i.jsx)(n.code,{children:"null"}),' as a marker to mean "unset this field"']}),"\n",(0,i.jsx)(n.li,{children:"Updating a parent's collection of children can be done incrementally, i.e. w/o knowing the full set of children"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Joist has dedicated ",(0,i.jsx)(n.code,{children:"EntityManager.createOrUpdatePartial"})," and ",(0,i.jsx)(n.code,{children:"Entity.setPartial"})," APIs to help implement APIs that follow these conventions with as little boilerplate as possible."]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["These methods are particularly useful for implementing GraphQL APIs, where Joist's normal ",(0,i.jsx)(n.code,{children:"EntityManager.create"})," and ",(0,i.jsx)(n.code,{children:"Entity.set"})," methods have TypeScript types that are too strict for GraphQL's looser/less strict type system."]}),(0,i.jsxs)(n.p,{children:["For example, a ",(0,i.jsx)(n.code,{children:"SaveAuthorInput"})," ",(0,i.jsx)(n.code,{children:"firstName"})," that is generated by ",(0,i.jsx)(n.a,{href:"https://graphql-code-generator.com",children:"graphql-code-generator"})," might be typed as ",(0,i.jsx)(n.code,{children:"firstName: string | null | undefined"})," which does not match Joist's more idiomatic ",(0,i.jsx)(n.code,{children:"Author.firstName: string | undefined"})," typing."]})]}),"\n",(0,i.jsxs)(n.h2,{id:"unsetting-fields-with-null-marker",children:["Unsetting Fields with ",(0,i.jsx)(n.code,{children:"null"})," Marker"]}),"\n",(0,i.jsxs)(n.p,{children:["A common pattern for partial-update style APIs is to treat ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"undefined"})," differently, i.e. ",(0,i.jsx)(n.code,{children:"{ firstName: null }"}),' specifically means "unset the ',(0,i.jsx)(n.code,{children:"firstName"}),' property", while ',(0,i.jsx)(n.code,{children:"firstName"})," being not present (i.e. either ",(0,i.jsx)(n.code,{children:"{ firstName: undefined }"})," or an empty ",(0,i.jsx)(n.code,{children:"{}"}),') means "do not change ',(0,i.jsx)(n.code,{children:"firstName"}),'".']}),"\n",(0,i.jsxs)(n.p,{children:["As mentioned, in a GraphQL input type this might be typed as ",(0,i.jsx)(n.code,{children:"SaveAuthorInput"})," having a ",(0,i.jsx)(n.code,{children:"firstName: string | null | undefined"})," field."]}),"\n",(0,i.jsxs)(n.p,{children:["Normally the ",(0,i.jsx)(n.code,{children:"null"}),"-ness of input's ",(0,i.jsx)(n.code,{children:"firstName"})," will cause issues with Joist's \"preferred ",(0,i.jsx)(n.code,{children:"undefined"}),'" convention:']}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// This is typed as string | null | undefined\nconst { firstName } = saveAuthorInput;\nconst author = em.load(Author, "1");\n// The normal `.set` will not compile\nauthor.set({ firstName });\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Instead, Joist provides a ",(0,i.jsx)(n.code,{children:"setPartial"})," that allows code to opt-in to the partial-semantic behavior and an RPC layer's potentially-less-strict typing:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// This is typed as string | null | undefined\nconst { firstName } = saveAuthorInput;\nconst author = em.load(Author, "1");\n// Compiles successfully\nauthor.setPartial({ firstName });\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Specifically, the semantics of ",(0,i.jsx)(n.code,{children:"Entity.setPartial"})," is that:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["For a required field ",(0,i.jsx)(n.code,{children:"firstName"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'{ firstName: "foo" }'})," will update ",(0,i.jsx)(n.code,{children:"firstName"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{ firstName: undefined }"})," will do nothing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{ firstName: null }"})," will cause a validation error b/c ",(0,i.jsx)(n.code,{children:"firstName"})," is required and cannot be ",(0,i.jsx)(n.code,{children:"null"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["For an optional field ",(0,i.jsx)(n.code,{children:"lastName"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'{ lastName: "bar" }'})," will update ",(0,i.jsx)(n.code,{children:"lastName"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{ lastName: undefined }"})," will do nothing"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{ lastName: null }"})," will unset ",(0,i.jsx)(n.code,{children:"lastName"})," (i.e. set it as ",(0,i.jsx)(n.code,{children:"undefined"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["For collections like ",(0,i.jsx)(n.code,{children:"books"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{ books: [b1] }"})," will set the collection to ",(0,i.jsx)(n.em,{children:"just"})," ",(0,i.jsx)(n.code,{children:"b1"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{ books: null }"})," will set the collection to ",(0,i.jsx)(n.code,{children:"[]"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"{ books: undefined }"})," will do nothing"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"EntityManager.createPartial"})," and ",(0,i.jsx)(n.code,{children:"EntityManager.createOrUpdatePartial"})," methods both have these semantics as well."]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["Arguably, the ideal partial-update type for ",(0,i.jsx)(n.code,{children:"Author"})," in this scenario would be:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface SaveAuthorInput {\n  firstName: string | undefined;\n  lastName: string | null | undefined;\n}\n"})}),(0,i.jsxs)(n.p,{children:["But sometimes it's a challenge to get the RPC framework, e.g. GraphQL in this instance, to generate a type that exactly matches this, which is why Joist offers these more flexible ",(0,i.jsx)(n.code,{children:"setPartial"})," methods."]})]}),"\n",(0,i.jsx)(n.h2,{id:"saving-parents-with-children",children:"Saving Parents with Children"}),"\n",(0,i.jsxs)(n.p,{children:["To save both a parent and multiple potentially-new-or-existing children, Joist provides ",(0,i.jsx)(n.code,{children:"EntityManager.createOrUpdatePartial"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"An example usage is:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Given some RPC types (in this instance GraphQL)\ninterface SaveAuthorInput {\n  id?: string | null;\n  firstName?: string | null;\n  books?: SaveBookInput[];\n}\ninterface SaveBookInput {\n  id?: string | null;\n  title?: string | null;\n  \n}\n\n// When the client\'s request comes in...\nconst input: SaveAuthorInput = {\n  // Updating author 1\n  id: "a:1",\n  // To have 3 books\n  books: [\n    // And the 1st book is new\n    { title: "new book" },\n    // And the 2nd book already exists but has no changes\n    { id: "b:1" },\n    // And the 3rd book already exists but has a new title \n    { id: "b:2", title: "updated" },\n  ]\n}\n\n// Then we can apply all of those changes via\n// a single call\nawait em.createOrUpdatePartial(Author, input);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Admittedly, your RPC/GraphQL API convention for parent/children inputs has to fairly closely follow what Joist's own partial update / ",(0,i.jsx)(n.code,{children:"createOrUpdatePartial"})," convention, but assuming you do so, Joist can reduce a very large amount of CRUD boilerplate in an RPC/GraphQL API."]}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsxs)(n.p,{children:["Unlike ",(0,i.jsx)(n.code,{children:"EntityManager.create"}),", which is synchronous, ",(0,i.jsx)(n.code,{children:"EntityManager.createOrUpdatePartial"})," is async and needs to be ",(0,i.jsx)(n.code,{children:"await"}),"-d because it may require SQL calls to look up existing entities, e.g. the ",(0,i.jsx)(n.code,{children:"b:1"})," and ",(0,i.jsx)(n.code,{children:"b:2"})," IDs in the above example."]})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Joist's ",(0,i.jsx)(n.code,{children:"createOrUpdatePartial"})," behavior, while developed independently, is effectively similar Objection.js's ",(0,i.jsx)(n.a,{href:"https://vincit.github.io/objection.js/guide/query-examples.html#graph-upserts",children:(0,i.jsx)(n.code,{children:"upsertGraph"})})," operation."]})}),"\n",(0,i.jsx)(n.h2,{id:"incremental-collection-updates",children:"Incremental Collection Updates"}),"\n",(0,i.jsxs)(n.p,{children:["Joist's default behavior for any collection set (e.g. ",(0,i.jsx)(n.code,{children:"Entity.set"}),", ",(0,i.jsx)(n.code,{children:"Entity.setPartial"}),", ",(0,i.jsx)(n.code,{children:"EntityManger.createOrUpdatePartial"}),", etc.) is for the collection to be exhaustively set to the new value, for example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const author = newAuthor(em);\n// Start out with two books\nauthor.set({ books: [b1, b2] });\n// Later set with a third book\nauthor.set({ books: [b3] });\n// Passes b/c `set` has implicitly removed the 1st two books\nexpect(author.books.get.length).toEqual(1);\n"})}),"\n",(0,i.jsx)(n.p,{children:"However, when partially updating entities via an RPC call, it's often convenient to change only a single child of the collection, especially for APIs where the child itself doesn't have a dedicated operation (i.e. saving an invoice line item can only be done via the invoice API)."}),"\n",(0,i.jsxs)(n.p,{children:["To support these APIs, ",(0,i.jsx)(n.code,{children:"setPartial"})," and ",(0,i.jsx)(n.code,{children:"createOrUpdatePartial"})," will both opt-in to incremental collection semantics if they detect an extra ",(0,i.jsx)(n.code,{children:"op"})," hint key on the children. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const author = newAuthor(em);\n// Start out with two books\nauthor.set({ books: [b1, b2] });\n// Later add a third book\nauthor.setPartial({ books: [\n  // And include the `op` hint\n  { op: "include", title: "b3" }\n]});\n// Passes b/c `setPartial` saw `op` and worked incrementally\nexpect(author.books.get.length).toEqual(3);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The valid values of an ",(0,i.jsx)(n.code,{children:"op"})," keyword are:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'{ op: "delete", id: ... }'})," will remove the child and ",(0,i.jsx)(n.code,{children:"EntityManager.delete"})," it for hard deletion"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'{ op: "remove", id: ... }'})," will remove the child but not call ",(0,i.jsx)(n.code,{children:"EntityManager.delete"})]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:'{ op: "include", id: ... }'})," will include (i.e. add if needed, or just update if it already an existing child) the child"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["If any child has an ",(0,i.jsx)(n.code,{children:"op"})," key, then all children must have an ",(0,i.jsx)(n.code,{children:"op"})," key, to be the most clear/consistent to the caller that incremental semantics are being used."]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"op"})," key is not an actual column stored in your database or domain model, i.e. the ",(0,i.jsx)(n.code,{children:"Book"})," entity should not have an ",(0,i.jsx)(n.code,{children:"op"})," field."]}),(0,i.jsxs)(n.p,{children:["Instead, ",(0,i.jsx)(n.code,{children:"op"})," can be just an extra key on the RPC/GraphQL input types to specifically driven Joist's incremental collection semantics."]}),(0,i.jsxs)(n.p,{children:["The key name ",(0,i.jsx)(n.code,{children:"op"})," was chosen for both succinctness and also low probably of overlapping with real fields in the domain model."]})]}),"\n",(0,i.jsxs)(n.admonition,{type:"caution",children:[(0,i.jsxs)(n.p,{children:["Because incremental semantics are enabled by the presence of an ",(0,i.jsx)(n.code,{children:"op"})," key, if the collection is empty it will fundamentally look like an exhaustive set that clears the collection."]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// An empty collection will always clear the books, and can't be\n// treated as a incremental operation\nauthor.setPartial({ books: [] });\n"})}),(0,i.jsx)(n.p,{children:'This means that if a client is trying to optimize its call by sending "only changed children", when no children have been changed then it should not include the child key in the payload at all, to avoid unintentionally clearing the collection.'}),(0,i.jsxs)(n.p,{children:["Technically, Joist currently supports a 4th ",(0,i.jsx)(n.code,{children:'{ op: "incremental" }'}),' keyword that can act as a "fake child" and will be ignored (i.e. not treated as an entity to add/remove from the collection), but will still enable incremental semantics and so avoid the "empty list clears the collection" gotcha.']})]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["If you're working in React, the ",(0,i.jsx)(n.a,{href:"https://github.com/homebound-team/form-state/",children:"form-state"})," library has built-in knowledge of Joist's ",(0,i.jsx)(n.code,{children:"op"})," keyword/incremental collection semantics and makes it easy to craft optimized/only-what-changed payloads with a single ",(0,i.jsx)(n.code,{children:"form.changedValue"})," call."]})}),"\n",(0,i.jsx)(n.h2,{id:"legacy-incremental-collection-updates",children:"Legacy Incremental Collection Updates"}),"\n",(0,i.jsxs)(n.p,{children:["Joist's initial version of incremental updates used separate ",(0,i.jsx)(n.code,{children:"delete"})," and ",(0,i.jsx)(n.code,{children:"remove"})," keys instead of ",(0,i.jsx)(n.code,{children:"op"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const author = newAuthor(em);\n// Start out with three books\nauthor.set({ books: [b1, b2, b3] });\n// Then delete b1, remove b2, leave b3 alone, and add b4\nauthor.setPartial({ books: [\n  { id: "b:1", delete: true },\n  { id: "b:2", remove: true },\n  { id: "b:4" },\n]});\n'})}),"\n",(0,i.jsxs)(n.p,{children:["These are still supported, but are soft-deprecated and the ",(0,i.jsx)(n.code,{children:"op"})," key is preferred going forward."]}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsxs)(n.p,{children:["We moved away from ",(0,i.jsx)(n.code,{children:"delete"})," and ",(0,i.jsx)(n.code,{children:"remove"})," keywords for two reasons:"]}),(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"They are more likely to overlap with existing fields in the domain model, and"}),"\n",(0,i.jsxs)(n.li,{children:["It is ergonomically easier for our frontend UI to bind to an always-present ",(0,i.jsx)(n.code,{children:"op"})," key, and just flip its value from ",(0,i.jsx)(n.code,{children:"include"}),"/",(0,i.jsx)(n.code,{children:"delete"})," when the user toggles adding/removing rows, instead of adding/removing entire ",(0,i.jsx)(n.code,{children:"delete"})," / ",(0,i.jsx)(n.code,{children:"remove"})," keys."]}),"\n"]})]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>a});var i=t(7378);const s={},l=i.createContext(s);function a(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);