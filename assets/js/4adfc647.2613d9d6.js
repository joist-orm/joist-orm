"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2262],{5566:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>d,toc:()=>r});var a=t(4246),i=t(1670);const s={title:"Unit of Work",sidebar_position:1},o=void 0,d={id:"advanced/unit-of-work",title:"Unit of Work",description:"Joist's EntityManager acts as a Unit of Work, which allows it to provide several features:",source:"@site/docs/advanced/unit-of-work.md",sourceDirName:"advanced",slug:"/advanced/unit-of-work",permalink:"/docs/advanced/unit-of-work",draft:!1,unlisted:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/advanced/unit-of-work.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Unit of Work",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Partial Update APIs",permalink:"/docs/features/partial-update-apis"},next:{title:"Tagged Ids",permalink:"/docs/advanced/tagged-ids"}},c={},r=[{value:"Per-Request Entity Caching",id:"per-request-entity-caching",level:2},{value:"Per-Request Data Consistency",id:"per-request-data-consistency",level:2},{value:"Automatically Batching Updates",id:"automatically-batching-updates",level:2},{value:"Automatically Using Transactions",id:"automatically-using-transactions",level:2},{value:"Enforcing Hooks and Derived Values",id:"enforcing-hooks-and-derived-values",level:2},{value:"Note: Not a Shared/Distributed Cache",id:"note-not-a-shareddistributed-cache",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["Joist's ",(0,a.jsx)(n.code,{children:"EntityManager"})," acts as a ",(0,a.jsx)(n.a,{href:"https://www.martinfowler.com/eaaCatalog/unitOfWork.html",children:"Unit of Work"}),", which allows it to provide several features:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Per-request entity caching"}),"\n",(0,a.jsx)(n.li,{children:"Per-request data consistency"}),"\n",(0,a.jsx)(n.li,{children:"Automatically batching updates"}),"\n",(0,a.jsx)(n.li,{children:"Automatically using transactions"}),"\n",(0,a.jsx)(n.li,{children:"Enforcing hooks and reactive values"}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"per-request-entity-caching",children:"Per-Request Entity Caching"}),"\n",(0,a.jsxs)(n.p,{children:["Typically with Joist, one ",(0,a.jsx)(n.code,{children:"EntityManager"})," is created per request, e.g. handling ",(0,a.jsx)(n.code,{children:"POST /book/new"})," creates one ",(0,a.jsx)(n.code,{children:"EntityManager"})," to (say) load ",(0,a.jsx)(n.code,{children:"em.load"})," the new book's ",(0,a.jsx)(n.code,{children:"Author"})," (from the post data), create a new ",(0,a.jsx)(n.code,{children:"Book"})," instance, and then save it to the database by calling ",(0,a.jsx)(n.code,{children:"em.flush()"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Once created for a request, the ",(0,a.jsx)(n.code,{children:"EntityManager"})," instance will cache each row it loads from the database, and not reload it, even if multiple ",(0,a.jsx)(n.code,{children:"SELECT * FROM books WHERE ..."}),' queries bring back "the same row" twice.']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'const a = await em.find(Author, { id: "a:1" });\nconst b = await em.find(Author, { id: "a:1" });\nconst c = await em.load(Author, "a:1"); // no SQL call issued\nconst d = await book1.author.load(); // no SQL call issued\n// All print true\nconsole.log(a === b);\nconsole.log(a === c);\nconsole.log(a === d);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This caching avoids reloading the ",(0,a.jsx)(n.code,{children:"Author"})," from the database if other code loads it (for example validation rules within ",(0,a.jsx)(n.code,{children:"Book"})," or ",(0,a.jsx)(n.code,{children:"Author"})," calling ",(0,a.jsx)(n.code,{children:"book.author.load()"})," will avoid a ",(0,a.jsx)(n.code,{children:"SELECT"})," call if the author for that ",(0,a.jsx)(n.code,{children:"id"})," is already in the ",(0,a.jsx)(n.code,{children:"EntityManager"}),")."]}),"\n",(0,a.jsxs)(n.p,{children:["This caching also works for references & collections: for example if two places both call ",(0,a.jsx)(n.code,{children:"a1.books.load()"}),', because Joist has ensured there is only "one ',(0,a.jsx)(n.code,{children:"a1"})," instance\" for this request, we don't need to issue two ",(0,a.jsx)(n.code,{children:"SELECT * FROM books WHERE author_id = 1"})," queries."]}),"\n",(0,a.jsxs)(n.p,{children:["Granted, in simple endpoints with no abstractions or complicated business logic, this caching is likely not a big deal; but once a codebase grows and access patterns get complicated (i.e. in GraphQL resolvers or validation rules/business logics), not constantly refetching the same ",(0,a.jsx)(n.code,{children:"Author id=1"})," row in the database is a nice win."]}),"\n",(0,a.jsx)(n.h2,{id:"per-request-data-consistency",children:"Per-Request Data Consistency"}),"\n",(0,a.jsx)(n.p,{children:"An additional upshot of entity caching (which focuses on avoiding reloads) is data consistency."}),"\n",(0,a.jsx)(n.p,{children:"Specifically, because there is \"only one instance\" of an entity/row, any changes we've made to the entity are defacto seen by the rest of the endpoint's code."}),"\n",(0,a.jsxs)(n.p,{children:["Without this Unit-of-Work/",(0,a.jsx)(n.code,{children:"EntityManager"}),' pattern, it\'s possible for code to have "out of date" versions of an entity.']}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'function updateAuthor(a) {\n  a.firstName = "bob";\n}\n\nfunction outputAuthor(id) {\n  // if this was like Rails ActiveRecord, we get a different view of author\n  const a = Author.find_by_id(id)\n  // Now we\'ve output inconsistent/stale data\n  console.log(a.firstName)\n}\n\nconst a = Author.find_by_id(id)\nupdateAuthor(a)\noutputAuthor(id)\n'})}),"\n",(0,a.jsxs)(n.p,{children:["With Joist, the ",(0,a.jsx)(n.code,{children:"Author.find_by_id(id)"})," would be ",(0,a.jsx)(n.code,{children:"em.load(Author, id)"}),", which means we'd get back the existing ",(0,a.jsx)(n.code,{children:"a"})," instance, and so can fundamentally no longer accidentally see old/stale data."]}),"\n",(0,a.jsxs)(n.p,{children:['This pattern generally makes reasoning about "what have I changed so far?", "what is the latest version of the entity?" much easier, because when handling a given ',(0,a.jsx)(n.code,{children:"POST"})," / API update, you don't have to worry about various parts of your code having stale/different versions of the ",(0,a.jsx)(n.code,{children:"Author"}),"."]}),"\n",(0,a.jsx)(n.h2,{id:"automatically-batching-updates",children:"Automatically Batching Updates"}),"\n",(0,a.jsxs)(n.p,{children:["With Joist, each endpoint will generally make a single call to ",(0,a.jsx)(n.code,{children:"EntityManager.flush"})," to save its changes."]}),"\n",(0,a.jsxs)(n.p,{children:["This ",(0,a.jsx)(n.code,{children:"em.flush"})," call can seem like extra work, but it means Joist can:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Apply all validation rules to changed entities at once/in-parallel"}),"\n",(0,a.jsxs)(n.li,{children:["Issue batch ",(0,a.jsx)(n.code,{children:"INSERT"}),"/",(0,a.jsx)(n.code,{children:"UPDATE"})," commands for all changed entities"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"automatically-using-transactions",children:"Automatically Using Transactions"}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.code,{children:"EntityManager.flush"}),", all ",(0,a.jsx)(n.code,{children:"INSERT"}),"s, ",(0,a.jsx)(n.code,{children:"UPDATE"}),"s, and ",(0,a.jsx)(n.code,{children:"DELETE"}),"s for a single request are automatically applied with a single transaction."]}),"\n",(0,a.jsxs)(n.p,{children:["Without this ",(0,a.jsx)(n.code,{children:"flush"})," pattern, endpoints need to explicitly opt-in to transactions by manually demarking when the transaction starts/stops, i.e. in Rails ActiveRecord:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ruby",children:"Account.transaction do\n  balance.save!\n  account.save!\nend\n"})}),"\n",(0,a.jsx)(n.p,{children:"And because it is opt-in, most endpoints forget/do not bother doing this."}),"\n",(0,a.jsxs)(n.p,{children:["However, transactions are so fundamental to the pleasantness of Postgres and relational databases, that Joist's assertion is that ",(0,a.jsx)(n.strong,{children:"transactions should always be used by default"}),", and not just opt-in."]}),"\n",(0,a.jsx)(n.h2,{id:"enforcing-hooks-and-derived-values",children:"Enforcing Hooks and Derived Values"}),"\n",(0,a.jsx)(n.p,{children:'Joist\'s goal is not to be "just a query builder", but to facilitate building a rich domain model.'}),"\n",(0,a.jsxs)(n.p,{children:["Part of a rich domain model is having ",(0,a.jsx)(n.a,{href:"../modeling/lifecycle-hooks",children:"lifecycle hooks"})," (",(0,a.jsx)(n.code,{children:"beforeFlush"}),", ",(0,a.jsx)(n.code,{children:"afterCreate"}),") and ",(0,a.jsx)(n.a,{href:"/docs/modeling/derived-fields",children:"reactive derived values"}),", both of which allow enforcing invariants/business rules on entities other than the primary entity being changed."]}),"\n",(0,a.jsxs)(n.p,{children:["For example, adding a ",(0,a.jsx)(n.code,{children:"Book"})," might recalc the ",(0,a.jsx)(n.code,{children:"Author.numberOfBooks"})," derived value."]}),"\n",(0,a.jsxs)(n.p,{children:["Or adding a ",(0,a.jsx)(n.code,{children:"Book"})," might schedule a job to index its content in a background job/lambda."]}),"\n",(0,a.jsxs)(n.p,{children:["For these use cases, the behavior that happens during ",(0,a.jsx)(n.code,{children:"em.flush"}),' is not "just" ',(0,a.jsx)(n.code,{children:"author1.save"}),", or ",(0,a.jsx)(n.code,{children:"book2.update"}),", but more holistically evaluating the entities that have changed and deciding what, if any, reactive/derived behavior should also update to maintain the system's business invariants."]}),"\n",(0,a.jsx)(n.h2,{id:"note-not-a-shareddistributed-cache",children:"Note: Not a Shared/Distributed Cache"}),"\n",(0,a.jsxs)(n.p,{children:["Note that, because it's intended to be used per-request, the ",(0,a.jsx)(n.code,{children:"EntityManager"})," is not a shared/second-level cache, i.e. a cache that would be shared across multiple requests to your webapp/API to reduce calls to the relational database."]}),"\n",(0,a.jsxs)(n.p,{children:["An ",(0,a.jsx)(n.code,{children:"EntityManager"})," should only be used by a single request, and so the cache is request scoped."]}),"\n",(0,a.jsx)(n.p,{children:"Granted, shared/second-level caches can be a good idea, but it means you have to worry about cache invalidation and staleness strategies, so for now Joist avoids that complexity."})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>d,a:()=>o});var a=t(7378);const i={},s=a.createContext(i);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);