"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[262],{5318:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(7378);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(a),h=i,m=u["".concat(s,".").concat(h)]||u[h]||p[h]||o;return a?n.createElement(m,r(r({ref:t},c),{},{components:a})):n.createElement(m,r({ref:t},c))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var d=2;d<o;d++)r[d]=a[d];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9051:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var n=a(2685),i=(a(7378),a(5318));const o={title:"Unit of Work",sidebar_position:1},r=void 0,l={unversionedId:"advanced/unit-of-work",id:"advanced/unit-of-work",title:"Unit of Work",description:"Joist's EntityManager acts as a Unit of Work, which allows it to provide several features:",source:"@site/docs/advanced/unit-of-work.md",sourceDirName:"advanced",slug:"/advanced/unit-of-work",permalink:"/docs/advanced/unit-of-work",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/advanced/unit-of-work.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Unit of Work",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Partial Update APIs",permalink:"/docs/features/partial-update-apis"},next:{title:"Tagged Ids",permalink:"/docs/advanced/tagged-ids"}},s={},d=[{value:"Per-Request Entity Caching",id:"per-request-entity-caching",level:2},{value:"Per-Request Data Consistency",id:"per-request-data-consistency",level:2},{value:"Automatically Batching Updates",id:"automatically-batching-updates",level:2},{value:"Automatically Using Transactions",id:"automatically-using-transactions",level:2},{value:"Enforcing Hooks and Derived Values",id:"enforcing-hooks-and-derived-values",level:2},{value:"Note: Not a Shared/Distributed Cache",id:"note-not-a-shareddistributed-cache",level:2}],c={toc:d};function p(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Joist's ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager")," acts as a ",(0,i.kt)("a",{parentName:"p",href:"https://www.martinfowler.com/eaaCatalog/unitOfWork.html"},"Unit of Work"),", which allows it to provide several features:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Per-request entity caching"),(0,i.kt)("li",{parentName:"ol"},"Per-request data consistency"),(0,i.kt)("li",{parentName:"ol"},"Automatically batching updates"),(0,i.kt)("li",{parentName:"ol"},"Automatically using transactions"),(0,i.kt)("li",{parentName:"ol"},"Enforcing hooks and reactive values")),(0,i.kt)("h2",{id:"per-request-entity-caching"},"Per-Request Entity Caching"),(0,i.kt)("p",null,"Typically with Joist, one ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager")," is created per request, e.g. handling ",(0,i.kt)("inlineCode",{parentName:"p"},"POST /book/new")," creates one ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager")," to (say) load ",(0,i.kt)("inlineCode",{parentName:"p"},"em.load")," the new book's ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," (from the post data), create a new ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," instance, and then save it to the database by calling ",(0,i.kt)("inlineCode",{parentName:"p"},"em.flush()"),"."),(0,i.kt)("p",null,"Once created for a request, the ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager")," instance will cache each row it loads from the database, and not reload it, even if multiple ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT * FROM books WHERE ..."),' queries bring back "the same row" twice.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const a = await em.find(Author, { id: "a:1" });\nconst b = await em.find(Author, { id: "a:1" });\nconst c = await em.load(Author, "a:1"); // no SQL call issued\nconst d = await book1.author.load(); // no SQL call issued\n// All print true\nconsole.log(a === b);\nconsole.log(a === c);\nconsole.log(a === d);\n')),(0,i.kt)("p",null,"This caching avoids reloading the ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," from the database if other code loads it (for example validation rules within ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," calling ",(0,i.kt)("inlineCode",{parentName:"p"},"book.author.load()")," will avoid a ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT")," call if the author for that ",(0,i.kt)("inlineCode",{parentName:"p"},"id")," is already in the ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager"),")."),(0,i.kt)("p",null,"This caching also works for references & collections: for example if two places both call ",(0,i.kt)("inlineCode",{parentName:"p"},"a1.books.load()"),', because Joist has ensured there is only "one ',(0,i.kt)("inlineCode",{parentName:"p"},"a1")," instance\" for this request, we don't need to issue two ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT * FROM books WHERE author_id = 1")," queries."),(0,i.kt)("p",null,"Granted, in simple endpoints with no abstractions or complicated business logic, this caching is likely not a big deal; but once a codebase grows and access patterns get complicated (i.e. in GraphQL resolvers or validation rules/business logics), not constantly refetching the same ",(0,i.kt)("inlineCode",{parentName:"p"},"Author id=1")," row in the database is a nice win."),(0,i.kt)("h2",{id:"per-request-data-consistency"},"Per-Request Data Consistency"),(0,i.kt)("p",null,"An additional upshot of entity caching (which focuses on avoiding reloads) is data consistency."),(0,i.kt)("p",null,"Specifically, because there is \"only one instance\" of an entity/row, any changes we've made to the entity are defacto seen by the rest of the endpoint's code."),(0,i.kt)("p",null,"Without this Unit-of-Work/",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager"),' pattern, it\'s possible for code to have "out of date" versions of an entity.'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'function updateAuthor(a) {\n  a.firstName = "bob";\n}\n\nfunction outputAuthor(id) {\n  // if this was like Rails ActiveRecord, we get a different view of author\n  const a = Author.find_by_id(id)\n  // Now we\'ve output inconsistent/stale data\n  console.log(a.firstName)\n}\n\nconst a = Author.find_by_id(id)\nupdateAuthor(a)\noutputAuthor(id)\n')),(0,i.kt)("p",null,"With Joist, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Author.find_by_id(id)")," would be ",(0,i.kt)("inlineCode",{parentName:"p"},"em.load(Author, id)"),", which means we'd get back the existing ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," instance, and so can fundamentally no longer accidentally see old/stale data."),(0,i.kt)("p",null,'This pattern generally makes reasoning about "what have I changed so far?", "what is the latest version of the entity?" much easier, because when handling a given ',(0,i.kt)("inlineCode",{parentName:"p"},"POST")," / API update, you don't have to worry about various parts of your code having stale/different versions of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Author"),"."),(0,i.kt)("h2",{id:"automatically-batching-updates"},"Automatically Batching Updates"),(0,i.kt)("p",null,"With Joist, each endpoint will generally make a single call to ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager.flush")," to save its changes."),(0,i.kt)("p",null,"This ",(0,i.kt)("inlineCode",{parentName:"p"},"em.flush")," call can seem like extra work, but it means Joist can:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Apply all validation rules to changed entities at once/in-parallel"),(0,i.kt)("li",{parentName:"ul"},"Issue batch ",(0,i.kt)("inlineCode",{parentName:"li"},"INSERT"),"/",(0,i.kt)("inlineCode",{parentName:"li"},"UPDATE")," commands for all changed entities")),(0,i.kt)("h2",{id:"automatically-using-transactions"},"Automatically Using Transactions"),(0,i.kt)("p",null,"With ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager.flush"),", all ",(0,i.kt)("inlineCode",{parentName:"p"},"INSERT"),"s, ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE"),"s, and ",(0,i.kt)("inlineCode",{parentName:"p"},"DELETE"),"s for a single request are automatically applied with a single transaction."),(0,i.kt)("p",null,"Without this ",(0,i.kt)("inlineCode",{parentName:"p"},"flush")," pattern, endpoints need to explicitly opt-in to transactions by manually demarking when the transaction starts/stops, i.e. in Rails ActiveRecord:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ruby"},"Account.transaction do\n  balance.save!\n  account.save!\nend\n")),(0,i.kt)("p",null,"And because it is opt-in, most endpoints forget/do not bother doing this."),(0,i.kt)("p",null,"However, transactions are so fundamental to the pleasantness of Postgres and relational databases, that Joist's assertion is that ",(0,i.kt)("strong",{parentName:"p"},"transactions should always be used by default"),", and not just opt-in."),(0,i.kt)("h2",{id:"enforcing-hooks-and-derived-values"},"Enforcing Hooks and Derived Values"),(0,i.kt)("p",null,'Joist\'s goal is not to be "just a query builder", but to facilitate building a rich domain model.'),(0,i.kt)("p",null,"Part of a rich domain model is having ",(0,i.kt)("a",{parentName:"p",href:"../modeling/lifecycle-hooks"},"lifecycle hooks")," (",(0,i.kt)("inlineCode",{parentName:"p"},"beforeFlush"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"afterCreate"),") and ",(0,i.kt)("a",{parentName:"p",href:"/docs/modeling/derived-fields"},"reactive derived values"),", both of which allow enforcing invariants/business rules on entities other than the primary entity being changed."),(0,i.kt)("p",null,"For example, adding a ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," might recalc the ",(0,i.kt)("inlineCode",{parentName:"p"},"Author.numberOfBooks")," derived value."),(0,i.kt)("p",null,"Or adding a ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," might schedule a job to index its content in a background job/lambda."),(0,i.kt)("p",null,"For these use cases, the behavior that happens during ",(0,i.kt)("inlineCode",{parentName:"p"},"em.flush"),' is not "just" ',(0,i.kt)("inlineCode",{parentName:"p"},"author1.save"),", or ",(0,i.kt)("inlineCode",{parentName:"p"},"book2.update"),", but more holistically evaluating the entities that have changed and deciding what, if any, reactive/derived behavior should also update to maintain the system's business invariants."),(0,i.kt)("h2",{id:"note-not-a-shareddistributed-cache"},"Note: Not a Shared/Distributed Cache"),(0,i.kt)("p",null,"Note that, because it's intended to be used per-request, the ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager")," is not a shared/second-level cache, i.e. a cache that would be shared across multiple requests to your webapp/API to reduce calls to the relational database."),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager")," should only be used by a single request, and so the cache is request scoped."),(0,i.kt)("p",null,"Granted, shared/second-level caches can be a good idea, but it means you have to worry about cache invalidation and staleness strategies, so for now Joist avoids that complexity."))}p.isMDXComponent=!0}}]);