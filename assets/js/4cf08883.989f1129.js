"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8174],{3729:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>d,toc:()=>o});var t=n(4246),s=n(1670);const l={title:"Reactive Fields",sidebar_position:4},a=void 0,d={id:"modeling/reactive-fields",title:"Reactive Fields",description:"In Joist, Reactive Fields are values that can be calculated/derived from other data within your domain model, for example:",source:"@site/docs/modeling/reactive-fields.md",sourceDirName:"modeling",slug:"/modeling/reactive-fields",permalink:"/docs/modeling/reactive-fields",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/modeling/reactive-fields.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Reactive Fields",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Relations",permalink:"/docs/modeling/relations"},next:{title:"Derived Properties",permalink:"/docs/modeling/derived-properties"}},r={},o=[{value:"Always Up-to-Date",id:"always-up-to-date",level:2},{value:"Sync Reactive Fields",id:"sync-reactive-fields",level:2},{value:"Async Reactive Fields",id:"async-reactive-fields",level:2},{value:"Reactive Query Fields",id:"reactive-query-fields",level:2}];function c(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.p,{children:"In Joist, Reactive Fields are values that can be calculated/derived from other data within your domain model, for example:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["Deriving an Author's ",(0,t.jsx)(i.code,{children:"fullName"})," from their ",(0,t.jsx)(i.code,{children:"firstName"})," and ",(0,t.jsx)(i.code,{children:"lastName"})]}),"\n",(0,t.jsxs)(i.li,{children:["Deriving an Author's ",(0,t.jsx)(i.code,{children:"numberOfBooks"})," from their ",(0,t.jsx)(i.code,{children:"books"})," collection"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["Reactive Fields ",(0,t.jsx)(i.strong,{children:"are stored in the database"})," (as regular primitive columns), and so not calculated on-the-fly when accessed. This makes them very quick to access, and amenable to filtering & sorting."]}),"\n",(0,t.jsxs)(i.p,{children:["Joist also supports ",(0,t.jsx)(i.a,{href:"./derived-properties",children:"Derived Fields"}),", which are similar to Reactive Fields but ",(0,t.jsx)(i.strong,{children:"are not stored in the database"}),"."]}),"\n",(0,t.jsx)(i.h2,{id:"always-up-to-date",children:"Always Up-to-Date"}),"\n",(0,t.jsxs)(i.p,{children:["A key feature of Joist's Reactive Fields is that Joist will ",(0,t.jsx)(i.strong,{children:"automatically keep them up-to-date"})," as the data they depend on changes."]}),"\n",(0,t.jsxs)(i.p,{children:["Joist accomplishes this by using each reactive field's declared dependencies (fields, relations, and nested relations--called its ",(0,t.jsx)(i.strong,{children:"reactive hint"}),") to watch for writes in other entities that affect the reactive field's value."]}),"\n",(0,t.jsxs)(i.p,{children:["For example, given a Reactive Field ",(0,t.jsx)(i.code,{children:"numberOfReviews"})," on ",(0,t.jsx)(i.code,{children:"Author"})," with a dependency graph of ",(0,t.jsx)(i.code,{children:'{ books: { reviews: { "title" }'}),", when an update occurs, Joist will automatically recalculate the reactive field's value and update the database, i.e.:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["If a ",(0,t.jsx)(i.code,{children:"review.title"})," changes, Joist will walk from the BookReview to ",(0,t.jsx)(i.code,{children:"Book"})," to ",(0,t.jsx)(i.code,{children:"Author"})," and recalc ",(0,t.jsx)(i.code,{children:"numberOfReviews"})]}),"\n",(0,t.jsxs)(i.li,{children:["If a ",(0,t.jsx)(i.code,{children:"BookReview"})," is created or deleted, Joist will walk from the Review to Book to ",(0,t.jsx)(i.code,{children:"Author"})," and recalc ",(0,t.jsx)(i.code,{children:"numberOfReviews"})]}),"\n",(0,t.jsxs)(i.li,{children:["If a ",(0,t.jsx)(i.code,{children:"Book"})," changes authors, Joist will walk from the Book to the old Author and new Author and recalc each ",(0,t.jsx)(i.code,{children:"numberOfReviews"})]}),"\n",(0,t.jsx)(i.li,{children:"Etc."}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:'Joist exhaustively handles any mutation in the graph by "walking backwards" from the write to any downstream values.'}),"\n",(0,t.jsxs)(i.admonition,{type:"tip",children:[(0,t.jsx)(i.p,{children:"Joist's reactivity depends on all writes going through the domain model, i.e. not raw SQL updates to the database."}),(0,t.jsxs)(i.p,{children:["That said, if the underlying data does drift, or you've updated your reactive field's business logic and need it to be recalculated, you can call ",(0,t.jsx)(i.code,{children:"em.recalc"})," on any entity, and all of its reactive fields will be recalculated and updated in the database."]})]}),"\n",(0,t.jsx)(i.h2,{id:"sync-reactive-fields",children:"Sync Reactive Fields"}),"\n",(0,t.jsx)(i.p,{children:"Synchronous reactive fields are just getters that calculate the field's value (and store it in the database column) from other fields on the entity itself."}),"\n",(0,t.jsxs)(i.p,{children:["After adding the column for a sync field to the database, i.e. an ",(0,t.jsx)(i.code,{children:"authors.initials"})," column, you mark the field as ",(0,t.jsx)(i.code,{children:'derived: "sync"'})," in ",(0,t.jsx)(i.code,{children:"joist-config.json"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-json",children:'{\n  "entities": {\n    "Author": {\n      "fields": {\n        "initials": { "derived": "sync" }\n      }\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["This will cause the ",(0,t.jsx)(i.code,{children:"Author.initials"})," field to not have a setter, only an ",(0,t.jsx)(i.code,{children:"abstract"})," getter than you must implement:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:'export class Author {\n  /** Implements the business logic for a sync reactive value. */\n  get initials(): string {\n    return (this.firstName || "")[0] + (this.lastName !== undefined ? this.lastName[0] : "");\n  }\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["This getter will be automatically called by Joist during any ",(0,t.jsx)(i.code,{children:"INSERT"})," or ",(0,t.jsx)(i.code,{children:"UPDATE"})," of ",(0,t.jsx)(i.code,{children:"Author"}),", to determine the latest ",(0,t.jsx)(i.code,{children:"initials"})," value to store in the database."]}),"\n",(0,t.jsx)(i.h2,{id:"async-reactive-fields",children:"Async Reactive Fields"}),"\n",(0,t.jsxs)(i.p,{children:["For reactive fields that depend on other relations, we again have a column in the database to hold the value, i.e. ",(0,t.jsx)(i.code,{children:"authors.number_of_books"}),", and then mark them as ",(0,t.jsx)(i.code,{children:'derived: "async"'})," in ",(0,t.jsx)(i.code,{children:"joist-config.json"}),":"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-json",children:'{\n  "entities": {\n    "Author": {\n      "fields": {\n        "numberOfBooks": { "derived": "async" }\n      }\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["And then implement the ",(0,t.jsx)(i.code,{children:"numberOfFields"})," field in the ",(0,t.jsx)(i.code,{children:"Author"})," domain model with the same name, but now instead of a getter, by calling the ",(0,t.jsx)(i.code,{children:"hasReactiveField"})," function:"]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:'import { ReactiveField, hasReactiveField } from "joist-orm";\n\nclass Author extends AuthorCodegen {\n  readonly numberOfBooks: ReactiveField<Author, number> = hasReactiveField(\n    "numberOfBooks",\n    "books",\n    (a) => a.books.get.length,\n  );\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["Note that the ",(0,t.jsx)(i.code,{children:"numberOfBooks"})," property ",(0,t.jsx)(i.strong,{children:"must be explicitly typed"})," as ",(0,t.jsx)(i.code,{children:"ReactiveField"})," (not inferred, which unfortunately can cause cyclic compilation errors) with two generics: the entity itself, i.e. ",(0,t.jsx)(i.code,{children:"Author"}),", and the property's type, i.e. ",(0,t.jsx)(i.code,{children:"number"}),"."]}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"hasReactiveField"})," function takes three arguments:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"fieldName"})," the name of the field in the entity and ",(0,t.jsx)(i.code,{children:"joist-config.json"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"reactiveHint"})," any fields that should trigger recalculation of the reactive field."]}),"\n",(0,t.jsxs)(i.p,{children:["This can be a string (",(0,t.jsx)(i.code,{children:'"firstName"'}),"), an array of strings (",(0,t.jsx)(i.code,{children:'["firstName", "books"]'}),"), or an object literal of nested relationships (",(0,t.jsx)(i.code,{children:'{ books: { reviews: "title" } }'}),")."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"fn"})," the function that calculates the value of the derived field."]}),"\n",(0,t.jsxs)(i.p,{children:["This function will be called with the entity as the only argument. All the fields in the reactiveHint will be loaded before this function is called and can be accessed synchronously using ",(0,t.jsx)(i.code,{children:"get"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"As described above, Joist will automatically call this lambda when:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["The ",(0,t.jsx)(i.code,{children:"Author"})," is initially created"]}),"\n",(0,t.jsxs)(i.li,{children:["Any ",(0,t.jsx)(i.code,{children:"Book"})," is added/removed to the ",(0,t.jsx)(i.code,{children:"books"})," collection"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"reactive-query-fields",children:"Reactive Query Fields"}),"\n",(0,t.jsxs)(i.p,{children:["Regular Reactive Fields load all the data declared by their reactive hint into memory. This is very similar to Joist's ",(0,t.jsx)(i.code,{children:"em.populate"})," hints, and make it very easy to calculate values synchronously in regular TypeScript code."]}),"\n",(0,t.jsx)(i.p,{children:"However, a downside is if the hint references a lot of data, it may become too much to load into memory, for the lambda to loop over and calculate."}),"\n",(0,t.jsxs)(i.p,{children:["In these situations, you can use a ",(0,t.jsx)(i.code,{children:"ReactiveQueryField"}),", which calculates its value using a SQL query."]}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-typescript",children:'class Publisher {\n  readonly numberOfBookReviews: ReactiveField<Publisher, number> = hasReactiveQueryField(\n    "numberOfBookReviews",\n    // this hint will recalc + be available on `p`\n    "id",\n    // this hint will recalc + not be available on `p`\n    { authors: { books: "reviews" } },\n    // findCount is N+1 safe\n    (p) => p.em.findCount(BookReview, { book: { author: { publisher: p.id } } }),\n  );\n}\n'})}),"\n",(0,t.jsxs)(i.p,{children:["The ",(0,t.jsx)(i.code,{children:"hasReactiveQueryField"})," takes four arguments:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"fieldName"})," the name of the field in the entity and ",(0,t.jsx)(i.code,{children:"joist-config.json"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"paramHint"})," a reactive hint of data that will be loaded into memory, similar to a regular ",(0,t.jsx)(i.code,{children:"ReactiveField"}),"."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"dbHint"})," a reactive hint of data that will ",(0,t.jsx)(i.em,{children:"not"})," be loaded into memory, but if it changes will still cause the field to be recalculated."]}),"\n"]}),"\n",(0,t.jsxs)(i.li,{children:["\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.code,{children:"fn"})," the function that calculates the value of the derived field."]}),"\n",(0,t.jsxs)(i.p,{children:["This function will have access to the data in ",(0,t.jsx)(i.code,{children:"paramHint"}),", and then should issue a database query that summarizes/queries against the fields in the ",(0,t.jsx)(i.code,{children:"dbHint"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["A special aspect of ",(0,t.jsx)(i.code,{children:"ReactiveQueryField"}),"s is that Joist will defer running their query until any other WIP changes in the ",(0,t.jsx)(i.code,{children:"EntityManager"})," have been flushed to the database. This ensures that the SQL query sees the latest data, and doesn't mistakenly calculate a stale value."]}),"\n",(0,t.jsxs)(i.p,{children:["For example, a flow for the ",(0,t.jsx)(i.code,{children:"numberOfBookReviews"})," above might be:"]}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:["A ",(0,t.jsx)(i.code,{children:"Publisher"})," already exists in the database"]}),"\n",(0,t.jsxs)(i.li,{children:["A request creates a new ",(0,t.jsx)(i.code,{children:"BookReview"})," and call ",(0,t.jsx)(i.code,{children:"em.flush"})]}),"\n",(0,t.jsxs)(i.li,{children:["During ",(0,t.jsx)(i.code,{children:"em.flush"}),", Joist realises that the ",(0,t.jsx)(i.code,{children:"Publisher.numberOfBookReviews"})," needs recalculated"]}),"\n",(0,t.jsxs)(i.li,{children:["Joist will first issue an ",(0,t.jsx)(i.code,{children:"INSERT INTO book_reviews"})," for the ",(0,t.jsx)(i.code,{children:"BookReview"})]}),"\n",(0,t.jsxs)(i.li,{children:["With the transaction still open, the ",(0,t.jsx)(i.code,{children:"em.findCount"})," query runs and sees the updated count"]}),"\n",(0,t.jsxs)(i.li,{children:["Joist then issues an additional ",(0,t.jsx)(i.code,{children:"UPDATE publishers"})," query to update the ",(0,t.jsx)(i.code,{children:"Publisher"})]}),"\n",(0,t.jsx)(i.li,{children:"The transaction is then committed"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:['Note that this "issue a ',(0,t.jsx)(i.code,{children:"SELECT"}),' with a transaction open" is not normally how Joist operates, but it ensures the best transactional integrity of the ',(0,t.jsx)(i.code,{children:"BookReview"})," and ",(0,t.jsx)(i.code,{children:"Publisher"})," reactive field being updated atomically."]}),"\n",(0,t.jsx)(i.admonition,{type:"tip",children:(0,t.jsxs)(i.p,{children:["Currently, the ",(0,t.jsx)(i.code,{children:"ReactiveQueryField"}),"'s query is not limited (i.e. either by type-checking or runtime verification) to querying against ",(0,t.jsx)(i.strong,{children:"only"})," data described in the ",(0,t.jsx)(i.code,{children:"dbHint"}),", but you should ensure that it does, as otherwise field value may drift from the value calculated by the query."]})})]})}function h(e={}){const{wrapper:i}={...(0,s.a)(),...e.components};return i?(0,t.jsx)(i,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1670:(e,i,n)=>{n.d(i,{Z:()=>d,a:()=>a});var t=n(7378);const s={},l=t.createContext(s);function a(e){const i=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function d(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(l.Provider,{value:i},e.children)}}}]);