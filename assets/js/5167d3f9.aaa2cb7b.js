"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[677],{8236:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>c});var t=n(4246),o=n(1670);const a={title:"Lens Traversal",sidebar_position:5},i=void 0,r={id:"advanced/lenses",title:"Lens Traversal",description:"Lenses provide quick navigation the object graph, for example to navigate from an Author a",source:"@site/docs/advanced/lenses.md",sourceDirName:"advanced",slug:"/advanced/lenses",permalink:"/docs/advanced/lenses",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/advanced/lenses.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{title:"Lens Traversal",sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Optimistic Locking",permalink:"/docs/advanced/optimistic-locking"},next:{title:"Class Table Inheritance",permalink:"/docs/advanced/class-table-inheritance"}},d={},c=[{value:"Explanation",id:"explanation",level:2},{value:"Typing",id:"typing",level:2}];function l(e){const s={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:["Lenses provide quick navigation the object graph, for example to navigate from an ",(0,t.jsx)(s.code,{children:"Author"})," ",(0,t.jsx)(s.code,{children:"a:1"})," to all of its books, and all of its book's reviews, you can write:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-typescript",children:'// Load an author as usual\nconst author = await em.load(Author, "a:1");\n// The `a.books.reviews` creates a lens/path to navigate\nconst reviews = await author.load(a => a.books.reviews);\nconsole.log(`Found ${reviews.length} reviews`);\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Behind the scenes, the above code executes exactly the same as using Joist's populate hints to preload and then ",(0,t.jsx)(s.code,{children:".get"})," + ",(0,t.jsx)(s.code,{children:".flatMap"})," across preloaded relations:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-typescript",children:'// Load an author but with a populate hint\nconst author = await em.load(\n  Author,\n  "a:1",\n  { books: "reviews" }\n);\n// Now flatMap book reviews w/o any awaits\nconst reviews = author.books.get.flatMap((book) => {\n  return book.reviews.get;\n})\nconsole.log(`Found ${reviews.length} reviews`);\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Both of these features prevent ",(0,t.jsx)(s.code,{children:"await"})," hell (by having only a single ",(0,t.jsx)(s.code,{children:"await"})," and then otherwise synchronous code), and which one is better depends on your need:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["If you need to apply filters and transformation logic, the populate hint with explicit ",(0,t.jsx)(s.code,{children:".get"}),"s",(0,t.jsx)(s.code,{children:"and"}),".flatMap`s is better b/c you can intersperse your custom logic as needed."]}),"\n",(0,t.jsxs)(s.li,{children:["If you just need to do a simple/no filtering/no transformation navigation of the object graph, then the lens ",(0,t.jsx)(s.code,{children:".load"})," approach is more succint."]}),"\n"]}),"\n",(0,t.jsx)(s.h2,{id:"explanation",children:"Explanation"}),"\n",(0,t.jsxs)(s.p,{children:["In the above example, the ",(0,t.jsx)(s.code,{children:"author.load"})," method passes its lambda the parameter ",(0,t.jsx)(s.code,{children:"a"}),"; this parameter is just a proxy/",(0,t.jsx)(s.a,{href:"https://medium.com/@dtipson/functional-lenses-d1aba9e52254",children:"lens"}),' records/"marks" what path to take through the object graph.']}),"\n",(0,t.jsxs)(s.p,{children:["Once the lambda returns that path (i.e. ",(0,t.jsx)(s.code,{children:"a.books.reviews"})," or ",(0,t.jsx)(s.code,{children:"author -> books -> reviews"}),"), then the ",(0,t.jsx)(s.code,{children:"load"}),' method internally loads/follows those paths, and returns the collection of entities that was at the "end" of the path.']}),"\n",(0,t.jsx)(s.h2,{id:"typing",children:"Typing"}),"\n",(0,t.jsxs)(s.p,{children:["In the above example, the ",(0,t.jsx)(s.code,{children:"a"})," parameter is a ",(0,t.jsx)(s.code,{children:"Lens<Author>"}),", where ",(0,t.jsx)(s.code,{children:"Lens"})," is a mapped type that exposes ",(0,t.jsx)(s.code,{children:"Author"}),"'s relations as simple keys."]}),"\n",(0,t.jsxs)(s.p,{children:["Those keys themselves return new ",(0,t.jsx)(s.code,{children:"Lens"}),"s, i.e. ",(0,t.jsx)(s.code,{children:"a.books"})," returns ",(0,t.jsx)(s.code,{children:"Lens<Book, Book[]>"})," (the 2nd ",(0,t.jsx)(s.code,{children:"Book[]"})," is because ",(0,t.jsx)(s.code,{children:"books"})," returns multiple ",(0,t.jsx)(s.code,{children:"Book"}),"s)."]}),"\n",(0,t.jsxs)(s.p,{children:["Then ",(0,t.jsx)(s.code,{children:".reviews"})," returns ",(0,t.jsx)(s.code,{children:"Lens<BookReview, BookReview[]>"}),', and since it is the "last path" / last lens, that is who the ',(0,t.jsx)(s.code,{children:"author.load"})," method knows that its return type should be ",(0,t.jsx)(s.code,{children:"BookReview[]"}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,o.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1670:(e,s,n)=>{n.d(s,{a:()=>i});var t=n(7378);const o={},a=t.createContext(o);function i(e){const s=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}}}]);