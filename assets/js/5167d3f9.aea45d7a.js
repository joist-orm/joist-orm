"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9376],{3023:(e,n,s)=>{s.d(n,{R:()=>i,x:()=>r});var o=s(3696);const t={},a=o.createContext(t);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),o.createElement(a.Provider,{value:n},e.children)}},5423:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"advanced/lenses","title":"Lens Traversal","description":"Lenses provide quick navigation the object graph, for example to navigate from an Author a","source":"@site/docs/advanced/lenses.md","sourceDirName":"advanced","slug":"/advanced/lenses","permalink":"/docs/advanced/lenses","draft":false,"unlisted":false,"editUrl":"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/advanced/lenses.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Lens Traversal","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Json Payloads","permalink":"/docs/advanced/json-payloads"},"next":{"title":"Optimistic Locking","permalink":"/docs/advanced/optimistic-locking"}}');var t=s(2540),a=s(3023);const i={title:"Lens Traversal",sidebar_position:5},r=void 0,d={},c=[{value:"Explanation",id:"explanation",level:2},{value:"Typing",id:"typing",level:2}];function l(e){const n={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Lenses provide quick navigation the object graph, for example to navigate from an ",(0,t.jsx)(n.code,{children:"Author"})," ",(0,t.jsx)(n.code,{children:"a:1"})," to all of its books, and all of its book's reviews, you can write:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Load an author as usual\nconst author = await em.load(Author, "a:1");\n// The `a.books.reviews` creates a lens/path to navigate\nconst reviews = await author.load(a => a.books.reviews);\nconsole.log(`Found ${reviews.length} reviews`);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Behind the scenes, the above code executes exactly the same as using Joist's populate hints to preload and then ",(0,t.jsx)(n.code,{children:".get"})," + ",(0,t.jsx)(n.code,{children:".flatMap"})," across preloaded relations:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// Load an author but with a populate hint\nconst author = await em.load(\n  Author,\n  "a:1",\n  { books: "reviews" }\n);\n// Now flatMap book reviews w/o any awaits\nconst reviews = author.books.get.flatMap((book) => {\n  return book.reviews.get;\n})\nconsole.log(`Found ${reviews.length} reviews`);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Both of these features prevent ",(0,t.jsx)(n.code,{children:"await"})," hell (by having only a single ",(0,t.jsx)(n.code,{children:"await"})," and then otherwise synchronous code), and which one is better depends on your need:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If you need to apply filters and transformation logic, the populate hint with explicit ",(0,t.jsx)(n.code,{children:".get"}),"s",(0,t.jsx)(n.code,{children:"and"}),".flatMap`s is better b/c you can intersperse your custom logic as needed."]}),"\n",(0,t.jsxs)(n.li,{children:["If you just need to do a simple/no filtering/no transformation navigation of the object graph, then the lens ",(0,t.jsx)(n.code,{children:".load"})," approach is more succint."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"explanation",children:"Explanation"}),"\n",(0,t.jsxs)(n.p,{children:["In the above example, the ",(0,t.jsx)(n.code,{children:"author.load"})," method passes its lambda the parameter ",(0,t.jsx)(n.code,{children:"a"}),"; this parameter is just a proxy/",(0,t.jsx)(n.a,{href:"https://medium.com/@dtipson/functional-lenses-d1aba9e52254",children:"lens"}),' records/"marks" what path to take through the object graph.']}),"\n",(0,t.jsxs)(n.p,{children:["Once the lambda returns that path (i.e. ",(0,t.jsx)(n.code,{children:"a.books.reviews"})," or ",(0,t.jsx)(n.code,{children:"author -> books -> reviews"}),"), then the ",(0,t.jsx)(n.code,{children:"load"}),' method internally loads/follows those paths, and returns the collection of entities that was at the "end" of the path.']}),"\n",(0,t.jsx)(n.h2,{id:"typing",children:"Typing"}),"\n",(0,t.jsxs)(n.p,{children:["In the above example, the ",(0,t.jsx)(n.code,{children:"a"})," parameter is a ",(0,t.jsx)(n.code,{children:"Lens<Author>"}),", where ",(0,t.jsx)(n.code,{children:"Lens"})," is a mapped type that exposes ",(0,t.jsx)(n.code,{children:"Author"}),"'s relations as simple keys."]}),"\n",(0,t.jsxs)(n.p,{children:["Those keys themselves return new ",(0,t.jsx)(n.code,{children:"Lens"}),"s, i.e. ",(0,t.jsx)(n.code,{children:"a.books"})," returns ",(0,t.jsx)(n.code,{children:"Lens<Book, Book[]>"})," (the 2nd ",(0,t.jsx)(n.code,{children:"Book[]"})," is because ",(0,t.jsx)(n.code,{children:"books"})," returns multiple ",(0,t.jsx)(n.code,{children:"Book"}),"s)."]}),"\n",(0,t.jsxs)(n.p,{children:["Then ",(0,t.jsx)(n.code,{children:".reviews"})," returns ",(0,t.jsx)(n.code,{children:"Lens<BookReview, BookReview[]>"}),', and since it is the "last path" / last lens, that is who the ',(0,t.jsx)(n.code,{children:"author.load"})," method knows that its return type should be ",(0,t.jsx)(n.code,{children:"BookReview[]"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);