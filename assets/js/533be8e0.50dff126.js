"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1172],{8245:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>d});var o=t(4246),s=t(1670);const l={title:"Enums",sidebar_position:6},i=void 0,a={id:"modeling/enum-tables",title:"Enums",description:"Joist supports enum tables for modeling fields that can be set to a fixed number of values (i.e. a state field that can be OPEN or CLOSED, or a field status field that can be ACTIVE, DRAFT, PENDING, etc.)",source:"@site/docs/modeling/enum-tables.md",sourceDirName:"modeling",slug:"/modeling/enum-tables",permalink:"/docs/modeling/enum-tables",draft:!1,unlisted:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/modeling/enum-tables.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{title:"Enums",sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"Lifecycle Hooks",permalink:"/docs/modeling/lifecycle-hooks"},next:{title:"Derived Fields",permalink:"/docs/modeling/derived-fields"}},r={},d=[{value:"What&#39;s an Enum Table",id:"whats-an-enum-table",level:3},{value:"Why Tables?",id:"why-tables",level:2},{value:"Enum Details and Extra Columns",id:"enum-details-and-extra-columns",level:2},{value:"Integrated with Testing",id:"integrated-with-testing",level:2},{value:"Enum Arrays",id:"enum-arrays",level:2},{value:"When to Use Enums",id:"when-to-use-enums",level:2},{value:"Native Enums",id:"native-enums",level:2}];function c(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Joist supports enum tables for modeling fields that can be set to a fixed number of values (i.e. a ",(0,o.jsx)(n.code,{children:"state"})," field that can be ",(0,o.jsx)(n.code,{children:"OPEN"})," or ",(0,o.jsx)(n.code,{children:"CLOSED"}),", or a field ",(0,o.jsx)(n.code,{children:"status"})," field that can be ",(0,o.jsx)(n.code,{children:"ACTIVE"}),", ",(0,o.jsx)(n.code,{children:"DRAFT"}),", ",(0,o.jsx)(n.code,{children:"PENDING"}),", etc.)"]}),"\n",(0,o.jsx)(n.h3,{id:"whats-an-enum-table",children:"What's an Enum Table"}),"\n",(0,o.jsxs)(n.p,{children:["Enum tables are a pattern where each enum (",(0,o.jsx)(n.code,{children:"Color"}),") in your domain model has a corresponding table (",(0,o.jsx)(n.code,{children:"colors"}),") in the database, with rows for each enum values."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, for a ",(0,o.jsx)(n.code,{children:"Color"})," enum with values of ",(0,o.jsx)(n.code,{children:"Color.RED"}),", ",(0,o.jsx)(n.code,{children:"Color.GREEN"}),", ",(0,o.jsx)(n.code,{children:"Color.Blue"}),", the ",(0,o.jsx)(n.code,{children:"color"})," table would look like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-console",children:'joist=> \\d color;\n                 Table "public.color"\n Column |  Type   | Nullable |              Default\n--------+---------+----------+-----------------------------------\n id     | integer | not null | nextval(\'color_id_seq\'::regclass)\n code   | text    | not null |\n name   | text    | not null |\nIndexes:\n    "color_pkey" PRIMARY KEY, btree (id)\n    "color_unique_enum_code_constraint" UNIQUE CONSTRAINT, btree (code)\n'})}),"\n",(0,o.jsx)(n.p,{children:"With rows for each value:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-console",children:"joist=> select * from color;\n id | code  | name\n----+-------+-------\n  1 | RED   | Red\n  2 | GREEN | Green\n  3 | BLUE  | Blue\n(3 rows)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Which are codegen'd into TypeScript enums:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'export enum Color {\n  Red = "RED",\n  Green = "GREEN",\n  Blue = "BLUE",\n}\n'})}),"\n",(0,o.jsx)(n.p,{children:"And then other domain entities use foreign keys to point back to valid values:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-console",children:'\\d authors\n                          Table "public.authors"\n   Column           |           Type           | Nullable |                Default\n--------------------+--------------------------+----------+----------------------------------------\n id                 | integer                  | not null | nextval(\'authors_id_seq\'::regclass)\n name               | character varying(255)   | not null |\n favorite_color_id  | integer                  |          |\n created_at         | timestamp with time zone | not null |\n updated_at         | timestamp with time zone | not null |\nIndexes:\n    "authors_pkey" PRIMARY KEY, btree (id)\n    "authors_favorite_color_id_idx" btree (size_id)\nForeign-key constraints:\n    "authors_favorite_color_id_fkey" FOREIGN KEY\n       (favorite_color_id) REFERENCES color(id)\n'})}),"\n",(0,o.jsx)(n.h2,{id:"why-tables",children:"Why Tables?"}),"\n",(0,o.jsx)(n.p,{children:"There are multiple ways to model enums, i.e. other options are database-native enums (which Joist does support, see below), or using enum values declared solely within your codebase."}),"\n",(0,o.jsx)(n.p,{children:"Joist generally recommended/refers the enum table pattern because:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"The foreign keys enforce data integrity at the database-level"}),"\n",(0,o.jsx)(n.p,{children:"(Database-native enums do this as well, codebase-only enums would not.)"}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsxs)(n.p,{children:["Ability to store ",(0,o.jsx)(n.code,{children:"code"})," vs. ",(0,o.jsx)(n.code,{children:"name"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["Although minor, it's nice to have a dedicated ",(0,o.jsx)(n.code,{children:"name"})," field to store the display name for enum values, and have them available in the database for updating/looking up."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Ability to add extra columns (see later)"}),"\n",(0,o.jsxs)(n.p,{children:["Joist supports adding addition columns to the code, so like ",(0,o.jsx)(n.code,{children:"color.customization_cost"})," could be an additional column on the ",(0,o.jsx)(n.code,{children:"color"})," table that Joist will automatically expose to the domain layer."]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:["\n",(0,o.jsx)(n.p,{children:"Changing enum values is generally simpler DML instead of DDL"}),"\n",(0,o.jsxs)(n.p,{children:["With a ",(0,o.jsx)(n.code,{children:"color"})," table, adding/removing new values is just ",(0,o.jsx)(n.code,{children:"INSERT"}),"s / ",(0,o.jsx)(n.code,{children:"UPDATE"}),"s, whereas database-native enums require ",(0,o.jsx)(n.code,{children:"ALTER"}),"s to change the type."]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"enum-details-and-extra-columns",children:"Enum Details and Extra Columns"}),"\n",(0,o.jsxs)(n.p,{children:["Besides the basic ",(0,o.jsx)(n.code,{children:"Color"}),' enum, Joist generates "details" types, i.e. ',(0,o.jsx)(n.code,{children:"ColorDetails"})," that include more information about each enum:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'export type ColorDetails = { id: number; code: Color; name: string };\n\nconst details: Record<Color, ColorDetails> = {\n  [Color.Red]: { id: 1, code: Color.Red, name: "Red" },\n  [Color.Green]: { id: 2, code: Color.Green, name: "Green" },\n  [Color.Blue]: { id: 3, code: Color.Blue, name: "Blue" },\n};\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Which you can lookup via static methods on the ",(0,o.jsx)(n.code,{children:"ColorDetails"})," class:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"export const Colors = {\n  getByCode(code: Color): ColorDetails;\n\n  findByCode(code: string): ColorDetails | undefined;\n\n  findById(id: number): ColorDetails | undefined;\n\n  getValues(): ReadonlyArray<Color>;\n\n  getDetails(): ReadonlyArray<ColorDetails>;\n};\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Also, as mentioned before, if you add additional columns to the ",(0,o.jsx)(n.code,{children:"color"})," table, they will be added to the ",(0,o.jsx)(n.code,{children:"ColorDetails"})," type, i.e.:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'b.addColumn("color", { sort_order: { type: "integer", notNull: true, default: 1 } });\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Will result in a ",(0,o.jsx)(n.code,{children:"ColorDetails"})," that looks like:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"export type ColorDetails = {\n  id: number;\n  code: Color;\n  name: string;\n  sortOrder: 1 | 2 | 3;\n};\n"})}),"\n",(0,o.jsx)(n.p,{children:'Currently, "extra details columns" only supports primitive columns (integers, strings, etc.), i.e. not other enums, JSONB columns, or arrays.'}),"\n",(0,o.jsx)(n.h2,{id:"integrated-with-testing",children:"Integrated with Testing"}),"\n",(0,o.jsxs)(n.p,{children:["During tests, ",(0,o.jsx)(n.code,{children:"flush_database"})," will skip enum tables, so they do not need to be re-populated each time."]}),"\n",(0,o.jsx)(n.h2,{id:"enum-arrays",children:"Enum Arrays"}),"\n",(0,o.jsxs)(n.p,{children:["If you want to store a list of enums in a single column (for example, instead of just ",(0,o.jsx)(n.code,{children:"Author.favoriteColor"}),", you want ",(0,o.jsx)(n.code,{children:"Author.favoriteColors"}),"), Joist supports modeling that as a ",(0,o.jsx)(n.code,{children:"int[]"})," column, i.e.:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-console",children:'joist=> \\d authors;\n                        Table "public.authors"\n   Column         |           Type           | Nullable |               Default\n\n------------------+--------------------------+----------+-----------------------------------\n--\n id               | integer                  | not null | nextval(\'authors_id_seq\'::regclass\n)\n first_name       | character varying(255)   | not null |\n favorite_colors  | integer[]                |          | ARRAY[]::integer[]\n created_at       | timestamp with time zone | not null |\n updated_at       | timestamp with time zone | not null |\nIndexes:\n    "authors_pkey" PRIMARY KEY, btree (id)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Note that Postgres does not yet support foreign key constraints on array columns, so you'll lose that aspect of data integrity with enum arrays."}),"\n",(0,o.jsx)(n.p,{children:'Also, because of this lack of foreign key constraint, Joist cannot use that to know "what enum type is this column?"'}),"\n",(0,o.jsx)(n.p,{children:"As an admittedly hacky approach, we encode that information in a schema comment:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:'b.addColumns("authors", {\n  favorite_colors: {\n    type: "integer[]",\n    comment: `enum=color`,\n    notNull: false,\n    default: PgLiteral.create("array[]::integer[]"),\n  },\n});\n'})}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use-enums",children:"When to Use Enums"}),"\n",(0,o.jsx)(n.p,{children:"In general, you should only use enums when you have business logic that directly branches based on the values."}),"\n",(0,o.jsxs)(n.p,{children:['For an example, if your system has a list of "markets", and you only have ~2-3 markets, it can be tempting to think of ',(0,o.jsx)(n.code,{children:"Market"})," as an enum, because currently there are only a few of them. And if you make it an enum, then ",(0,o.jsx)(n.code,{children:"flush_database"})," will not reset the ",(0,o.jsx)(n.code,{children:"market"}),' table, so you don\'t have to keep adding test data that is "we have markets 1/2/3".']}),"\n",(0,o.jsxs)(n.p,{children:["However, now adding/removing new markets changes the ",(0,o.jsx)(n.code,{children:"Market"})," enum, and so has to be coordinated with deployments. And renaming/removing ",(0,o.jsx)(n.code,{children:"Market"}),"s is a breaking change."]}),"\n",(0,o.jsxs)(n.p,{children:["So, unless if you have codepaths that are explicitly dedicated to ",(0,o.jsx)(n.code,{children:"Market 1"}),' codepath is "chunk of business logic" and ',(0,o.jsx)(n.code,{children:"Market 2"}),' codepath is "different chunk of business logic", these "small lookup tables" are generally better modeled as just regular entities.']}),"\n",(0,o.jsx)(n.h2,{id:"native-enums",children:"Native Enums"}),"\n",(0,o.jsx)(n.p,{children:"While Joist generally prefers enum tables, if you have native enums in your schema, Joist will work for those as well."}),"\n",(0,o.jsxs)(n.p,{children:['Note that you don\'t get enum details, or extra columns, but the basic out of "a TypeScript" enum and ',(0,o.jsx)(n.code,{children:"Author.favoriteColor"})," is typed as the ",(0,o.jsx)(n.code,{children:"Color"})," enum will work."]})]})}function h(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>i});var o=t(7378);const s={},l=o.createContext(s);function i(e){const n=o.useContext(l);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);