"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1719],{2379:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>n,metadata:()=>r,toc:()=>d});var s=t(4246),o=t(1670);const n={title:"Why Joist?",position:10},a=void 0,r={id:"why-joist",title:"Why Joist?",description:"Joist is an ORM for TypeScript: it lets you interact with your database (Postgres) through objects (entities) instead of raw SQL.",source:"@site/docs/why-joist.md",sourceDirName:".",slug:"/why-joist",permalink:"/docs/why-joist",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/why-joist.md",tags:[],version:"current",frontMatter:{title:"Why Joist?",position:10},sidebar:"tutorialSidebar",previous:{title:"Test Utils",permalink:"/docs/testing/test-utils"}},l={},d=[{value:"What&#39;s Different About Joist?",id:"whats-different-about-joist",level:2},{value:"Examples for Reads",id:"examples-for-reads",level:3},{value:"Examples for Writes",id:"examples-for-writes",level:3},{value:"Thinking in Graphs",id:"thinking-in-graphs",level:2},{value:"Target Market",id:"target-market",level:2}];function c(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:"Joist is an ORM for TypeScript: it lets you interact with your database (Postgres) through objects (entities) instead of raw SQL."}),"\n",(0,s.jsxs)(i.p,{children:["For example, reading and updating an ",(0,s.jsx)(i.code,{children:"authors"})," row looks like:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:'const em = newEntityManager();\nconst author = em.load(Author, "a:1");\nauthor.firstName = "New Name";\nawait em.flush();\n'})}),"\n",(0,s.jsxs)(i.p,{children:["See the ",(0,s.jsx)(i.a,{href:"/docs/getting-started/tour",children:"Quick Tour"})," for more short examples."]}),"\n",(0,s.jsx)(i.h2,{id:"whats-different-about-joist",children:"What's Different About Joist?"}),"\n",(0,s.jsxs)(i.p,{children:["Joist's biggest differentiator is its focus on ",(0,s.jsx)(i.strong,{children:"domain modeling"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:['Most modern ORMs in the JavaScript/TypeScript space focus on being "query builders", where each invocation in your code (a call into Prisma or Drizzle or Kysley) results in generally one invocation to your database, and you get back every database row as a dumb (meant in a good way) ',(0,s.jsx)(i.a,{href:"https://gist.github.com/kurtmilam/a1179741777ea6f88374286a640829cc",children:"POJO"}),"--no more, and no less."]}),"\n",(0,s.jsx)(i.p,{children:"And that is basically it--the organization of your business logic, application of validation rules, and side effects/reactivity (i.e. when row X updates, do Y) are outside their scope."}),"\n",(0,s.jsxs)(i.p,{children:['This can be good and bad: good in that they\'re simpler, more "like a library", but also bad in that now ',(0,s.jsx)(i.strong,{children:"your app has to have its own conventions"})," for organizing business logic, consistently applying validation rules, and managing side effects."]}),"\n",(0,s.jsxs)(i.p,{children:["Joist is different: its focus is not just queries, but building ",(0,s.jsx)(i.a,{href:"https://martinfowler.com/eaaCatalog/domainModel.html",children:"domain models"}),", with features, conventions, and patterns for organizing the business logic that application backends are generally expected to implement."]}),"\n",(0,s.jsx)(i.p,{children:'In this regard, Joist sits more on the "framework" side of the "library / framework" spectrum, although it can used for any backend, i.e. GraphQL or GRPC or old-school REST endpoints, so does not qualify as a true end-to-end framework like Rails.'}),"\n",(0,s.jsxs)(i.admonition,{type:"info",children:[(0,s.jsxs)(i.p,{children:["Ironically, query-builder ORMs like Drizzle tout their \"we're ",(0,s.jsx)(i.em,{children:"not"}),' a data framework" approach as a benefit, just as much as Joist touts its "we ',(0,s.jsx)(i.em,{children:"are"}),' a framework" approach as a benefit. :-)']}),(0,s.jsx)(i.p,{children:'So whether you want a Joist-style "framework/entity ORM", or Drizzle-style "library/query-builder ORM", is a matter of personal taste and project requirements.'}),(0,s.jsx)(i.p,{children:"Some of it comes down to trust: do you trust yourself to remember to apply validation rules & side effects consistently, in every endpoint, before you issue low-level SQL calls via Drizzle/Prisma/Kysley, or do you trust Joist's entities & abstractions to do that automatically for you, without becoming too magical & spooky-action-at-a-distance?"}),(0,s.jsxs)(i.p,{children:['Joist tries very hard to avoid the "too magical" pitfall, and make its behavior as unsurprising and idiomatic as possible (i.e. no N+1s, no complex queries), such that you quickly become to trust that ',(0,s.jsx)(i.code,{children:"em.flush"}),", ",(0,s.jsx)(i.code,{children:"em.find"}),', all "just do the right thing", and you can focus on providing business value.']}),(0,s.jsx)(i.p,{children:"So far, we believe we've succeeded, but again personal preference & project requirements plays a big role here."})]}),"\n",(0,s.jsxs)(i.admonition,{type:"tip",children:[(0,s.jsx)(i.p,{children:'Although not a true  "end-to-end framework" like Rails, Joist grew out of a GraphQL backend and so has several ergonomic features for that use-case, like evergreen schema & resolver scaffolding.'}),(0,s.jsx)(i.p,{children:"(todo: write this up and link to it)"})]}),"\n",(0,s.jsx)(i.h3,{id:"examples-for-reads",children:"Examples for Reads"}),"\n",(0,s.jsxs)(i.p,{children:['An example of Joist\'s "rich domain model" features is derived properties, which are calculations on top of your raw database values. For example a ',(0,s.jsx)(i.code,{children:"hasManyThrough"})," or ",(0,s.jsx)(i.code,{children:"hasAsyncProperty"}),":"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:'class Author extends AuthorCodegen {\n  readonly reviews: Collection<Author, BookReview> = hasMany((a) => a.books.reviews);\n  readonly totalRatings: AsyncProperty<Author, number> = hasAsyncProperty(\n    { books: "reviews" },\n    (a) => a.reviews.get.reduce((acc, r) => acc + r.rating, 0)\n  );\n}\n'})}),"\n",(0,s.jsxs)(i.p,{children:['Both of these are "utility methods" that can be reused across endpoints/logic in your app--Joist\'s domain model gives you a known/obvious place to put them, and also guarantees they can be calculated relatively cheaply (i.e. ',(0,s.jsx)(i.a,{href:"/docs/goals/avoiding-n-plus-1s",children:"without N+1s"}),") or easily materialized (i.e. ",(0,s.jsx)(i.a,{href:"/docs/modeling/reactive-fields",children:"reactive fields"}),")."]}),"\n",(0,s.jsxs)(i.p,{children:["The biggest win is that our business logic within these methods is written in ",(0,s.jsx)(i.strong,{children:"regular, ergonomic"})," TypeScript."]}),"\n",(0,s.jsx)(i.p,{children:'This contrasts with query-builder ORMs (and also "database-to-API" approaches like Hasura and PostGraphile), that focus solely on pulling data directly from the database, such that logic reuse must be pushed down into the database itself, and written as views, triggers, or stored procedures.'}),"\n",(0,s.jsxs)(i.admonition,{type:"info",children:[(0,s.jsxs)(i.p,{children:["When looking at the ",(0,s.jsx)(i.code,{children:"totalRatings"}),' example above, it can initially look weird to see the "this is just a ',(0,s.jsx)(i.code,{children:"SUM(rating)"}),'" logic in written in TypeScript, instead of being pushed down into the database as SQL, but the two key benefits are:']}),(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Once your business logic is more complex than a ",(0,s.jsx)(i.code,{children:"SUM"}),", it can be much easier to express in TypeScript than SQL, and"]}),"\n"]}),"\n",(0,s.jsxs)(i.li,{children:["\n",(0,s.jsxs)(i.p,{children:["Because the business logic is evaluated against in-memory entities, it can be called on not-yet-committed data, i.e. your pending in-memory changes (to a ",(0,s.jsx)(i.code,{children:"Book"})," or ",(0,s.jsx)(i.code,{children:"Author"}),") during a ",(0,s.jsx)(i.code,{children:"save"})," operation, by validation rules or other business logic & they're guaranteed to see the latest calculated values."]}),"\n",(0,s.jsx)(i.p,{children:"This is much easier than manually opening a transaction, flushing the WIP changes without commiting, then issuing queries to read the latest aggregates, do validation checks against those SQL-calculated aggregates, and then finally commit."}),"\n",(0,s.jsxs)(i.p,{children:["(Although if you really do need this functionality, Joist's ",(0,s.jsx)(i.a,{href:"/docs/modeling/reactive-fields#reactive-query-fields",children:"Reactive Query Fields"})," will orchestrate exactly this ",(0,s.jsx)(i.code,{children:"begin"})," + ",(0,s.jsx)(i.code,{children:"flush"})," + ",(0,s.jsx)(i.code,{children:"query"})," + ",(0,s.jsx)(i.code,{children:"flush"})," + ",(0,s.jsx)(i.code,{children:"commit"})," sequence for you, automatically, within an ",(0,s.jsx)(i.code,{children:"em.flush()"})," call)."]}),"\n"]}),"\n"]}),(0,s.jsxs)(i.p,{children:["That said, you can still do SQL-side ",(0,s.jsx)(i.code,{children:"SUM"}),"s and aggregates via custom SQL queries; that logic will just not be accessible to the rest of the Joist domain model."]})]}),"\n",(0,s.jsx)(i.h3,{id:"examples-for-writes",children:"Examples for Writes"}),"\n",(0,s.jsx)(i.p,{children:"On the write side, Joist's domain model approach also provides simple/obvious places to be validation rules and side effects."}),"\n",(0,s.jsx)(i.p,{children:'An example validation rule might be "the author first name and book title can never be the same string"; obviously this is contrived, but it shows a rule that needs to "watch" multiple entities:'}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-typescript",children:'import { authorConfig as config } from "./entities";\n\nclass Author extends AuthorCodegen {}\n\nconfig.addRule({ firstName: {}, books: "title" }, (a) => {\n  for (const book of a.books.get) {\n    if (a.firstName === book.title) {\n      throw new Error("Author first name and book title cannot be the same");\n     }\n  }\n});\n'})}),"\n",(0,s.jsxs)(i.p,{children:["Assuming writes go through Joist's domain model, ",(0,s.jsx)(i.strong,{children:"any update"})," to ",(0,s.jsx)(i.code,{children:"Author.firstName"})," or ",(0,s.jsx)(i.strong,{children:"any update"})," to a ",(0,s.jsx)(i.code,{children:"Book.title"})," or ",(0,s.jsxs)(i.strong,{children:["any ",(0,s.jsx)(i.code,{children:"Book"})," switching authors"]})," will fire this validation rule."]}),"\n",(0,s.jsxs)(i.p,{children:['This "',(0,s.jsx)(i.a,{href:"/docs/modeling/validation-rules#reactive-validation-rules",children:"backend reactivity"}),'" provides ',(0,s.jsx)(i.strong,{children:"extreme confidence"})," that your business rules will be enforced."]}),"\n",(0,s.jsxs)(i.p,{children:["This again contrasts with query builder ORMs, where it's your job to manually remember which validation rules, both on the current entity and other entities that might be affected, need to be checked, before issuing an ",(0,s.jsx)(i.code,{children:"INSERT"})," or ",(0,s.jsx)(i.code,{children:"UPDATE"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["Instead, domain-focused validation logic that would normally be scattered across endpoints (like ",(0,s.jsx)(i.code,{children:"saveAuthor"}),", ",(0,s.jsx)(i.code,{children:"createBook"})," and ",(0,s.jsx)(i.code,{children:"updateBook"}),"), and coupled/intermingled with each endpoint's core job of decoding/mapping the incoming payload, is put in an idiomatic location where it will always get invoked."]}),"\n",(0,s.jsx)(i.h2,{id:"thinking-in-graphs",children:"Thinking in Graphs"}),"\n",(0,s.jsx)(i.p,{children:'Beyond the reads & writes example, Joist fundamentally lets you "think in graphs" instead of "think in rows & columns".'}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsx)(i.p,{children:"This section needs flushed out more."})}),"\n",(0,s.jsx)(i.h2,{id:"target-market",children:"Target Market"}),"\n",(0,s.jsxs)(i.p,{children:["Joist will work great for any (Postgres) database schema or (TypeScript) team, large or small. We take a lot of inspiration from ",(0,s.jsx)(i.a,{href:"https://guides.rubyonrails.org/active_record_basics.html",children:"ActiveRecord"}),", which of course has been used by many, many applications & teams of all sizes."]}),"\n",(0,s.jsxs)(i.p,{children:["That said, Joist is particularly suited to ",(0,s.jsx)(i.strong,{children:"moderately-to-very complicated business domains"}),"; i.e. stereotypical enterprise back-office systems are an ideal fit for Joist."]}),"\n",(0,s.jsx)(i.p,{children:'Joist\'s framework-style structure, and idiomatic ways of encoding cross-entity business invariants (reactive validation rules, reactive fields, and lifecycle hooks), are all purposefully built to manage the complexity of medium-to-large database schemas/domain models, where "just updating a few columns in this one database row" is insufficient.'})]})}function h(e={}){const{wrapper:i}={...(0,o.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1670:(e,i,t)=>{t.d(i,{Z:()=>r,a:()=>a});var s=t(7378);const o={},n=s.createContext(o);function a(e){const i=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(n.Provider,{value:i},e.children)}}}]);