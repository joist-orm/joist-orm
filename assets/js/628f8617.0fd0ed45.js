"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3801],{3007:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var r=t(4246),i=t(1670);const a={},s=void 0,l={id:"advanced/graphql-filters",title:"graphql-filters",description:"GraphQL-Compatible Filters",source:"@site/docs/advanced/graphql-filters.md",sourceDirName:"advanced",slug:"/advanced/graphql-filters",permalink:"/docs/advanced/graphql-filters",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/advanced/graphql-filters.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Properties Transform",permalink:"/docs/advanced/transform-properties"},next:{title:"FAQ",permalink:"/docs/faq"}},o={},d=[{value:"GraphQL-Compatible Filters",id:"graphql-compatible-filters",level:3}];function c(e){const n={code:"code",h3:"h3",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"graphql-compatible-filters",children:"GraphQL-Compatible Filters"}),"\n",(0,r.jsxs)(n.p,{children:["Joist's ",(0,r.jsx)(n.code,{children:"find"}),' supports the standard "filter as object literal" pattern, i.e.']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const authors = em.find(Author, { age: { gte: 20 } });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And the generated ",(0,r.jsx)(n.code,{children:"AuthorFilter"})," type that drives this query is fairly picky, i.e. ",(0,r.jsx)(n.code,{children:"age: null"})," is not a valid query if the age column is not null."]}),"\n",(0,r.jsxs)(n.p,{children:["This works great for TypeScript code, but when doing interop with GraphQL (i.e. via types generated by graphql-code-generator), Joist's normal ",(0,r.jsx)(n.code,{children:"AuthorFilter"})," typing is \"too good\", i.e. while GraphQL's type system is great, it is more coarse than TypeScript's, so you end up with things like ",(0,r.jsx)(n.code,{children:"age: number | null | undefined"})," on the GQL filter type."]}),"\n",(0,r.jsxs)(n.p,{children:["To handle this, Joist generates separate GraphQL-specific filter types, i.e. ",(0,r.jsx)(n.code,{children:"AuthorGraphQLFilter"}),", that can fairly seamlessly integrate with GraphQL queries with a dedicated ",(0,r.jsx)(n.code,{children:"findGql"})," query methods."]}),"\n",(0,r.jsx)(n.p,{children:"I.e. given some generated GraphQL types like:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"/** Example AuthorFilter generated by graphql-code-generator. */\ninterface GraphQLAuthorFilter {\n  age?: GraphQLIntFilter | null | undefined;\n}\n\n/** Example IntFilter generated by graphql-code-generator. */\ninterface GraphQLIntFilter {\n  eq?: number | null | undefined;\n  in?: number[] | null | undefined;\n  lte?: number | null | undefined;\n  lt?: number | null | undefined;\n  gte?: number | null | undefined;\n  gt?: number | null | undefined;\n  ne?: number | null | undefined;\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Joist's ",(0,r.jsx)(n.code,{children:"EntityManager.findGql"}),' will accept the filter type as-is / "directly off the wire" without any cumbersome mapping:']}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// I.e. from the GraphQL args.filter parameter\nconst gqlFilter: GraphQLAuthorFilter = {\n  age: { eq: 2 },\n};\nconst authors = await em.findGql(Author, gqlFilter);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Also note that while the ",(0,r.jsx)(n.code,{children:"age: { eq: 2 }"}),' is a really clean way to write filters by hand, it can be annoying to dynamically create, i.e. in a UI that needs to conditionally change the operator from "equals" to "not equals", because there is not a single key to bind against in the input type.']}),"\n",(0,r.jsxs)(n.p,{children:["To make building these UIs easier, ",(0,r.jsx)(n.code,{children:"findGql"}),' also accepts a "more-boring" ',(0,r.jsx)(n.code,{children:'{ op: "gt", value: 1 }'})," syntax. The value of the ",(0,r.jsx)(n.code,{children:"op"})," key can be any of the supported operators, i.e. ",(0,r.jsx)(n.code,{children:"gt"}),", ",(0,r.jsx)(n.code,{children:"lt"}),", ",(0,r.jsx)(n.code,{children:"gte"}),", ",(0,r.jsx)(n.code,{children:"ne"}),", etc."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>l,a:()=>s});var r=t(7378);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);