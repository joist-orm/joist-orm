"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[189],{6690:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var s=i(4246),t=i(1670);const a={title:"Single Table Inheritance",sidebar_position:7},l=void 0,o={id:"advanced/single-table-inheritance",title:"Single Table Inheritance",description:"Joist supports Single Table Inheritance, which allows inheritance/subtyping of entities (like class Dog extends Animal), by automatically mapping multiple logical polymorphic entities (Dog, Cat, and Animal) into a single physical SQL table (animals).",source:"@site/docs/advanced/single-table-inheritance.md",sourceDirName:"advanced",slug:"/advanced/single-table-inheritance",permalink:"/docs/advanced/single-table-inheritance",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/advanced/single-table-inheritance.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Single Table Inheritance",sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Class Table Inheritance",permalink:"/docs/advanced/class-table-inheritance"},next:{title:"Full Text Search",permalink:"/docs/advanced/full-text-search"}},c={},d=[{value:"Database Representation",id:"database-representation",level:2},{value:"Entity Representation",id:"entity-representation",level:2},{value:"SubType Configuration",id:"subtype-configuration",level:2},{value:"Tagged Ids",id:"tagged-ids",level:2},{value:"Abstract Base Types",id:"abstract-base-types",level:2},{value:"Pros/Cons to Single Table Inheritance",id:"proscons-to-single-table-inheritance",level:2},{value:"When to Choose STI/CTI",id:"when-to-choose-sticti",level:2}];function r(e){const n={a:"a",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Joist supports ",(0,s.jsx)(n.a,{href:"https://www.martinfowler.com/eaaCatalog/singleTableInheritance.html",children:"Single Table Inheritance"}),", which allows inheritance/subtyping of entities (like ",(0,s.jsx)(n.code,{children:"class Dog extends Animal"}),"), by automatically mapping multiple logical polymorphic entities (",(0,s.jsx)(n.code,{children:"Dog"}),", ",(0,s.jsx)(n.code,{children:"Cat"}),", and ",(0,s.jsx)(n.code,{children:"Animal"}),") into a single physical SQL table (",(0,s.jsx)(n.code,{children:"animals"}),")."]}),"\n",(0,s.jsx)(n.h2,{id:"database-representation",children:"Database Representation"}),"\n",(0,s.jsxs)(n.p,{children:["For example, lets say we have a ",(0,s.jsx)(n.code,{children:"Dog"})," entity and a ",(0,s.jsx)(n.code,{children:"Cat"})," entity, and we want them to both extend the ",(0,s.jsx)(n.code,{children:"Animal"})," entity."]}),"\n",(0,s.jsxs)(n.p,{children:["For single table inheritance, we represent this in Postgres by having a single table: ",(0,s.jsx)(n.code,{children:"animals"}),"."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The ",(0,s.jsx)(n.code,{children:"animals"})," table has all columns for ",(0,s.jsx)(n.code,{children:"Animal"}),"s, ",(0,s.jsx)(n.code,{children:"Dog"}),"s, or ",(0,s.jsx)(n.code,{children:"Cat"}),"s"]}),"\n",(0,s.jsxs)(n.li,{children:["A discriminator column, i.e. ",(0,s.jsx)(n.code,{children:"type_id"}),", tells Joist whether a given row is a ",(0,s.jsx)(n.code,{children:"Dog"})," or a ",(0,s.jsx)(n.code,{children:"Cat"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"We currently require the discriminator field to be an enum column"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Any ",(0,s.jsx)(n.code,{children:"Dog"}),"-only columns are configured in ",(0,s.jsx)(n.code,{children:"joist-config.json"})]}),"\n",(0,s.jsxs)(n.li,{children:["Any ",(0,s.jsx)(n.code,{children:"Cat"}),"-only columns are configured in ",(0,s.jsx)(n.code,{children:"joist-config.json"})]}),"\n",(0,s.jsxs)(n.li,{children:["Any ",(0,s.jsx)(n.code,{children:"Dog"}),"- or ",(0,s.jsx)(n.code,{children:"Cat"}),"-only columns must be nullable"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["The",(0,s.jsx)(n.code,{children:"joist-config.json"})," might look like:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "entities": {\n    "Animal": {\n      "fields": {\n        "type": { "stiDiscriminator": { "DOG": "Dog", "CAT": "Cat" } },\n        "canBark": { "stiType": "Dog" },\n        "canMeow": { "stiType": "Cat", "stiNotNull": true }\n      },\n      "tag": "a"\n    },\n    "DogPack": {\n      "relations": {\n        "leader": { "stiType": "Dog" }\n      },\n      "tag": "dp"\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"entity-representation",children:"Entity Representation"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"joist-codegen"})," sees the above ",(0,s.jsx)(n.code,{children:"joist-config.json"})," setup, Joist will ensure that the ",(0,s.jsx)(n.code,{children:"Dog"})," model extends the ",(0,s.jsx)(n.code,{children:"Animal"})," model."]}),"\n",(0,s.jsx)(n.p,{children:"Note that because of the codegen entities, it will actually end up looking like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// in Dog.ts\nclass Dog extends DogCodegen {\n   // any custom logic\n}\n\n// in DogCodegen.ts\nabstract class DogCodegen extends Animal {\n  can_bark: boolean;\n}\n\n// in Animal.ts\nclass Animal extends AnimalCodegen {\n   // any custom logic\n}\n\n// in AnimalCodegen.ts\nabstract class AnimalCodegen extends BaseEntity {\n   name: string;\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["And when you load several ",(0,s.jsx)(n.code,{children:"Animal"}),"s, Joist will automatically read the ",(0,s.jsx)(n.code,{children:"type_id"})," column and create the respective subtype:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'const [a1, a2] = await em.loadAll(Animal, ["a:1", "a:2"]);\n// If a1 was saved as a dog, it will be a Dog\nexpect(a1).toBeInstanceOf(Dog);\n// if a2 was saved as a cat, it will be a Cat\nexpect(a2).toBeInstanceOf(Cat);\n'})}),"\n",(0,s.jsx)(n.h2,{id:"subtype-configuration",children:"SubType Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["Due to STI's lack of schema-based encoding (see Pros/Cons section below), you may often need to manually configure the ",(0,s.jsx)(n.code,{children:"joist-config.json"}),' to give Joist hints about "which subtype" a given relation should be.']}),"\n",(0,s.jsxs)(n.p,{children:["For example, instead of the ",(0,s.jsx)(n.code,{children:"DogPack.leader"})," relation (from the ",(0,s.jsx)(n.code,{children:"dog_packers.leader_id"})," FK) being typed as ",(0,s.jsx)(n.code,{children:"Animal"})," (which is the ",(0,s.jsx)(n.code,{children:"animals"})," table that the ",(0,s.jsx)(n.code,{children:"leader_id"})," FK points to in the database schema), you want it to be typed as ",(0,s.jsx)(n.code,{children:"Dog"})," because you know all ",(0,s.jsx)(n.code,{children:"DogPack"})," leader's should be ",(0,s.jsx)(n.code,{children:"Dog"}),"s."]}),"\n",(0,s.jsxs)(n.p,{children:["These hints in ",(0,s.jsx)(n.code,{children:"joist-config.json"})," generally look like:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Adding an ",(0,s.jsx)(n.code,{children:"stiDiscriminator"})," mapping to the ",(0,s.jsx)(n.code,{children:"type"}),' field that Joist will use to know "which subtype is this?"']}),"\n",(0,s.jsxs)(n.li,{children:["Adding ",(0,s.jsx)(n.code,{children:'stiType: "Dog"'})," or ",(0,s.jsx)(n.code,{children:'stiType: "Cat"'})," to any field (like ",(0,s.jsx)(n.code,{children:"canBark"})," or ",(0,s.jsx)(n.code,{children:"canMeow"}),") in the ",(0,s.jsx)(n.code,{children:"animals"})," table that should be limited to a specific subtype","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The value of ",(0,s.jsx)(n.code,{children:'"Dog"'})," or ",(0,s.jsx)(n.code,{children:'"Cat"'})," should match a name in the ",(0,s.jsx)(n.code,{children:"stiDiscriminator"})," mapping"]}),"\n",(0,s.jsx)(n.li,{children:"Currently, we only support a field being in a single subtype"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Adding ",(0,s.jsx)(n.code,{children:"stiNotNull: true"})," to any fields that you want Joist to enforce as not null","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["For example, if you want ",(0,s.jsx)(n.code,{children:"canMewo"})," to be required for all ",(0,s.jsx)(n.code,{children:"Cat"}),"s, you can add ",(0,s.jsx)(n.code,{children:"stiNotNull: true"})," to the ",(0,s.jsx)(n.code,{children:"canMeow"})," field"]}),"\n",(0,s.jsxs)(n.li,{children:["Without an explicit ",(0,s.jsx)(n.code,{children:"stiNotNull"})," set, we assume subtype fields are nullable, which is how they're represented in the database"]}),"\n",(0,s.jsx)(n.li,{children:'See the "Pros/Cons" section later for why this can\'t be encoded in the database'}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["On any FKs that point ",(0,s.jsx)(n.em,{children:"to"})," your base type, add ",(0,s.jsx)(n.code,{children:'stiType: "SubType"'})," to indicate that the FK is only valid for the given subtype.","\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["See the ",(0,s.jsx)(n.code,{children:"DogPack"})," example in the above example config"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"tagged-ids",children:"Tagged Ids"}),"\n",(0,s.jsx)(n.p,{children:"Currently, subtypes share the same tagged id as the base type."}),"\n",(0,s.jsxs)(n.p,{children:["For example, ",(0,s.jsx)(n.code,{children:"dog1.id"})," returns ",(0,s.jsx)(n.code,{children:"a:1"})," because the ",(0,s.jsx)(n.code,{children:"Dog"}),"'s base type is ",(0,s.jsx)(n.code,{children:"Animal"}),", and all ",(0,s.jsx)(n.code,{children:"Animal"}),"s (regardless of whether they're ",(0,s.jsx)(n.code,{children:"Dog"}),"s or ",(0,s.jsx)(n.code,{children:"Cat"}),"s) use the ",(0,s.jsx)(n.code,{children:"a"})," tag."]}),"\n",(0,s.jsx)(n.h2,{id:"abstract-base-types",children:"Abstract Base Types"}),"\n",(0,s.jsxs)(n.p,{children:["If you'd like to enforce that base type is abstract, i.e. that users cannot instantiate ",(0,s.jsx)(n.code,{children:"Animal"}),", they must instantiate either a ",(0,s.jsx)(n.code,{children:"Dog"})," or ",(0,s.jsx)(n.code,{children:"Cat"}),", then you can mark ",(0,s.jsx)(n.code,{children:"Animal"})," as ",(0,s.jsx)(n.code,{children:"abstract"})," in the ",(0,s.jsx)(n.code,{children:"joist-config.json"})," file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "entities": {\n    "Animal": {\n      "tag": "a",\n      "abstract": true\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You also need to manually update the ",(0,s.jsx)(n.code,{children:"Animal.ts"})," file to make the class ",(0,s.jsx)(n.code,{children:"abstract"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export abstract class Animal extends AnimalCodegen {}\n"})}),"\n",(0,s.jsxs)(n.p,{children:["After this, Joist will enforce that all ",(0,s.jsx)(n.code,{children:"Animal"}),"s must be either ",(0,s.jsx)(n.code,{children:"Dog"}),"s or ",(0,s.jsx)(n.code,{children:"Cat"}),"s."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, if an ",(0,s.jsx)(n.code,{children:'em.load(Animal, "a:1")'})," finds a row only in the ",(0,s.jsx)(n.code,{children:"animals"})," table, and no matching row in the ",(0,s.jsx)(n.code,{children:"dogs"})," or ",(0,s.jsx)(n.code,{children:"cats"})," table, then the ",(0,s.jsx)(n.code,{children:"em.load"})," method will fail with an error message."]}),"\n",(0,s.jsx)(n.h2,{id:"proscons-to-single-table-inheritance",children:"Pros/Cons to Single Table Inheritance"}),"\n",(0,s.jsxs)(n.p,{children:["Between Single Table Inheritance (STI) and ",(0,s.jsx)(n.a,{href:"/docs/advanced/class-table-inheritance",children:"Class Table Inheritance"})," (CTI), Joist generally recommends using CTI over STI for the following reasons:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"With CTI, the database schema makes it obvious what the class hierarchy should be."}),"\n",(0,s.jsx)(n.p,{children:'Given the schema itself already has the per-type fields split out (into separate tables), there is very little configuration for CTI, and instead the generated entities are basically "automatically correct".'}),"\n",(0,s.jsxs)(n.p,{children:["With STI, this schema-based encoding does not exist, so we have to configure items like the discriminator value, and which fields belong to which subtype, in the ",(0,s.jsx)(n.code,{children:"joist-config.json"}),". This is doable, but tedious."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"With CTI, the schema is safer, because the subtype-only columns can have not-null constraints."}),"\n",(0,s.jsxs)(n.p,{children:["With STI, if we want ",(0,s.jsx)(n.code,{children:"can_bark"})," to be required for all ",(0,s.jsx)(n.code,{children:"Dog"}),"s, we cannot use a ",(0,s.jsx)(n.code,{children:"can_bark boolean NOT NULL"})," in the schema, because the ",(0,s.jsx)(n.code,{children:"animals"})," table will also have ",(0,s.jsx)(n.code,{children:"Cat"})," rows that fundamentally don't have ",(0,s.jsx)(n.code,{children:"can_bark"})," values."]}),"\n",(0,s.jsxs)(n.p,{children:["Instead, we have to indicate in ",(0,s.jsx)(n.code,{children:"joist-config.json"})," that Joist should enforce model-level not-null constraints, which is okay, but not as good as database-level enforcement."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsx)(n.p,{children:"With CTI, we can have foreign keys point directly to subtypes."}),"\n",(0,s.jsxs)(n.p,{children:["For example, we could have a ",(0,s.jsx)(n.code,{children:"DogPack"})," entity with a ",(0,s.jsx)(n.code,{children:"dog_packs.leader_id"})," foreign key that references the ",(0,s.jsx)(n.code,{children:"dogs"})," subtype table, and so points ",(0,s.jsx)(n.em,{children:"only"})," to ",(0,s.jsx)(n.code,{children:"Dog"}),"s, and is fundamentally unable to point to ",(0,s.jsx)(n.code,{children:"Cat"}),"s (even at the database level, this is enforced b/c the ",(0,s.jsx)(n.code,{children:"dogs"})," table will not have any ids of ",(0,s.jsx)(n.code,{children:"Cat"})," entities)."]}),"\n",(0,s.jsxs)(n.p,{children:["With STI, it's not possible in the database to represent/enforce that FKs are only valid for a specific subtype (",(0,s.jsx)(n.code,{children:"dog_packs.leader_id"})," can only point to the ",(0,s.jsx)(n.code,{children:"animals"})," table)."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["That said, the pro of STI is that you don't need ",(0,s.jsx)(n.code,{children:"LEFT OUTER JOIN"}),"s to load entities (see the ",(0,s.jsx)(n.a,{href:"/docs/advanced/class-table-inheritance",children:"CTI"})," docs), b/c all data for all subtypes is a single table."]}),"\n",(0,s.jsx)(n.h2,{id:"when-to-choose-sticti",children:"When to Choose STI/CTI"}),"\n",(0,s.jsxs)(n.p,{children:["To application code, the STI and CTI approach can look near identical, because both approaches result in the same ",(0,s.jsx)(n.code,{children:"Dog"}),", ",(0,s.jsx)(n.code,{children:"Cat"}),", and ",(0,s.jsx)(n.code,{children:"Animal"})," type hierarchy."]}),"\n",(0,s.jsx)(n.p,{children:"But, generally Joist recommends:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:['Use CTI when the polymorphism is an integral part of your domain model, i.e. you have "true" ',(0,s.jsx)(n.code,{children:"Cat"})," and ",(0,s.jsx)(n.code,{children:"Dog"})," entities as separate concepts you want to model in your domain"]}),"\n",(0,s.jsxs)(n.li,{children:["Use STI when the polymorphism is for a transient implementation detail, i.e. migrating your ",(0,s.jsx)(n.code,{children:"Cat"})," model to a ",(0,s.jsx)(n.code,{children:"CatV2"})," model."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"And, either way, use both approaches judiciously; in a system of 50-100 entities, you should probably be using CTI/STI only a handful of times."})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(r,{...e})}):r(e)}},1670:(e,n,i)=>{i.d(n,{Z:()=>o,a:()=>l});var s=i(7378);const t={},a=s.createContext(t);function l(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:l(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);