"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[954],{6407:(e,i,n)=>{n.r(i),n.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>d});var s=n(4246),t=n(1670);const o={title:"Loading Entities",sidebar_position:2},r=void 0,a={id:"features/loading-entities",title:"Loading Entities",description:"Joist has several ways to load entities, and which to use depends on how much control you need over the query.",source:"@site/docs/features/loading-entities.md",sourceDirName:"features",slug:"/features/loading-entities",permalink:"/docs/features/loading-entities",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/features/loading-entities.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Loading Entities",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Entity Manager",permalink:"/docs/features/entity-manager"},next:{title:"Find Queries",permalink:"/docs/features/queries-find"}},l={},d=[{value:"Approaches",id:"approaches",level:2},{value:"1. Object Graph Navigation",id:"1-object-graph-navigation",level:3},{value:"2. Find Queries",id:"2-find-queries",level:3},{value:"3. Other Query Builders",id:"3-other-query-builders",level:3},{value:"<code>buildQuery</code>",id:"buildquery",level:4}];function c(e){const i={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:"Joist has several ways to load entities, and which to use depends on how much control you need over the query."}),"\n",(0,s.jsxs)(i.admonition,{type:"tip",children:[(0,s.jsxs)(i.p,{children:["Joist's primary focus is not \"",(0,s.jsx)(i.em,{children:"never"}),' having to hand-write SQL", so it is not a full-fledged query builder (like ',(0,s.jsx)(i.a,{href:"https://knexjs.org/",children:"Knex"})," or ",(0,s.jsx)(i.a,{href:"https://github.com/koskimas/kysely",children:"Kysely"}),"); instead it focuses on robust domain modeling, with validation rules, reactive derived values, etc."]}),(0,s.jsx)(i.p,{children:"So it's expected to, for advanced/complicated queries, occasionally use a 3rd party query builder in addition to Joist, as covered in Approach 3."})]}),"\n",(0,s.jsx)(i.h2,{id:"approaches",children:"Approaches"}),"\n",(0,s.jsx)(i.p,{children:"Loading entities is a core feature of ORMs, and Joist supports several ways of doing this:"}),"\n",(0,s.jsx)(i.h3,{id:"1-object-graph-navigation",children:"1. Object Graph Navigation"}),"\n",(0,s.jsx)(i.p,{children:'This is the bread & butter of ORMs, and involves just "walking the graph" from some entity you already have, to other entities that are related to it. Examples are:'}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-ts",children:'// Calling .load() methods directly\nconst author = await book.author.load();\n// Using a lens\nconst reviews = await publisher.load(p => p.books.reviews);\n// Using populate + gets\nconst loaded = author.populate({ books: "reviews" });\nloaded.books.get.flatMap(b => b.reviews.get);\n'})}),"\n",(0,s.jsxs)(i.p,{children:["This pattern will likely be ",(0,s.jsx)(i.strong,{children:"~90% of the queries"}),' in your app, and are so pervasive/ergonomic that you likely won\'t even think of them as "making SQL queries".']}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Pro: The most succinct way of loading entities."}),"\n",(0,s.jsx)(i.li,{children:"Pro: Joist guarantees these will not N+1, even if called in a loop."}),"\n",(0,s.jsxs)(i.li,{children:["Pro: Works with non-database/domain model-only relations like Joist's ",(0,s.jsx)(i.code,{children:"hasOneDerived"}),", ",(0,s.jsx)(i.code,{children:"hasOneThrough"}),", ",(0,s.jsx)(i.code,{children:"AsyncProperties"}),", etc."]}),"\n",(0,s.jsxs)(i.li,{children:["Con: Generally object graph navigation loads all entities within the sub-graph you're walking, i.e. you can't say \"return only ",(0,s.jsx)(i.em,{children:"out of stock"}),' books" (see ',(0,s.jsx)(i.code,{children:"find"})," queries next)"]}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"2-find-queries",children:"2. Find Queries"}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.code,{children:"EntityManager.find"})," queries are a middle-ground that allow database-side filtering of rows, and so return only a subset of data (instead of the full subgraph like approach 1). Examples are:"]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-ts",children:'const r1 = await em.find(Book, { author: { firstName: "b1" } });\nconst r2 = await em.find(Publisher, { authors: { firstName: "b1" } });\nconst r3 = await em.find(Author, { firstName: { like: "%a%" } });\nconst r4 = await em.find(Author, { publisher: p1 });\n'})}),"\n",(0,s.jsxs)(i.p,{children:["If object graph navigation is ~80% of your application's queries (because they are all implicit), ",(0,s.jsx)(i.code,{children:"em.find"})," queries will likely be ",(0,s.jsx)(i.strong,{children:"~15% of your queries"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["See ",(0,s.jsx)(i.a,{href:"./queries-find",children:"Find Queries"})," for more documentation and examples."]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Pro: Still succinct because joins are implicit in the object literal"}),"\n",(0,s.jsxs)(i.li,{children:["Pro: Supports ",(0,s.jsx)(i.code,{children:"WHERE"}),"-based filtering/returning a subset of entities"]}),"\n",(0,s.jsx)(i.li,{children:"Pro: N+1 safe even when called in a loop"}),"\n",(0,s.jsxs)(i.li,{children:["Con: Cannot use domain model-level relations like Joist's ",(0,s.jsx)(i.code,{children:"hasOneDerived"}),", ",(0,s.jsx)(i.code,{children:"hasOneThrough"}),", ",(0,s.jsx)(i.code,{children:"AsyncProperties"}),", etc."]}),"\n",(0,s.jsx)(i.li,{children:"Con: Loads only full entities, not cross-table aggregates/group bys/etc."}),"\n"]}),"\n",(0,s.jsx)(i.h3,{id:"3-other-query-builders",children:"3. Other Query Builders"}),"\n",(0,s.jsxs)(i.p,{children:["For queries that grow outside what ",(0,s.jsx)(i.code,{children:"em.find"})," can provide, i.e. ",(0,s.jsx)(i.strong,{children:"the last ~5% of your application's queries"})," that are truly custom, then it's perfectly fine to use a 3rd-party query builder like ",(0,s.jsx)(i.a,{href:"https://knexjs.org/",children:"Knex"})," or ",(0,s.jsx)(i.a,{href:"https://github.com/koskimas/kysely",children:"Kysely"}),"."]}),"\n",(0,s.jsx)(i.p,{children:"Knex would be a natural choice, because Joist uses Knex as an internal dependency, but Kysely would be fine too."}),"\n",(0,s.jsx)(i.p,{children:"In particular, any queries that need to:"}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Group bys/aggregates"}),"\n",(0,s.jsx)(i.li,{children:"Select custom fragments of data (not just an entity)"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"Are best done via Knex or Kysely."}),"\n",(0,s.jsx)(i.h4,{id:"buildquery",children:(0,s.jsx)(i.code,{children:"buildQuery"})}),"\n",(0,s.jsxs)(i.p,{children:["Joist provides a ",(0,s.jsx)(i.code,{children:"buildQuery"})," method that allows blending approaches 2 and 3: you can pass an ",(0,s.jsx)(i.code,{children:"em.find"}),"-style join literal to ",(0,s.jsx)(i.code,{children:"buildQuery"})," (with either inline or complex conditions), and get back a Knex ",(0,s.jsx)(i.code,{children:"QueryBuilder"})," with all the joins and conditions added, to which you can do your own further joins or filters."]}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-ts",children:'const query = buildQuery(knex, Book, {\n  where: { author: [a1, a2] },\n});\n// Use knex methods to continue building the query\nquery.whereNotNull("parent_bill_id");\n// Then load the entities with the customizing query\nconst books = await em.loadFromQuery(Book, query);\n'})}),"\n",(0,s.jsxs)(i.admonition,{type:"tip",children:[(0,s.jsxs)(i.p,{children:["These three options all focus on loading ",(0,s.jsx)(i.em,{children:"entities"}),", which your code will then iterate over to perform business/view logic."]}),(0,s.jsx)(i.p,{children:'If you need to load bespoke, non-entity fragments of data across several tables (i.e. with aggregates/group bys/etc.), that is currently not a feature that Joist provides, so you must use a separate raw query builder, as per the "option 3" in the above list.'})]})]})}function h(e={}){const{wrapper:i}={...(0,t.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1670:(e,i,n)=>{n.d(i,{Z:()=>a,a:()=>r});var s=n(7378);const t={},o=s.createContext(t);function r(e){const i=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function a(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:i},e.children)}}}]);