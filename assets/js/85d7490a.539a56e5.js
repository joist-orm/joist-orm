"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3829],{3023:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>o});var s=n(3696);const r={},i=s.createContext(r);function a(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),s.createElement(i.Provider,{value:t},e.children)}},5520:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"modeling/derived-properties","title":"Derived Properties","description":"In Joist, Derived Properties are values that can be calculated/derived from other data within your domain model, for example:","source":"@site/docs/modeling/derived-properties.md","sourceDirName":"modeling","slug":"/modeling/derived-properties","permalink":"/docs/modeling/derived-properties","draft":false,"unlisted":false,"editUrl":"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/modeling/derived-properties.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"title":"Derived Properties","sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Reactive Fields","permalink":"/docs/modeling/reactive-fields"},"next":{"title":"Validation Rules","permalink":"/docs/modeling/validation-rules"}}');var r=n(2540),i=n(3023);const a={title:"Derived Properties",sidebar_position:5},o=void 0,l={},c=[{value:"Sync Properties",id:"sync-properties",level:2},{value:"Async Properties",id:"async-properties",level:2},{value:"Reactive Getters",id:"reactive-getters",level:2},{value:"Reactive Async Properties",id:"reactive-async-properties",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"In Joist, Derived Properties are values that can be calculated/derived from other data within your domain model, for example:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:["Deriving an Author's ",(0,r.jsx)(t.code,{children:"fullName"})," from their ",(0,r.jsx)(t.code,{children:"firstName"})," and ",(0,r.jsx)(t.code,{children:"lastName"})]}),"\n",(0,r.jsxs)(t.li,{children:["Deriving an Author's ",(0,r.jsx)(t.code,{children:"numberOfBooks"})," from their ",(0,r.jsx)(t.code,{children:"books"})," collection"]}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:["Derived Properties ",(0,r.jsx)(t.strong,{children:"are not stored in the database"}),", but are calculated on-the-fly when accessed. Joist also supports ",(0,r.jsx)(t.a,{href:"./reactive-fields",children:"Reactive Fields"}),", which are similar to Derived Properties but ",(0,r.jsx)(t.strong,{children:"are stored in the database"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"sync-properties",children:"Sync Properties"}),"\n",(0,r.jsx)(t.p,{children:"Synchronous properties calculate their value from other values immediately available on the same entity; because of this, they can always be accessed, and are just getters:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:'class Author {\n  get fullName(): string {\n    return this.firstName + (this.lastName ? ` ${this.lastName}` : "");\n  }\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"async-properties",children:"Async Properties"}),"\n",(0,r.jsx)(t.p,{children:"Asynchronous Properties calculate their value from the entity and other related child/parent entities."}),"\n",(0,r.jsxs)(t.p,{children:["For example, to implement an ",(0,r.jsx)(t.code,{children:"Author"}),"'s ",(0,r.jsx)(t.code,{children:"numberOfBooks"})," property that requires counting the Author's ",(0,r.jsx)(t.code,{children:"books"})," collection, use ",(0,r.jsx)(t.code,{children:"hasAsyncProperty"})," with a populate hint stating it depends on the ",(0,r.jsx)(t.code,{children:"books"})," collection:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'export class Author {\n  readonly numberOfBooks: AsyncProperty<Author, number> = hasAsyncProperty(\n    // Declare the relations to load\n    "books",\n    // Only `a.books` will be marked as loaded\n    (a) => { a.books.get.length }\n  );\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Because this calculation fundamentally requires having the ",(0,r.jsx)(t.code,{children:"books"})," loaded, it is marked as ",(0,r.jsx)(t.code,{children:"async"})," and requires loading with a populate hint to access:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'// Load an author without any populate hints\nconst a1 = await em.load(Author, "a:1");\n// `.get` is not available, so `numberOfBooks` requires an await\nconst num1 = await a1.numberOfBooks.load();\n\n// Load the author with `numberOfBooks` populated\nconst a2 = await em.load(Author, "a:1", "numberOfBooks");\n// `.get` is now available and can be called immediately\nconst num2 = a2.numberOfBooks.get;\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Like populate hints, ",(0,r.jsx)(t.code,{children:"hasAsyncProperty"}),"s can used nested hints:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'export class Author {\n  readonly latestComments: AsyncProperty<Author, Comment[]> = hasAsyncProperty(\n    // Pass a nested load hint\n    { publisher: "comments", comments: {} },\n    // `a` will have the deep relations loaded\n    (a) => [...(a.publisher.get?.comments.get ?? []), ...a.comments.get],\n  );\n}\n'})}),"\n",(0,r.jsx)(t.h2,{id:"reactive-getters",children:"Reactive Getters"}),"\n",(0,r.jsxs)(t.p,{children:["If you want to access derived properties, like the ",(0,r.jsx)(t.code,{children:"fullName"})," getter in the first example, from ",(0,r.jsx)(t.a,{href:"./reactive-fields",children:"Reactive Fields"}),", Joist needs to know which specific fields ",(0,r.jsx)(t.code,{children:"fullName"})," depends."]}),"\n",(0,r.jsxs)(t.p,{children:["You can do this by using ",(0,r.jsx)(t.code,{children:"hasReactiveGetter"}),", which declares the business logic's dependencies:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'class Author {\n  readonly fullName: ReactiveGetter<Author, string> = hasReactiveGetter(\n    "fullName",\n    // Declare the other fields we depend on\n    ["firstName", "lastName"],\n    // `a` will be limited to using only `firstName` and `lastName`\n    a => a.firstName + (a.lastName ? ` ${a.lastName}` : ""),\n  );\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Now, even though ",(0,r.jsx)(t.code,{children:"Author.fullName"})," itself is not stored in the database, if any ",(0,r.jsx)(t.strong,{children:"other"})," reactive values want to depend on ",(0,r.jsx)(t.code,{children:"Author.fullName"}),", Joist will know when the ",(0,r.jsx)(t.code,{children:"fullName"})," value becomes dirty, and those downstream values should be recalculated."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"ReactiveGetter"}),"s are limited to depending on fields directly on the entity itself, which means they can be accessed at any time, without being loaded:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'// Load the author, without any populate hint\nconst a = await em.load(Author, "a:1");\n// We can still call the fullName logic\nconsole.log(a.fullName.get);\n'})}),"\n",(0,r.jsx)(t.h2,{id:"reactive-async-properties",children:"Reactive Async Properties"}),"\n",(0,r.jsxs)(t.p,{children:["Similar to Reactive Getters, if you have a ",(0,r.jsx)(t.a,{href:"./reactive-fields",children:"Reactive Field"})," that wants to depend on an Async Property, you need to declare the property's ",(0,r.jsx)(t.strong,{children:"field-level"})," dependencies by using ",(0,r.jsx)(t.code,{children:"hasReactiveAsyncProperty"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-typescript",children:'export class Author {\n  readonly numberOfBooks: AsyncProperty<Author, number> =\n   hasReactiveAsyncProperty(\n     // Now this is a field-level reactive hint\n     { books: "title" },\n     // `a` can only access fields declared by the hint\n     (a) => a.books.get.filter((b) => b.title !== undefined).length,\n   );\n}\n'})}),"\n",(0,r.jsxs)(t.p,{children:["This is similar to regular ",(0,r.jsx)(t.code,{children:"hasAsyncProperty"}),"s, except that the hint declares the specific fields that the lambda uses, and the lambda will be restricted from using any field not declared in the hint."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);