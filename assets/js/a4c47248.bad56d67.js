"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6436],{3341:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var a=t(4246),o=t(1670);const s={title:"New NextJS Sample App",description:"We've added a new NextJS sample app to the Joist repository.",slug:"nextjs-sample-app",authors:[{name:"Stephen Haberman",url:"https://github.com/stephenh",image_url:"https://github.com/stephenh.png"}],tags:[]},i=void 0,r={permalink:"/blog/nextjs-sample-app",source:"@site/blog/2024-04-21-nextjs-sample.md",title:"New NextJS Sample App",description:"We've added a new NextJS sample app to the Joist repository.",date:"2024-04-21T00:00:00.000Z",tags:[],readingTime:6.67,hasTruncateMarker:!1,authors:[{name:"Stephen Haberman",url:"https://github.com/stephenh",image_url:"https://github.com/stephenh.png",imageURL:"https://github.com/stephenh.png"}],frontMatter:{title:"New NextJS Sample App",description:"We've added a new NextJS sample app to the Joist repository.",slug:"nextjs-sample-app",authors:[{name:"Stephen Haberman",url:"https://github.com/stephenh",image_url:"https://github.com/stephenh.png",imageURL:"https://github.com/stephenh.png"}],tags:[]},unlisted:!1,prevItem:{title:"The Best ORM, Ever?",permalink:"/blog/the-best-orm-ever"},nextItem:{title:"Welcome",permalink:"/blog/welcome-blog"}},l={authorsImageUrls:[void 0]},d=[{value:"Two Render Tree Approaches",id:"two-render-tree-approaches",level:2},{value:"Automatic N+1 Prevention",id:"automatic-n1-prevention",level:2},{value:"JSON Payload/Props Creation",id:"json-payloadprops-creation",level:2},{value:"Join-Based Preloading",id:"join-based-preloading",level:2},{value:"What about Complex Queries?",id:"what-about-complex-queries",level:2},{value:"Sample App Feedback",id:"sample-app-feedback",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.p,{children:["We've added a new ",(0,a.jsx)(n.a,{href:"https://github.com/joist-orm/joist-nextjs-sample/",children:"NextJS + Joist"})," sample app that shows how Joist can be used in a NextJS application, with several benefits:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Automatic N+1 Prevention"}),"\n",(0,a.jsx)(n.li,{children:"JSON Payload/Props Creation"}),"\n",(0,a.jsx)(n.li,{children:"Optional Join-based Preloading"}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["This post gives a short overview; if you'd like to watch a video, we also have a ",(0,a.jsx)(n.a,{href:"https://youtu.be/H_qJdKUS9D0",children:"YouTube video"})," that walks through the sample app."]}),"\n",(0,a.jsx)("div",{style:{display:"grid",placeItems:"center"},children:(0,a.jsx)("iframe",{width:"750",height:"420",src:"https://www.youtube.com/embed/H_qJdKUS9D0?si=qUiRr0GTMrQCgayC",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",referrerpolicy:"strict-origin-when-cross-origin",allowfullscreen:!0})}),"\n",(0,a.jsx)(n.h2,{id:"two-render-tree-approaches",children:"Two Render Tree Approaches"}),"\n",(0,a.jsx)(n.p,{children:"While building the sample app, we found two fundamental ways of structuring a NextJS app's render tree:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Fewer React Server Components, that prop drill data to the Client Components","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Shown on the left, see ",(0,a.jsx)(n.code,{children:"author-rcc-card.tsx"})," and ",(0,a.jsx)(n.code,{children:"book-rcc-preview.tsx"})]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["Mostly React Server Components, with Client Components only at the bottom","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Shown on the right, see ",(0,a.jsx)(n.code,{children:"author-rsc-card.tsx"})," and ",(0,a.jsx)(n.code,{children:"book-rsc-preview.tsx"})]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)("div",{style:{padding:"24px"},children:(0,a.jsx)("img",{src:"/images/nextjs-sample-single-multiple-rscs.png"})}),"\n",(0,a.jsxs)(n.p,{children:["The top-level ",(0,a.jsx)(n.code,{children:"Table"})," / ",(0,a.jsx)(n.code,{children:"table.tsx"})," component renders each of these side-by-side, so we can see the differences, and observe some pros/cons of each approach."]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsx)(n.p,{children:"With mostly RSC components, it's easy to decompose data loading away from the top-level component."}),"\n",(0,a.jsxs)(n.p,{children:["For example, the ",(0,a.jsx)(n.code,{children:"AuthorRscCard"})," can make its own data loading calls, and even if it's render many pages on the page, Joist will de-dupe across the ",(0,a.jsx)(n.code,{children:"N"})," sibling ",(0,a.jsx)(n.code,{children:"AuthorRscCard"}),"s, and batch into a single SQL call."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:'type AuthorCardProps = {\n  /** RSCs can accept the domain model enities as a prop. */\n  author: Author;\n  addBook: (id: string) => Promise<void>;\n};\n\n/** The RSC version of AuthorCard can load it\'s own data. */\nexport async function AuthorRscCard({ author, addBook }: AuthorCardProps) {\n  // This will be auto-batched if many cards render at once\n  const books = await author.books.load();\n  // Or if you wanted a tree of data, this will also be auto-batched\n  const loaded = await author.populate({ books: { reviews: "ratings" } });\n  return <div>...jsx</div>;\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["This is nice because it allows the ",(0,a.jsx)(n.code,{children:"AuthorRscCard"})," to be more self-sufficient, and allow the parent table component to be unaware of its children loading details."]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["\n",(0,a.jsxs)(n.p,{children:["With mostly Client components, the opposite happens, and only the parent can make database / ",(0,a.jsx)(n.code,{children:"EntityManager"})," calls, and so is responsible for loading all the data for its children, and passing it as JSON via props:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"type AuthorCardProps = {\n  /** RCCs must accept a POJO of `Author` + all nested data. */\n  author: AuthorPayload;\n  addBook: (id: string) => Promise<void>;\n};\n\n/** The RCC version of AuthorCard accepts the `AuthorPayload`. */\nexport function AuthorRccCard({ author, addBook }: AuthorCardProps) {\n  // can only use data already available on `author` \n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Even though the up-front data load can become awkward, it does give more opportunities for optimizations; for example Joist can use join-based preloading to load a single tree of ",(0,a.jsx)(n.code,{children:"Author"})," + ",(0,a.jsx)(n.code,{children:"Book"})," + ",(0,a.jsx)(n.code,{children:"Review"}),' entities in a single SQL call, which is even better optimization than the "one query per layer" N+1 prevention of the RSC-based approach.']}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"automatic-n1-prevention",children:"Automatic N+1 Prevention"}),"\n",(0,a.jsx)(n.p,{children:"In either approach, Joist's N+1 prevention auto-batches database calls, even if they are made across separate component renders. I.e. in the RSC components:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["The top-level ",(0,a.jsx)(n.code,{children:"Table"})," component makes 1 SQL call for all ",(0,a.jsx)(n.code,{children:"Author"})," entities."]}),"\n",(0,a.jsxs)(n.li,{children:["All 2nd-level ",(0,a.jsx)(n.code,{children:"AuthorRscCard"})," cards each make their own ",(0,a.jsx)(n.code,{children:"author.books.load()"})," (or ",(0,a.jsx)(n.code,{children:"author.populate(...)"}),") call, but because they're all rendered in the same event loop, Joist batches all the ",(0,a.jsx)(n.code,{children:"load"})," calls into 1 SQL call"]}),"\n",(0,a.jsxs)(n.li,{children:["Any 3rd-level components would have their ",(0,a.jsx)(n.code,{children:"load"})," calls batched as well."]}),"\n"]}),"\n",(0,a.jsxs)(n.p,{children:["In the React Client Component approach, this auto-batching is admittedly not as necessary, assuming a singular top-level component, like ",(0,a.jsx)(n.code,{children:"Table"}),", loads all the data at once anyway (although, as mentioned later, Joist can optimize that as well)."]}),"\n",(0,a.jsxs)(n.p,{children:["See the ",(0,a.jsx)(n.a,{href:"/docs/goals/avoiding-n-plus-1s",children:"Avoiding N+1s"})," section of our docs for more information."]}),"\n",(0,a.jsx)(n.h2,{id:"json-payloadprops-creation",children:"JSON Payload/Props Creation"}),"\n",(0,a.jsxs)(n.p,{children:["Since the client components cannot make their own async data calls, the top-level ",(0,a.jsx)(n.code,{children:"Table"})," components is responsible for loading all the data into a JSON payload, and passing it down to the children as props."]}),"\n",(0,a.jsxs)(n.p,{children:["Joist entities have an easy way of doing this is, via a ",(0,a.jsx)(n.code,{children:"toJSON"})," method that takes the shape of data to create:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'// Define the shape of data to create\nexport const authorHint = {\n  id: true,\n  firstName: true,\n  books: {\n    id: true,\n    title: true,\n    reviews: ["id", "rating"],\n  },\n  customField: (a) => a.id + a.title,\n} satisfies JsonHint<Author>;\n\n// This typedef can be used in the client-side props, or to match any\n// endpoint-based respones types like for REST/OpenAPI.\nexport type AuthorPayload = JsonPayload<Author, typeof authorHint>;\n\nconst payload = await a.toJSON(authorHint);\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"toJSON"})," implementation will:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Load any relations that are not yet loaded from the database"}),"\n",(0,a.jsxs)(n.li,{children:["Output only the keys that are requested in the ",(0,a.jsx)(n.code,{children:"authorHint"})]}),"\n",(0,a.jsxs)(n.li,{children:["Call any lambdas like ",(0,a.jsx)(n.code,{children:"customField"})," to generate custom values"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"As with previous examples, all data loading is N+1 safe, and also potentially join-based preloaded."}),"\n",(0,a.jsxs)(n.p,{children:["See the ",(0,a.jsx)(n.a,{href:"/docs/advanced/json-payloads",children:"toJSON"})," docs for more information."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["This recursive ",(0,a.jsx)(n.code,{children:"toJSON"})," payload generation is a relatively new feature of Joist, so if you have feature ideas that would make it more useful, please let us know!"]})}),"\n",(0,a.jsx)(n.h2,{id:"join-based-preloading",children:"Join-Based Preloading"}),"\n",(0,a.jsx)(n.p,{children:"The last optimization that Joist can do is join-based preloading, which can be used in either the RSC or RCC approach."}),"\n",(0,a.jsxs)(n.p,{children:["This is also a newer feature that requires opt-ing in to, but in ",(0,a.jsx)(n.code,{children:"em.ts"})," you can add a ",(0,a.jsx)(n.code,{children:"preloadPlugin"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"/** Returns this request's `EntityManager` instance. */\nexport const getEm = cache(() => {\n  // Opt-in to preloading\n  const preloadPlugin = new JsonAggregatePreloader();\n  return new EntityManager({}, { driver, preloadPlugin });\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"This will allow Joist to load a deep tree/subgraph of entities in a single SQL call."}),"\n",(0,a.jsxs)(n.p,{children:["For example, normally a Joist ",(0,a.jsx)(n.code,{children:"em.find"})," a call like:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:'const a = await em.find(\n  Author,\n  { id: 1 },\n  {populate: { books: "reviews" } },\n);\n// Now access all the data in memory\nconsole.log(a.books.get[0].reviews.get[0].rating)\n'})}),"\n",(0,a.jsx)(n.p,{children:"Will issue three SQL calls:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"SELECT * FROM authors WHERE id = 1;\nSELECT * FROM books WHERE author_id = 1;\nSELECT * FROM reviews WHERE book_id IN (1, 2, 3, ...);\n"})}),"\n",(0,a.jsxs)(n.p,{children:["But with the ",(0,a.jsx)(n.code,{children:"preloadPlugin"})," enabled, it will use a single SQL call that uses ",(0,a.jsx)(n.code,{children:"CROSS JOIN LATERAL"})," and ",(0,a.jsx)(n.code,{children:"json_agg"})," to return the author's books, and the book's reviews (omitted for brevity) in a single row:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-sql",children:"select a.id, _b._ as _b from authors as a\n  cross join lateral\n    -- create a tuple for each book, and aggregate then into an array of books\n    select json_agg(json_build_array(_b.id, _b.title, _b.foreword, _b.author_id) order by _b.id) as _\n    from books _b\n    where _b.author_id = a.id\n  ) _b\n  where a.id = ? limit ?\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"Joist's join-based preloading is still a beta feature, so if you run into any issues, please let us know!"})}),"\n",(0,a.jsx)(n.h2,{id:"what-about-complex-queries",children:"What about Complex Queries?"}),"\n",(0,a.jsx)(n.p,{children:'So far, our queries have focused on loading "just entities", and then putting those on the wire (or rendering them to HTML).'}),"\n",(0,a.jsxs)(n.p,{children:["This is because Joist's focus is on building robust domain models, and specifically helping solve the \"write-side\" of your application's business logic (running the correct ",(0,a.jsx)(n.a,{href:"/docs/modeling/validation-rules",children:"validation rules"}),", ",(0,a.jsx)(n.a,{href:"/docs/modeling/lifecycle-hooks",children:"lifecycle hooks"}),", ",(0,a.jsx)(n.a,{href:"/docs/modeling/reactive-fields",children:"reactive updates"}),'), and less so on the "read-side" of complex queries (i.e. that using aggregates using ',(0,a.jsx)(n.code,{children:"GROUP BY"}),", multiple nested subqueries/projections/etc.)."]}),"\n",(0,a.jsx)(n.p,{children:"As such, Joist does not yet have a sophisticated query builder that can create arbitrary SQL queries, like Kysley or Drizzle."}),"\n",(0,a.jsxs)(n.p,{children:['Instead, Joist encourages an approach that uses its robust write-side features to create materialized columns in the database, such that the majority of your pages/responses really can be served by "super simple ',(0,a.jsx)(n.code,{children:"SELECT"}),' statements", instead of using complicated queries to calculate aggregates on-the-fly.']}),"\n",(0,a.jsx)(n.p,{children:"Although you can of course use both approaches, and just use a lower-level query builder where needed."}),"\n",(0,a.jsx)(n.h2,{id:"sample-app-feedback",children:"Sample App Feedback"}),"\n",(0,a.jsx)(n.p,{children:"Joist's roots come from the GraphQL world, so this sample app was our first foray into using it for a NextJS application. If we've missed any key features that would make it easier to use Joist in a NextJS app, please let us know!"})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>i});var a=t(7378);const o={},s=a.createContext(o);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);