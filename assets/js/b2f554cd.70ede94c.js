"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1477],{4556:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"nextjs-sample-app","metadata":{"permalink":"/blog/nextjs-sample-app","source":"@site/blog/2024-04-21-nextjs-sample.md","title":"New NextJS Sample App","description":"We\'ve added a new NextJS sample app to the Joist repository.","date":"2024-04-21T00:00:00.000Z","tags":[],"readingTime":6.67,"hasTruncateMarker":false,"authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"frontMatter":{"title":"New NextJS Sample App","description":"We\'ve added a new NextJS sample app to the Joist repository.","slug":"nextjs-sample-app","authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"tags":[]},"unlisted":false,"nextItem":{"title":"Welcome","permalink":"/blog/welcome-blog"}},"content":"We\'ve added a new [NextJS + Joist](https://github.com/joist-orm/joist-nextjs-sample/) sample app that shows how Joist can be used in a NextJS application, with several benefits:\\n\\n- Automatic N+1 Prevention\\n- JSON Payload/Props Creation\\n- Optional Join-based Preloading\\n\\nThis post gives a short overview; if you\'d like to watch a video, we also have a [YouTube video](https://youtu.be/H_qJdKUS9D0) that walks through the sample app.\\n\\n<div style={{ display: \'grid\', placeItems: \'center\' }}>\\n  <iframe width=\\"750\\" height=\\"420\\" src=\\"https://www.youtube.com/embed/H_qJdKUS9D0?si=qUiRr0GTMrQCgayC\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" referrerpolicy=\\"strict-origin-when-cross-origin\\" allowfullscreen></iframe>\\n</div>\\n\\n## Two Render Tree Approaches\\n\\nWhile building the sample app, we found two fundamental ways of structuring a NextJS app\'s render tree:\\n\\n1. Fewer React Server Components, that prop drill data to the Client Components\\n   - Shown on the left, see `author-rcc-card.tsx` and `book-rcc-preview.tsx`\\n2. Mostly React Server Components, with Client Components only at the bottom\\n   - Shown on the right, see `author-rsc-card.tsx` and `book-rsc-preview.tsx`\\n\\n<div style={{ padding: \'24px\' }}>\\n  <img src=\\"/images/nextjs-sample-single-multiple-rscs.png\\" />\\n</div>\\n\\nThe top-level `Table` / `table.tsx` component renders each of these side-by-side, so we can see the differences, and observe some pros/cons of each approach.\\n\\n- With mostly RSC components, it\'s easy to decompose data loading away from the top-level component.\\n\\n  For example, the `AuthorRscCard` can make its own data loading calls, and even if it\'s render many pages on the page, Joist will de-dupe across the `N` sibling `AuthorRscCard`s, and batch into a single SQL call.\\n\\n  ```tsx\\n  type AuthorCardProps = {\\n    /** RSCs can accept the domain model enities as a prop. */\\n    author: Author;\\n    addBook: (id: string) => Promise<void>;\\n  };\\n\\n  /** The RSC version of AuthorCard can load it\'s own data. */\\n  export async function AuthorRscCard({ author, addBook }: AuthorCardProps) {\\n    // This will be auto-batched if many cards render at once\\n    const books = await author.books.load();\\n    // Or if you wanted a tree of data, this will also be auto-batched\\n    const loaded = await author.populate({ books: { reviews: \\"ratings\\" } });\\n    return <div>...jsx</div>;\\n  }\\n  ```\\n\\n  This is nice because it allows the `AuthorRscCard` to be more self-sufficient, and allow the parent table component to be unaware of its children loading details.\\n\\n- With mostly Client components, the opposite happens, and only the parent can make database / `EntityManager` calls, and so is responsible for loading all the data for its children, and passing it as JSON via props:\\n\\n  ```tsx\\n  type AuthorCardProps = {\\n    /** RCCs must accept a POJO of `Author` + all nested data. */\\n    author: AuthorPayload;\\n    addBook: (id: string) => Promise<void>;\\n  };\\n\\n  /** The RCC version of AuthorCard accepts the `AuthorPayload`. */\\n  export function AuthorRccCard({ author, addBook }: AuthorCardProps) {\\n    // can only use data already available on `author` \\n  }\\n  ```\\n\\n  Even though the up-front data load can become awkward, it does give more opportunities for optimizations; for example Joist can use join-based preloading to load a single tree of `Author` + `Book` + `Review` entities in a single SQL call, which is even better optimization than the \\"one query per layer\\" N+1 prevention of the RSC-based approach.\\n\\n## Automatic N+1 Prevention\\n\\nIn either approach, Joist\'s N+1 prevention auto-batches database calls, even if they are made across separate component renders. I.e. in the RSC components:\\n\\n- The top-level `Table` component makes 1 SQL call for all `Author` entities.\\n- All 2nd-level `AuthorRscCard` cards each make their own `author.books.load()` (or `author.populate(...)`) call, but because they\'re all rendered in the same event loop, Joist batches all the `load` calls into 1 SQL call\\n- Any 3rd-level components would have their `load` calls batched as well.\\n\\nIn the React Client Component approach, this auto-batching is admittedly not as necessary, assuming a singular top-level component, like `Table`, loads all the data at once anyway (although, as mentioned later, Joist can optimize that as well).\\n\\nSee the [Avoiding N+1s](/docs/goals/avoiding-n-plus-1s) section of our docs for more information.\\n\\n## JSON Payload/Props Creation\\n\\nSince the client components cannot make their own async data calls, the top-level `Table` components is responsible for loading all the data into a JSON payload, and passing it down to the children as props.\\n\\nJoist entities have an easy way of doing this is, via a `toJSON` method that takes the shape of data to create:\\n\\n```ts\\n// Define the shape of data to create\\nexport const authorHint = {\\n  id: true,\\n  firstName: true,\\n  books: {\\n    id: true,\\n    title: true,\\n    reviews: [\\"id\\", \\"rating\\"],\\n  },\\n  customField: (a) => a.id + a.title,\\n} satisfies JsonHint<Author>;\\n\\n// This typedef can be used in the client-side props, or to match any\\n// endpoint-based respones types like for REST/OpenAPI.\\nexport type AuthorPayload = JsonPayload<Author, typeof authorHint>;\\n\\nconst payload = await a.toJSON(authorHint);\\n```\\n\\nThe `toJSON` implementation will:\\n\\n- Load any relations that are not yet loaded from the database\\n- Output only the keys that are requested in the `authorHint`\\n- Call any lambdas like `customField` to generate custom values\\n\\nAs with previous examples, all data loading is N+1 safe, and also potentially join-based preloaded.\\n\\nSee the [toJSON](/docs/advanced/json-payloads) docs for more information.\\n\\n:::info\\n\\nThis recursive `toJSON` payload generation is a relatively new feature of Joist, so if you have feature ideas that would make it more useful, please let us know!\\n\\n:::\\n\\n## Join-Based Preloading\\n\\nThe last optimization that Joist can do is join-based preloading, which can be used in either the RSC or RCC approach.\\n\\nThis is also a newer feature that requires opt-ing in to, but in `em.ts` you can add a `preloadPlugin`:\\n\\n```ts\\n/** Returns this request\'s `EntityManager` instance. */\\nexport const getEm = cache(() => {\\n  // Opt-in to preloading\\n  const preloadPlugin = new JsonAggregatePreloader();\\n  return new EntityManager({}, { driver, preloadPlugin });\\n});\\n```\\n\\nThis will allow Joist to load a deep tree/subgraph of entities in a single SQL call.\\n\\nFor example, normally a Joist `em.find` a call like:\\n\\n```ts\\nconst a = await em.find(\\n  Author,\\n  { id: 1 },\\n  {populate: { books: \\"reviews\\" } },\\n);\\n// Now access all the data in memory\\nconsole.log(a.books.get[0].reviews.get[0].rating)\\n```\\n\\nWill issue three SQL calls:\\n\\n```sql\\nSELECT * FROM authors WHERE id = 1;\\nSELECT * FROM books WHERE author_id = 1;\\nSELECT * FROM reviews WHERE book_id IN (1, 2, 3, ...);\\n```\\n\\nBut with the `preloadPlugin` enabled, it will use a single SQL call that uses `CROSS JOIN LATERAL` and `json_agg` to return the author\'s books, and the book\'s reviews (omitted for brevity) in a single row:\\n\\n```sql\\nselect a.id, _b._ as _b from authors as a\\n  cross join lateral\\n    -- create a tuple for each book, and aggregate then into an array of books\\n    select json_agg(json_build_array(_b.id, _b.title, _b.foreword, _b.author_id) order by _b.id) as _\\n    from books _b\\n    where _b.author_id = a.id\\n  ) _b\\n  where a.id = ? limit ?\\n```\\n\\n:::info\\n\\nJoist\'s join-based preloading is still a beta feature, so if you run into any issues, please let us know!\\n\\n:::\\n\\n## What about Complex Queries?\\n\\nSo far, our queries have focused on loading \\"just entities\\", and then putting those on the wire (or rendering them to HTML).\\n\\nThis is because Joist\'s focus is on building robust domain models, and specifically helping solve the \\"write-side\\" of your application\'s business logic (running the correct [validation rules](/docs/modeling/validation-rules), [lifecycle hooks](/docs/modeling/lifecycle-hooks), [reactive updates](/docs/modeling/reactive-fields)), and less so on the \\"read-side\\" of complex queries (i.e. that using aggregates using `GROUP BY`, multiple nested subqueries/projections/etc.).\\n\\nAs such, Joist does not yet have a sophisticated query builder that can create arbitrary SQL queries, like Kysley or Drizzle.\\n\\nInstead, Joist encourages an approach that uses its robust write-side features to create materialized columns in the database, such that the majority of your pages/responses really can be served by \\"super simple `SELECT` statements\\", instead of using complicated queries to calculate aggregates on-the-fly.\\n\\nAlthough you can of course use both approaches, and just use a lower-level query builder where needed.\\n\\n## Sample App Feedback\\n\\nJoist\'s roots come from the GraphQL world, so this sample app was our first foray into using it for a NextJS application. If we\'ve missed any key features that would make it easier to use Joist in a NextJS app, please let us know!"},{"id":"welcome-blog","metadata":{"permalink":"/blog/welcome-blog","source":"@site/blog/2024-04-13-first-post.md","title":"Welcome","description":"First post on the Joist blog.","date":"2024-04-13T00:00:00.000Z","tags":[],"readingTime":0.09,"hasTruncateMarker":false,"authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"frontMatter":{"title":"Welcome","description":"First post on the Joist blog.","slug":"welcome-blog","authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"tags":[]},"unlisted":false,"prevItem":{"title":"New NextJS Sample App","permalink":"/blog/nextjs-sample-app"}},"content":"Hello! This is just a \\"Hello World\\" post to show the Joist blog, using [**Docusaurus**](https://docusaurus.io/), is working :tada:."}]}')}}]);