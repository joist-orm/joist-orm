"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[722],{8476:(e,o,a)=>{a.r(o),a.d(o,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>n,metadata:()=>l,toc:()=>c});var t=a(4246),s=a(1670);const n={title:"Load-Safe Relations",sidebar_position:3},i=void 0,l={id:"goals/load-safe-relations",title:"Load-Safe Relations",description:"Joist models all relations as async-by-default, i.e. you must access them via await calls:",source:"@site/docs/goals/load-safe-relations.md",sourceDirName:"goals",slug:"/goals/load-safe-relations",permalink:"/docs/goals/load-safe-relations",draft:!1,unlisted:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/goals/load-safe-relations.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Load-Safe Relations",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Avoiding N+1s",permalink:"/docs/goals/avoiding-n-plus-1s"},next:{title:"Great Tests",permalink:"/docs/goals/great-tests"}},r={},c=[{value:"Background",id:"background",level:2},{value:"Async By Default",id:"async-by-default",level:2},{value:"But Async is Kinda Annoying",id:"but-async-is-kinda-annoying",level:2},{value:"The Magic Escape Hatch",id:"the-magic-escape-hatch",level:2},{value:"Best of Both Worlds",id:"best-of-both-worlds",level:2}];function d(e){const o={admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(o.p,{children:["Joist models all relations as async-by-default, i.e. you must access them via ",(0,t.jsx)(o.code,{children:"await"})," calls:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:'const author = await em.load(Author, "a:1");\n// Returns the publisher if already fetched, otherwise makes a (batched) SQL call \nconst publisher = await author.publisher.load();\nconst publisherComments = await publisher.comments.load();\nconst books = await author.books.load();\n'})}),"\n",(0,t.jsx)(o.p,{children:'We call this "load safe", because you can\'t accidentally access unloaded data, which results in a runtime error.'}),"\n",(0,t.jsxs)(o.p,{children:["Which is great, but then to improve ergonomics and avoid tedious ",(0,t.jsx)(o.code,{children:"await Promise.all"})," calls, Joist also supports marking relations as explicitly loaded, to enable synchronous ",(0,t.jsx)(o.code,{children:".get"}),", non-",(0,t.jsx)(o.code,{children:"await"}),"-d access:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-ts",children:'// Preload publisher, it\'s comments, and books\nconst author = await em.load(Author, "a:1", { publisher: "comments", books: {} });\nconst publisher = author.publisher.get;\nconst publisherComments = publisher.comments.get;\nconst books = author.books.get;\n'})}),"\n",(0,t.jsx)(o.h2,{id:"background",children:"Background"}),"\n",(0,t.jsx)(o.p,{children:"One of the main affordances of ORMs is that relationships (relations) between tables in the database (i.e. foreign keys) are modelled as references & collections on the classes/entities in the domain model."}),"\n",(0,t.jsxs)(o.p,{children:["For example, in most ORMs a ",(0,t.jsx)(o.code,{children:"books.author_id"})," foreign key column means the ",(0,t.jsx)(o.code,{children:"Author"})," entity will have an ",(0,t.jsx)(o.code,{children:"author.books"})," collection (which loads all books for that author), and the ",(0,t.jsx)(o.code,{children:"Book"})," entity will have a ",(0,t.jsx)(o.code,{children:"book.author"})," reference (which loads the book's author)."]}),"\n",(0,t.jsxs)(o.p,{children:["In all ORMs, these references & collections are inherently lazy: because you don't have your entire relational database in memory, objects start out with just a single/few rows loaded (i.e. a single ",(0,t.jsx)(o.code,{children:"authors"})," row with ",(0,t.jsx)(o.code,{children:"id=1"})," loaded as an ",(0,t.jsx)(o.code,{children:"Author#1"}),' instance) and then lazily loaded the data you need from there (i.e. you "walk the object graph" from that ',(0,t.jsx)(o.code,{children:"Author#1"})," to the related data you need)."]}),"\n",(0,t.jsx)(o.h2,{id:"async-by-default",children:"Async By Default"}),"\n",(0,t.jsxs)(o.p,{children:["Because of the inherently lazy nature of references & collections, Joist takes the strong, type-safe opinion that if they ",(0,t.jsx)(o.em,{children:"might"})," be unloaded, then they ",(0,t.jsx)(o.em,{children:"must"})," be marked as ",(0,t.jsx)(o.code,{children:"async/await"}),"."]}),"\n",(0,t.jsxs)(o.p,{children:["For example, you have to access ",(0,t.jsx)(o.code,{children:"author.books"})," via an ",(0,t.jsx)(o.code,{children:"await"}),"-d promise:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-typescript",children:'const author = await em.load(Author, "a:1");\nconst books = await author.books.load();\n'})}),"\n",(0,t.jsxs)(o.p,{children:['And you must do this each time, even if technically in the code path that you\'re in, you "know" that ',(0,t.jsx)(o.code,{children:"books"})," has already been loaded, i.e.:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-typescript",children:'const author = await em.load(Author, "a:1");\n// Call another method that happens to loads books\nsomeComplicatedLogicThatLoadsBooks(author);\n// You still can\'t do `books.get`, even though "we know" (but the compiler\n// does not know) that the collection is technically already cached in-memory\nconst books = await author.books.load();\n'})}),"\n",(0,t.jsx)(o.h2,{id:"but-async-is-kinda-annoying",children:"But Async is Kinda Annoying"}),"\n",(0,t.jsxs)(o.p,{children:['While Joist\'s "async by default" approach is the safest, it is admittedly tedious when you get to double/triple levels of ',(0,t.jsx)(o.code,{children:"await"}),"s, i.e. to go from an ",(0,t.jsx)(o.code,{children:"Author"})," to their ",(0,t.jsx)(o.code,{children:"Book"}),"s to each ",(0,t.jsx)(o.code,{children:"Book"}),"'s ",(0,t.jsx)(o.code,{children:"BookReview"}),"s:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-typescript",children:'const author = await em.load(Author, "a:1");\nawait Promise.all((await author.books.load()).map(async (book) => {\n  // For each book load the reviews\n  return Promise.all((await book.reviews.load()).map(async (review) => {\n    console.log(review.name);\n  })); \n}));\n'})}),"\n",(0,t.jsx)(o.p,{children:"Yuck."}),"\n",(0,t.jsxs)(o.p,{children:['Given this complication, some ORMs in the JavaScript/TypeScript space sometimes fudge the "collections must be async" approach, and allow you to model collections as ',(0,t.jsx)(o.em,{children:"synchronous"}),", i.e. you're allowed to do:"]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-typescript",children:'const author = await em.load(Author, "a:1");\n// I promise I loaded books\nawait author.books.load();\n// Now access it w/o promises\nauthor.books.get.length;\n'})}),"\n",(0,t.jsxs)(o.p,{children:["Which is nice! But the wrinkle is that we're now trusting ourselves to only access ",(0,t.jsx)(o.code,{children:"books"})," ",(0,t.jsx)(o.em,{children:"after"})," an explicit ",(0,t.jsx)(o.code,{children:"load"}),", and if we forget, i.e. when our code paths end up being complex enough that it's hard to tell, then we'll get a runtime error that ",(0,t.jsx)(o.code,{children:"books.get"})," is not allowed to be called"]}),"\n",(0,t.jsx)(o.p,{children:"Because of this lack of safety, Joist avoids this approach, and instead has something fancier."}),"\n",(0,t.jsx)(o.h2,{id:"the-magic-escape-hatch",children:"The Magic Escape Hatch"}),"\n",(0,t.jsx)(o.p,{children:"Ideally what we want is to have relations lazy-by-default, except when we've explicitly told TypeScript that we've loaded them. This is what Joist does."}),"\n",(0,t.jsxs)(o.p,{children:["In Joist, populate hints (which tell the ORM to pre-fetch data before it's actually accessed) also ",(0,t.jsx)(o.em,{children:"change the type of the entity"}),", and mark relations that were explicitly listed in the hint as loaded."]}),"\n",(0,t.jsx)(o.p,{children:"This looks like:"}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-typescript",children:'const book = await em.populate(\n  originalBook,\n  // Tell Joist we want `{ author: "publisher" } preloaded\n  { author: "publisher" });\n// The `populate` return type is now "special"/MarkLoaded `Book`\n// that has `author` and `publisher` marked as "get"-able\nexpect(book.author.get.firstName).toEqual("a1");\nexpect(book.author.get.publisher.get.name).toEqual("p1");\n'})}),"\n",(0,t.jsxs)(o.p,{children:["Note that ",(0,t.jsx)(o.code,{children:"originalBook"}),"'s ",(0,t.jsx)(o.code,{children:"originalBook.author"})," reference does ",(0,t.jsx)(o.em,{children:"not"})," have ",(0,t.jsx)(o.code,{children:".get"})," available (just the safe ",(0,t.jsx)(o.code,{children:".load"})," which returns a ",(0,t.jsx)(o.code,{children:"Promise"}),"); only the modified ",(0,t.jsx)(o.code,{children:"Book"})," type returned from ",(0,t.jsx)(o.code,{children:"em.populate"})," has the ",(0,t.jsx)(o.code,{children:".get"})," method added ",(0,t.jsx)(o.code,{children:"author.book"}),"."]}),"\n",(0,t.jsxs)(o.admonition,{type:"tip",children:[(0,t.jsxs)(o.p,{children:["You can avoid having two ",(0,t.jsx)(o.code,{children:"originalBook"})," / ",(0,t.jsx)(o.code,{children:"book"})," variables by passing populate hints directly to ",(0,t.jsx)(o.code,{children:"EntityManager.load"}),", which will then return the appropriate ",(0,t.jsx)(o.code,{children:".get"}),"-able references:"]}),(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-typescript",children:'const book = await em.load(\n  Book,\n  "a:1",\n  { author: "publisher" });\nexpect(book.author.get.firstName).toEqual("a1");\nexpect(book.author.get.publisher.get.name).toEqual("p1");\n'})})]}),"\n",(0,t.jsxs)(o.p,{children:["Joist's ",(0,t.jsx)(o.code,{children:"populate"})," approach also works for multiple levels, i.e. our triple-nested ",(0,t.jsx)(o.code,{children:"Promise.all"}),"-hell example can be written with a single ",(0,t.jsx)(o.code,{children:"await"})]}),"\n",(0,t.jsx)(o.pre,{children:(0,t.jsx)(o.code,{className:"language-typescript",children:'const author = await em.load(\n  Author,\n  "a:1",\n  { books: "reviews" },\n);\nauthor.books.get.forEach((book) => {\n  book.reviews.get.forEach((review) => {\n    console.log(review.name);\n  });\n})\n'})}),"\n",(0,t.jsx)(o.h2,{id:"best-of-both-worlds",children:"Best of Both Worlds"}),"\n",(0,t.jsx)(o.p,{children:'This combination of "async by default" and "populate hint mapped types" brings the best of both worlds:'}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:["Data that we are unsure of its loaded-ness, must be ",(0,t.jsx)(o.code,{children:"await"}),"-d, while"]}),"\n",(0,t.jsx)(o.li,{children:"Data that we (and, more importantly, the TypeScript compiler) are sure of its loaded-ness, can be accessed synchronously"}),"\n"]})]})}function h(e={}){const{wrapper:o}={...(0,s.a)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1670:(e,o,a)=>{a.d(o,{Z:()=>l,a:()=>i});var t=a(7378);const s={},n=t.createContext(s);function i(e){const o=t.useContext(n);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function l(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),t.createElement(n.Provider,{value:o},e.children)}}}]);