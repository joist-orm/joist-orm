"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[365],{162:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var t=n(2540),i=n(3023);const o={title:"Schema Assumptions",sidebar_position:1},a=void 0,r={id:"getting-started/schema-assumptions",title:"Schema Assumptions",description:"Joist makes a few assumptions about your database schema, which basically assume you have a modern/pleasant database schema that you want directly mapped to your TypeScript domain model.",source:"@site/docs/getting-started/schema-assumptions.md",sourceDirName:"getting-started",slug:"/getting-started/schema-assumptions",permalink:"/docs/getting-started/schema-assumptions",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/getting-started/schema-assumptions.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Schema Assumptions",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Installation",permalink:"/docs/getting-started"},next:{title:"Configuration",permalink:"/docs/configuration"}},d={},l=[{value:"Entity Tables",id:"entity-tables",level:2},{value:"Deferred Constraints (Recommended)",id:"deferred-constraints-recommended",level:2},{value:"Timestamp Columns",id:"timestamp-columns",level:2},{value:"Enum Tables",id:"enum-tables",level:2},{value:"Many-to-Many Join Tables",id:"many-to-many-join-tables",level:2}];function c(e){const s={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.p,{children:"Joist makes a few assumptions about your database schema, which basically assume you have a modern/pleasant database schema that you want directly mapped to your TypeScript domain model."}),"\n",(0,t.jsx)(s.h2,{id:"entity-tables",children:"Entity Tables"}),"\n",(0,t.jsxs)(s.p,{children:["Joist requires entity tables (i.e. ",(0,t.jsx)(s.code,{children:"authors"}),", ",(0,t.jsx)(s.code,{children:"books"}),") to have a single primary key column, ",(0,t.jsx)(s.code,{children:"id"}),", that is either:"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["An ",(0,t.jsx)(s.code,{children:"id"}),", ",(0,t.jsx)(s.code,{children:"serial"}),", ",(0,t.jsx)(s.code,{children:"int"}),", or ",(0,t.jsx)(s.code,{children:"bigint"})," type, that uses a sequence called ",(0,t.jsx)(s.code,{children:"${tableName}_id_seq"}),", or"]}),"\n",(0,t.jsxs)(s.li,{children:["An ",(0,t.jsx)(s.code,{children:"uuid"})," type"]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"And that is it; you can:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["Use either singular or plural table names (",(0,t.jsx)(s.code,{children:"author"})," or ",(0,t.jsx)(s.code,{children:"authors"}),")"]}),"\n",(0,t.jsxs)(s.li,{children:["Use either underscore or camel cased column names (",(0,t.jsx)(s.code,{children:"first_name"})," or ",(0,t.jsx)(s.code,{children:"firstName"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["If you use plural table names, Joist will de-pluralize them for the entity name, e.g. ",(0,t.jsx)(s.code,{children:"authors"})," -> ",(0,t.jsx)(s.code,{children:"Author"}),"."]}),"\n",(0,t.jsx)(s.admonition,{type:"info",children:(0,t.jsxs)(s.p,{children:["We have added Postgres data types to Joist only as we've personally needed them; if you use a data type that Joist doesn't support yet, you'll get an error when running ",(0,t.jsx)(s.code,{children:"joist-codegen"}),", but please just open an issue or PR, and we'll be happy to look in to it."]})}),"\n",(0,t.jsx)(s.h2,{id:"deferred-constraints-recommended",children:"Deferred Constraints (Recommended)"}),"\n",(0,t.jsxs)(s.p,{children:["Joist automatically batches all ",(0,t.jsx)(s.code,{children:"INSERT"}),"s and ",(0,t.jsx)(s.code,{children:"UPDATE"}),"s within an ",(0,t.jsx)(s.code,{children:"EntityManager.flush"}),", which results in the best performance, but means that foreign keys might be temporarily invalid (i.e. we've inserted a ",(0,t.jsx)(s.code,{children:"Book"})," with an ",(0,t.jsx)(s.code,{children:"author_id"})," before the ",(0,t.jsx)(s.code,{children:"Author"})," is inserted)."]}),"\n",(0,t.jsxs)(s.p,{children:["The cleanest way to handle this, is by telling Postgres to ",(0,t.jsx)(s.em,{children:"temporarily"})," defer foreign key checks until the end of the transaction."]}),"\n",(0,t.jsx)(s.p,{children:"To enable this, foreign keys must be created with this syntax:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-sql",children:'CREATE TABLE "authors" (\n  "publisher_id" integer REFERENCES "publishers" DEFERRABLE INITIALLY DEFERRED,\n);\n'})}),"\n",(0,t.jsxs)(s.p,{children:["If you're using node-pg-migrate, Joist's ",(0,t.jsx)(s.code,{children:"joist-migration-utils"})," package has utility methods, i.e. ",(0,t.jsx)(s.code,{children:"createEntityTable"})," and ",(0,t.jsx)(s.code,{children:"foreignKey"}),", to apply these defaults for you, but you should be able to do the same in any migration library."]}),"\n",(0,t.jsxs)(s.p,{children:["The first time you run ",(0,t.jsx)(s.code,{children:"joist-codegen"}),", Joist will output any foreign keys it finds that are not deferred, and create an ",(0,t.jsx)(s.code,{children:"alter-foreign-keys.sql"})," file you can apply to convert them over."]}),"\n",(0,t.jsxs)(s.p,{children:["That said, this is ",(0,t.jsx)(s.em,{children:"optional"}),"; if you don't want to use deferred foreign keys, you can set ",(0,t.jsx)(s.code,{children:'nonDeferredForeignKeys: "ignore"'})," in your ",(0,t.jsx)(s.code,{children:"joist-config.json"}),", and Joist will stop outputting this warning."]}),"\n",(0,t.jsxs)(s.admonition,{type:"info",children:[(0,t.jsxs)(s.p,{children:["One scenario where deferred keys are required is if you have ",(0,t.jsx)(s.code,{children:"NOT NULL"})," cycles in your schema."]}),(0,t.jsxs)(s.p,{children:["An example is having ",(0,t.jsx)(s.code,{children:"authors.favorite_book_id"})," and ",(0,t.jsx)(s.code,{children:"books.author_id"}),", both of which are ",(0,t.jsx)(s.code,{children:"NOT NULL"}),"."]}),(0,t.jsxs)(s.p,{children:["When creating an ",(0,t.jsx)(s.code,{children:"Author"})," and a ",(0,t.jsx)(s.code,{children:"Book"}),', there is no way for Joist to "choose which one goes first", and so in this scenario you must either make one of the FKs nullable (i.e. the ',(0,t.jsx)(s.code,{children:"authors.favorite_book_id"}),", in which case Joist will insert the ",(0,t.jsx)(s.code,{children:"Author"})," first), or make one of the FKs deferred."]})]}),"\n",(0,t.jsx)(s.h2,{id:"timestamp-columns",children:"Timestamp Columns"}),"\n",(0,t.jsxs)(s.p,{children:["Entity tables can optionally have ",(0,t.jsx)(s.code,{children:"created_at"})," and ",(0,t.jsx)(s.code,{children:"updated_at"})," columns, which Joist will automatically manage by setting ",(0,t.jsx)(s.code,{children:"created_at"})," when creating entities, and updating ",(0,t.jsx)(s.code,{children:"updated_at"})," when updating entities."]}),"\n",(0,t.jsxs)(s.p,{children:["In ",(0,t.jsx)(s.code,{children:"joist-config.json"}),", you can configure the names of the ",(0,t.jsx)(s.code,{children:"timestampColumns"}),", which defaults to:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-json",children:'{\n  "timestampColumns": {\n    "createdAt": { "names": ["created_at", "createdAt"], "required": false },\n    "updatedAt": { "names": ["updated_at", "updatedAt"], "required": false }\n  }\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["For example, if you want to strictly require ",(0,t.jsx)(s.code,{children:"created_at"})," and ",(0,t.jsx)(s.code,{children:"updated_at"})," on all entities in your application's schema, you can use:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-json",children:'{\n  "timestampColumns": {\n    "createdAt": { "names": ["created_at"], "required": true },\n    "updatedAt": { "names": ["updated_at"], "required": true }\n  }\n}\n'})}),"\n",(0,t.jsxs)(s.admonition,{type:"tip",children:[(0,t.jsxs)(s.p,{children:["If you have non-Joist clients that update entities tables, or use bulk/raw SQL updates, you can create triggers that mimic this functionality (but will not overwrite ",(0,t.jsx)(s.code,{children:"INSERT"}),"s / ",(0,t.jsx)(s.code,{children:"UPDATE"}),"s that do set the columns), see ",(0,t.jsx)(s.a,{href:"https://github.com/joist-orm/joist-orm/blob/main/packages/migration-utils/src/utils.ts#L73",children:"joist-migration-utils"}),"."]}),(0,t.jsxs)(s.p,{children:["(These methods use ",(0,t.jsx)(s.code,{children:"node-pg-migrate"}),", but you can use whatever migration library you prefer to apply the DDL.)"]})]}),"\n",(0,t.jsx)(s.h2,{id:"enum-tables",children:"Enum Tables"}),"\n",(0,t.jsxs)(s.p,{children:["Joist models enums (i.e. ",(0,t.jsx)(s.code,{children:"EmployeeStatus"}),") as their own database tables with a row-per-enum value."]}),"\n",(0,t.jsxs)(s.p,{children:["For example, ",(0,t.jsx)(s.code,{children:"employee_status"})," might have two rows like:"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{children:"id  | code          | name\n----+---------------+---------------\n1   | FULL_TIME     | Full Time\n2   | PART_TIME     | Part Time\n"})}),"\n",(0,t.jsx)(s.p,{children:"And Joist will generate code that looks like:"}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-typescript",children:"enum EmployeeStatus {\n  FullTime,\n  PartTime,\n}\n"})}),"\n",(0,t.jsxs)(s.p,{children:['This "enums-as-tables" approach allows the entities reference to the enum, i.e. ',(0,t.jsx)(s.code,{children:"Employee.status"})," pointing to the ",(0,t.jsx)(s.code,{children:"EmployeeStatus"})," enum, to use foreign keys to the enum table, i.e. ",(0,t.jsx)(s.code,{children:"employees.status_id"})," is a foreign key to the ",(0,t.jsx)(s.code,{children:"employee_status"})," table. This enables:"]}),"\n",(0,t.jsxs)(s.ol,{children:["\n",(0,t.jsxs)(s.li,{children:["Data integrity, ensuring that all ",(0,t.jsx)(s.code,{children:"status_id"})," values are valid statuses, and"]}),"\n",(0,t.jsxs)(s.li,{children:["Allows Joist's code generator to tell both that ",(0,t.jsx)(s.code,{children:"employees.status_id"})," is a) of the type ",(0,t.jsx)(s.code,{children:"EmployeeStatus"})," and b) how many enum values ",(0,t.jsx)(s.code,{children:"EmployeeStatus"})," has."]}),"\n"]}),"\n",(0,t.jsx)(s.p,{children:"Joist expects enum tables to have three columns:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"id"})," primary key/serial"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"code"})," i.e. ",(0,t.jsx)(s.code,{children:"FOO_BAR"})]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"name"})," i.e. ",(0,t.jsx)(s.code,{children:"Foo Bar"})]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"joist-migration-utils"})," package has ",(0,t.jsx)(s.code,{children:"createEnumTable"}),", ",(0,t.jsx)(s.code,{children:"addEnumValue"}),", and ",(0,t.jsx)(s.code,{children:"updateEnumValue"})," helper methods to use in your migrations."]}),"\n",(0,t.jsx)(s.p,{children:"And, as mentioned, entities that want to use this enum should have a foreign key that references the appropriate enum table."}),"\n",(0,t.jsx)(s.p,{children:"If you do not wish to use enums as tables, native enums can be used as well, and Joist will generate the Typescript enum."}),"\n",(0,t.jsx)(s.h2,{id:"many-to-many-join-tables",children:"Many-to-Many Join Tables"}),"\n",(0,t.jsx)(s.p,{children:"Joist expects join tables to have three or four columns:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"id"})," primary key/serial"]}),"\n",(0,t.jsx)(s.li,{children:"One foreign key column for 1st side"}),"\n",(0,t.jsx)(s.li,{children:"One foreign key column for 2nd side"}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"created_at"})," ",(0,t.jsx)(s.code,{children:"timestamptz"})," (optional)"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["(",(0,t.jsx)(s.code,{children:"updated_at"})," is not applicable to join tables.)"]})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},3023:(e,s,n)=>{n.d(s,{R:()=>a,x:()=>r});var t=n(3696);const i={},o=t.createContext(i);function a(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function r(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);