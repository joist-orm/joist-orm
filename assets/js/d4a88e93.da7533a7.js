"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[42],{6683:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var t=s(4246),i=s(1670);const a={title:"Schema Assumptions",sidebar_position:1},o=void 0,r={id:"getting-started/schema-assumptions",title:"Schema Assumptions",description:"Joist makes a few assumptions about your database schema, which basically assume you have a modern/pleasant database schema that you want directly mapped to your TypeScript domain model.",source:"@site/docs/getting-started/schema-assumptions.md",sourceDirName:"getting-started",slug:"/getting-started/schema-assumptions",permalink:"/docs/getting-started/schema-assumptions",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/getting-started/schema-assumptions.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Schema Assumptions",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Installation",permalink:"/docs/getting-started"},next:{title:"Configuration",permalink:"/docs/configuration"}},d={},l=[{value:"Entity Tables",id:"entity-tables",level:2},{value:"Deferred Constraints",id:"deferred-constraints",level:3},{value:"Timestamp Columns",id:"timestamp-columns",level:3},{value:"Enum Tables",id:"enum-tables",level:2},{value:"Many-to-Many Join Tables",id:"many-to-many-join-tables",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Joist makes a few assumptions about your database schema, which basically assume you have a modern/pleasant database schema that you want directly mapped to your TypeScript domain model."}),"\n",(0,t.jsx)(n.h2,{id:"entity-tables",children:"Entity Tables"}),"\n",(0,t.jsxs)(n.p,{children:["Joist expects entity tables (i.e. ",(0,t.jsx)(n.code,{children:"authors"}),", ",(0,t.jsx)(n.code,{children:"books"}),") to have a single primary key column, ",(0,t.jsx)(n.code,{children:"id"}),", that is either:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"id"})," / ",(0,t.jsx)(n.code,{children:"serial"})," type, that uses a sequence called ",(0,t.jsx)(n.code,{children:"${tableName}_id_seq"}),", or"]}),"\n",(0,t.jsxs)(n.li,{children:["A ",(0,t.jsx)(n.code,{children:"uuid"})," type"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"And that is it; you can:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use either singular or plural table names (",(0,t.jsx)(n.code,{children:"author"})," or ",(0,t.jsx)(n.code,{children:"authors"}),")"]}),"\n",(0,t.jsxs)(n.li,{children:["Use either underscore or camel cased column names (",(0,t.jsx)(n.code,{children:"first_name"})," or ",(0,t.jsx)(n.code,{children:"firstName"}),")"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["If you use plural table names, Joist will de-pluralize them for the entity name, e.g. ",(0,t.jsx)(n.code,{children:"authors"})," -> ",(0,t.jsx)(n.code,{children:"Author"}),"."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.p,{children:["We have added Postgres data types to Joist only as we've personally needed them; if you use a data type that Joist doesn't support yet, you'll get an error when running ",(0,t.jsx)(n.code,{children:"joist-codegen"}),", but please just open an issue or PR, and we'll be happy to look in to it."]})}),"\n",(0,t.jsx)(n.h3,{id:"deferred-constraints",children:"Deferred Constraints"}),"\n",(0,t.jsxs)(n.p,{children:["Joist batches all ",(0,t.jsx)(n.code,{children:"INSERT"}),"s and ",(0,t.jsx)(n.code,{children:"UPDATE"}),"s within an ",(0,t.jsx)(n.code,{children:"EntityManager.flush"}),", which results in the best performance, but means that foreign keys might be temporarily invalid (i.e. we've inserted a ",(0,t.jsx)(n.code,{children:"Book"})," with an ",(0,t.jsx)(n.code,{children:"author_id"})," before the ",(0,t.jsx)(n.code,{children:"Author"})," is inserted)."]}),"\n",(0,t.jsxs)(n.p,{children:["Joist handles this by telling Postgres to ",(0,t.jsx)(n.em,{children:"temporarily"})," defer foreign key checks until the end of the transaction."]}),"\n",(0,t.jsx)(n.p,{children:"To enable this, foreign keys must be created with this syntax:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sql",children:'CREATE TABLE "authors" (\n  ...\n  "publisher_id" integer REFERENCES "publishers" DEFERRABLE INITIALLY DEFERRED,\n  ...\n);\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If you're using node-pg-migrate for your migrations, Joist's ",(0,t.jsx)(n.code,{children:"joist-migration-utils"})," NPM package has utility methods, i.e. ",(0,t.jsx)(n.code,{children:"createEntityTable"})," and ",(0,t.jsx)(n.code,{children:"foreignKey"}),", to apply these defaults for you, but you should be able to do the same in any migration library."]}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:["As a longer example explaining the nuance of insertion order, given ",(0,t.jsx)(n.code,{children:"Publisher"}),"/",(0,t.jsx)(n.code,{children:"Author"})," entities, if deferred FK constraints are not used then:"]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Sometimes ",(0,t.jsx)(n.code,{children:"Publisher"})," needs flushed first to satisfy an ",(0,t.jsx)(n.code,{children:"authors.publisher_id"})," foreign key constraint, but"]}),"\n",(0,t.jsxs)(n.li,{children:["Other times ",(0,t.jsx)(n.code,{children:"Author"})," needs flushed first to satisfy a ",(0,t.jsx)(n.code,{children:"publishers.top_author_id"})," foreign key constraint."]}),"\n",(0,t.jsxs)(n.li,{children:["Or, even trickier, if mixing ",(0,t.jsx)(n.code,{children:"authors"})," and ",(0,t.jsx)(n.code,{children:"publishers"})," ",(0,t.jsx)(n.code,{children:"INSERT"}),"s and ",(0,t.jsx)(n.code,{children:"DELETE"}),"s in the same transaction: should we delete authors then insert publishers, or delete publishers then insert authors, etc."]}),"\n"]}),(0,t.jsx)(n.p,{children:"Using deferred constraints makes this complexity & non-deterministic insertion order go away."})]}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["If you have an existing schema, and need to convert your existing foreign keys to deferrable, you can use ",(0,t.jsx)(n.a,{href:"https://www.pg-structure.com/",children:"pg-structure"})," in a migration to loop over them like:"]}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'import pgStructure from "pg-structure";\n\nconst client = getYourDbClient();\nconst db = await pgStructure(client, { includeSchemas: "public" });\nfor (const table of db.tables) {\n  for (const constraint of table.constraints) {\n    if (constraint instanceof ForeignKey) {\n      await b.db.query(`\n        ALTER TABLE ${table.name}\n        ALTER CONSTRAINT ${constraint.name}\n        DEFERRABLE INITIALLY DEFERRED\n      `);\n    }\n  }\n}\n'})})]}),"\n",(0,t.jsx)(n.h3,{id:"timestamp-columns",children:"Timestamp Columns"}),"\n",(0,t.jsxs)(n.p,{children:["Entity tables can optionally have ",(0,t.jsx)(n.code,{children:"created_at"})," and ",(0,t.jsx)(n.code,{children:"updated_at"})," columns, which Joist will automatically manage by setting ",(0,t.jsx)(n.code,{children:"created_at"})," when creating entities, and updating ",(0,t.jsx)(n.code,{children:"updated_at"})," when updating entities."]}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.code,{children:"joist-config.json"}),", you can configure the names of the ",(0,t.jsx)(n.code,{children:"timestampColumns"}),", which defaults to:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "timestampColumns": {\n    "createdAt": { "names": ["created_at", "createdAt"], "required": false },\n    "updatedAt": { "names": ["updated_at", "updatedAt"], "required": false }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For example, if you want to strictly require ",(0,t.jsx)(n.code,{children:"created_at"})," and ",(0,t.jsx)(n.code,{children:"updated_at"})," on all entities in your application's schema, you can use:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n  "timestampColumns": {\n    "createdAt": { "names": ["created_at"], "required": true },\n    "updatedAt": { "names": ["updated_at"], "required": true }\n  }\n}\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"tip",children:[(0,t.jsxs)(n.p,{children:["If you have non-Joist clients that update entities tables, or use bulk/raw SQL updates, you can create triggers that mimic this functionality (but will not overwrite ",(0,t.jsx)(n.code,{children:"INSERT"}),"s / ",(0,t.jsx)(n.code,{children:"UPDATE"}),"s that do set the columns), see ",(0,t.jsx)(n.a,{href:"https://github.com/joist-orm/joist-orm/blob/main/packages/migration-utils/src/utils.ts#L73",children:"joist-migration-utils"}),"."]}),(0,t.jsxs)(n.p,{children:["(These methods use ",(0,t.jsx)(n.code,{children:"node-pg-migrate"}),", but you can use whatever migration library you prefer to apply the DDL.)"]})]}),"\n",(0,t.jsx)(n.h2,{id:"enum-tables",children:"Enum Tables"}),"\n",(0,t.jsxs)(n.p,{children:["Joist models enums (i.e. ",(0,t.jsx)(n.code,{children:"EmployeeStatus"}),") as their own database tables with a row-per-enum value."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, ",(0,t.jsx)(n.code,{children:"employee_status"})," might have two rows like:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"id  | code          | name\n----+---------------+---------------\n1   | FULL_TIME     | Full Time\n2   | PART_TIME     | Part Time\n"})}),"\n",(0,t.jsx)(n.p,{children:"And Joist will generate code that looks like:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"enum EmployeeStatus {\n  FullTime,\n  PartTime,\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:['This "enums-as-tables" approach allows the entities reference to the enum, i.e. ',(0,t.jsx)(n.code,{children:"Employee.status"})," pointing to the ",(0,t.jsx)(n.code,{children:"EmployeeStatus"})," enum, to use foreign keys to the enum table, i.e. ",(0,t.jsx)(n.code,{children:"employees.status_id"})," is a foreign key to the ",(0,t.jsx)(n.code,{children:"employee_status"})," table. This enables:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Data integrity, ensuring that all ",(0,t.jsx)(n.code,{children:"status_id"})," values are valid statuses, and"]}),"\n",(0,t.jsxs)(n.li,{children:["Allows Joist's code generator to tell both that ",(0,t.jsx)(n.code,{children:"employees.status_id"})," is a) of the type ",(0,t.jsx)(n.code,{children:"EmployeeStatus"})," and b) how many enum values ",(0,t.jsx)(n.code,{children:"EmployeeStatus"})," has."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Joist expects enum tables to have three columns:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id"})," primary key/serial"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"code"})," i.e. ",(0,t.jsx)(n.code,{children:"FOO_BAR"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"name"})," i.e. ",(0,t.jsx)(n.code,{children:"Foo Bar"})]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"joist-migration-utils"})," package has ",(0,t.jsx)(n.code,{children:"createEnumTable"}),", ",(0,t.jsx)(n.code,{children:"addEnumValue"}),", and ",(0,t.jsx)(n.code,{children:"updateEnumValue"})," helper methods to use in your migrations."]}),"\n",(0,t.jsx)(n.p,{children:"And, as mentioned, entities that want to use this enum should have a foreign key that references the appropriate enum table."}),"\n",(0,t.jsx)(n.p,{children:"If you do not wish to use enums as tables, native enums can be used as well, and Joist will generate the Typescript enum."}),"\n",(0,t.jsx)(n.h2,{id:"many-to-many-join-tables",children:"Many-to-Many Join Tables"}),"\n",(0,t.jsx)(n.p,{children:"Joist expects join tables to have three or four columns:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"id"})," primary key/serial"]}),"\n",(0,t.jsx)(n.li,{children:"One foreign key column for 1st side"}),"\n",(0,t.jsx)(n.li,{children:"One foreign key column for 2nd side"}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"created_at"})," ",(0,t.jsx)(n.code,{children:"timestamptz"})," (optional)"]}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["(",(0,t.jsx)(n.code,{children:"updated_at"})," is not applicable to join tables.)"]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},1670:(e,n,s)=>{s.d(n,{Z:()=>r,a:()=>o});var t=s(7378);const i={},a=t.createContext(i);function o(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);