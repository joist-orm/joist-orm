"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[624],{5318:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(7378);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),p=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=p(n),h=i,m=u["".concat(s,".").concat(h)]||u[h]||c[h]||o;return n?a.createElement(m,r(r({ref:t},d),{},{components:n})):a.createElement(m,r({ref:t},d))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9271:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(2685),i=(n(7378),n(5318));const o={title:"Optimistic Locking",sidebar_position:4},r=void 0,l={unversionedId:"advanced/optimistic-locking",id:"advanced/optimistic-locking",title:"Optimistic Locking",description:"Joist implements optimistic locking to avoid conflicting/dropped UPDATEs.",source:"@site/docs/advanced/optimistic-locking.md",sourceDirName:"advanced",slug:"/advanced/optimistic-locking",permalink:"/docs/advanced/optimistic-locking",draft:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/advanced/optimistic-locking.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Optimistic Locking",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Large Collections",permalink:"/docs/advanced/large-collections"},next:{title:"Lens Traversal",permalink:"/docs/advanced/lenses"}},s={},p=[{value:"How It Works",id:"how-it-works",level:3},{value:"Oplock Granularity",id:"oplock-granularity",level:3},{value:"When Will Errors Like This Happen?",id:"when-will-errors-like-this-happen",level:3},{value:"Integrating Locks with the Client",id:"integrating-locks-with-the-client",level:3}],d={toc:p};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Joist implements optimistic locking to avoid conflicting/dropped ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE"),"s."),(0,i.kt)("p",null,"Optimistic locking is a pattern where reading data (i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},'em.load(Author, "a:1")'),') does not lock data (i.e. within the database at the row level, holding a lock that prevents other transactions from reading the row until we\'re "done").'),(0,i.kt)("p",null,'Instead, optimistic locking assumes we are not going to conflict (hence the term "optimistic"), and so does not bother prematurely locking data (which would be "pessimistic locking").'),(0,i.kt)("p",null,"However, when ",(0,i.kt)("em",{parentName:"p"},"writing")," data, we check that the data has not changed since we read it."),(0,i.kt)("h3",{id:"how-it-works"},"How It Works"),(0,i.kt)("p",null,"When Joist loads data, it knows the ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at")," for every row that is read, i.e.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const author = await em.load(Author, "a:1");\nconsole.log(author.updated_at); // ...10:00am...\n')),(0,i.kt)("p",null,"Then when issuing ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE"),"s, we include the ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at")," as part of the ",(0,i.kt)("inlineCode",{parentName:"p"},"WHERE")," clause:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"UPDATE authors\n  SET\n    first_name = 'bob'\n    updated_at = '...10:01am...'\n  WHERE id = 1\n  AND updated_at = '...10:00am...'\n")),(0,i.kt)("p",null,"This ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," can have two outcomes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"UPDATE")," modifies 1 row, and we know no one else changed the data, so our write is successful."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"UPDATE")," modifies 0 rows, and we know that a different thread changed the data since we had read it, so our write was not successful, and Joist will throw an ",(0,i.kt)("inlineCode",{parentName:"li"},"Oplock failure")," error.")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The SQL in this example only updates 1 row at a time, so is pretty straight forward."),(0,i.kt)("p",{parentName:"admonition"},"The SQL that Joist generates at runtime will be more complex, because it batches all ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE"),"s for a single table together into 1 SQL call, but the effect is the same: the bulk ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE"),"s still check the individual/per-row ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at")," values.")),(0,i.kt)("h3",{id:"oplock-granularity"},"Oplock Granularity"),(0,i.kt)("p",null,"Currently, Joist's oplock granularity is at the entity/row level, because it uses the row-level ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at")," column to detect conflicts."),(0,i.kt)("p",null,"So if you have two clients that are trying to simultaneously update separate columns, i.e.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"-- thread 1, sets first name\nUPDATE authors SET first_name = 'bob'\n  WHERE id = 1 AND updated_at = '...10:00am...'\n\n-- thread 2, sets last name\nUPDATE authors SET last_name = 'smith'\n  WHERE id = 1 AND updated_at = '...10:00am...'\n")),(0,i.kt)("p",null,"These two statements will still conflict, and only 1 will win."),(0,i.kt)("p",null,"There are two interpretations of this behavior:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"That it's incorrect because each ",(0,i.kt)("inlineCode",{parentName:"li"},"UPDATE")," touched separate columns, so they should have been allowed to interleave."),(0,i.kt)("li",{parentName:"ol"},"That it's correct because the person/business logic changing ",(0,i.kt)("inlineCode",{parentName:"li"},"last_name")," might have needed to know that the ",(0,i.kt)("inlineCode",{parentName:"li"},"first_name")," they observed at read time is actually incorrect (or vice versa, that the person/business logic ",(0,i.kt)("inlineCode",{parentName:"li"},"first_name")," might have needed to know that the ",(0,i.kt)("inlineCode",{parentName:"li"},"last_name"),' it observed is incorrect), and so they should "redo" their update/logic with the latest values.')),(0,i.kt)("p",null,"Unfortunately, which of these interpretations is right likely changes on a case-by-case basis."),(0,i.kt)("p",null,"However, the 2nd interpretation is safer (i.e. \"just in case\", let's have one of the writers retry), and it's also the most convenient to implement, because a singular ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at")," column can't support per-field versioning (which would be required to implement the 1st interpretation)."),(0,i.kt)("p",null,'So, for now, Joist uses the 2nd interpretation, and does not allow "technically setting separate columns" ',(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE"),"s to interleave."),(0,i.kt)("p",null,"Eventually Joist could support per-field versioning, perhaps with a ",(0,i.kt)("inlineCode",{parentName:"p"},"columns_at")," ",(0,i.kt)("inlineCode",{parentName:"p"},"jsonb")," column that is a map of ",(0,i.kt)("inlineCode",{parentName:"p"},"columnName -> timestamp"),", with some careful crafting of ",(0,i.kt)("inlineCode",{parentName:"p"},"UPDATE")," statements to check and maintain the per-column values."),(0,i.kt)("h3",{id:"when-will-errors-like-this-happen"},"When Will Errors Like This Happen?"),(0,i.kt)("p",null,"In theory, you should rarely see ",(0,i.kt)("inlineCode",{parentName:"p"},"Oplock failure")," errors, and when you do it should be one of two conditions:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"A longer-running process did a read, briefly paused due to business/logic/etc., and then when writing the data, another process had changed the data."),(0,i.kt)("p",{parentName:"li"},"This is a valid detection of the oplock feature preventing data overwrites; ideally the long running process can be implemented with retries to just try again.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},'Two incoming requests happened simultaneously, and it\'s possible a client is "double tapping" saves, i.e. issuing two requests when it should only be issuing one.'))),(0,i.kt)("h3",{id:"integrating-locks-with-the-client"},"Integrating Locks with the Client"),(0,i.kt)("p",null,'By default/currently, Joist\'s op locks are only "held" between the read & write of a single ',(0,i.kt)("inlineCode",{parentName:"p"},"EntityManager"),", i.e.:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"An HTTP request comes in with ",(0,i.kt)("inlineCode",{parentName:"li"},"firstName=bob")),(0,i.kt)("li",{parentName:"ol"},"We load ",(0,i.kt)("inlineCode",{parentName:"li"},'author = await em.load(Author, "a:1")')),(0,i.kt)("li",{parentName:"ol"},"We call ",(0,i.kt)("inlineCode",{parentName:"li"},'author.firstName = "bob"')),(0,i.kt)("li",{parentName:"ol"},"We save ",(0,i.kt)("inlineCode",{parentName:"li"},"em.flush()"))),(0,i.kt)("p",null,"Because steps 2 and 4 are probably ~milliseconds apart, it is fairly unlikely another user/request will have written to ",(0,i.kt)("inlineCode",{parentName:"p"},"a:1"),"."),(0,i.kt)("p",null,"However, a potentially useful way to leverage optimistic locks is to have the HTTP request ",(0,i.kt)("em",{parentName:"p"},"specify which version of ",(0,i.kt)("inlineCode",{parentName:"em"},"a:1")," the user was viewing when they made the change"),"."),(0,i.kt)("p",null,"For example, if:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"User A loads the page ",(0,i.kt)("inlineCode",{parentName:"li"},"/author?id=a:1")," at 10:00am"),(0,i.kt)("li",{parentName:"ol"},"User A decides that ",(0,i.kt)("inlineCode",{parentName:"li"},"firstName=bob")," is a good change to make"),(0,i.kt)("li",{parentName:"ol"},"User B quickly loads ",(0,i.kt)("inlineCode",{parentName:"li"},"/author?id=a:1"),", makes a change, hits save at 10:02am"),(0,i.kt)("li",{parentName:"ol"},'User A finally hits "Save Author" at 10:05am')),(0,i.kt)("p",null,"On step 4, the ",(0,i.kt)("inlineCode",{parentName:"p"},"saveAuthor"),' request could specify "the user is saving ',(0,i.kt)("inlineCode",{parentName:"p"},"a:1"),", but 'as of' ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at=...2:00am..."),'".'),(0,i.kt)("p",null,"This approach would catch that User A is potentially writing over User B's changes, i.e. and fail User A's update with an ",(0,i.kt)("inlineCode",{parentName:"p"},"Oplock failure"),"."),(0,i.kt)("p",null,"That said, this example is theoretical at this point, because Joist does not currently have a way to load an entity but then say you want the ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at")," to be the prior/incoming ",(0,i.kt)("inlineCode",{parentName:"p"},"updated_at"),' / "as of" value. See ',(0,i.kt)("a",{parentName:"p",href:"https://github.com/stephenh/joist-ts/issues/204"},"#204")," for tracking that feature."))}c.isMDXComponent=!0}}]);