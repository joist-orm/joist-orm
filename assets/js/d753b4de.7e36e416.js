"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[624],{5661:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var n=i(4246),s=i(1670);const o={title:"Optimistic Locking",sidebar_position:4},a=void 0,r={id:"advanced/optimistic-locking",title:"Optimistic Locking",description:"Joist implements optimistic locking to avoid conflicting/dropped UPDATEs.",source:"@site/docs/advanced/optimistic-locking.md",sourceDirName:"advanced",slug:"/advanced/optimistic-locking",permalink:"/docs/advanced/optimistic-locking",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/advanced/optimistic-locking.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Optimistic Locking",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Large Collections",permalink:"/docs/advanced/large-collections"},next:{title:"Lens Traversal",permalink:"/docs/advanced/lenses"}},l={},c=[{value:"How It Works",id:"how-it-works",level:3},{value:"Oplock Granularity",id:"oplock-granularity",level:3},{value:"When Will Errors Like This Happen?",id:"when-will-errors-like-this-happen",level:3},{value:"Integrating Locks with the Client",id:"integrating-locks-with-the-client",level:3}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["Joist implements optimistic locking to avoid conflicting/dropped ",(0,n.jsx)(t.code,{children:"UPDATE"}),"s."]}),"\n",(0,n.jsxs)(t.p,{children:["Optimistic locking is a pattern where reading data (i.e. ",(0,n.jsx)(t.code,{children:'em.load(Author, "a:1")'}),') does not lock data (i.e. within the database at the row level, holding a lock that prevents other transactions from reading the row until we\'re "done").']}),"\n",(0,n.jsx)(t.p,{children:'Instead, optimistic locking assumes we are not going to conflict (hence the term "optimistic"), and so does not bother prematurely locking data (which would be "pessimistic locking").'}),"\n",(0,n.jsxs)(t.p,{children:["However, when ",(0,n.jsx)(t.em,{children:"writing"})," data, we check that the data has not changed since we read it."]}),"\n",(0,n.jsx)(t.h3,{id:"how-it-works",children:"How It Works"}),"\n",(0,n.jsxs)(t.p,{children:["When Joist loads data, it knows the ",(0,n.jsx)(t.code,{children:"updated_at"})," for every row that is read, i.e.:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-typescript",children:'const author = await em.load(Author, "a:1");\nconsole.log(author.updated_at); // ...10:00am...\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Then when issuing ",(0,n.jsx)(t.code,{children:"UPDATE"}),"s, we include the ",(0,n.jsx)(t.code,{children:"updated_at"})," as part of the ",(0,n.jsx)(t.code,{children:"WHERE"})," clause:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"UPDATE authors\n  SET\n    first_name = 'bob'\n    updated_at = '...10:01am...'\n  WHERE id = 1\n  AND updated_at = '...10:00am...'\n"})}),"\n",(0,n.jsxs)(t.p,{children:["This ",(0,n.jsx)(t.code,{children:"UPDATE"})," can have two outcomes:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.code,{children:"UPDATE"})," modifies 1 row, and we know no one else changed the data, so our write is successful."]}),"\n",(0,n.jsxs)(t.li,{children:["The ",(0,n.jsx)(t.code,{children:"UPDATE"})," modifies 0 rows, and we know that a different thread changed the data since we had read it, so our write was not successful, and Joist will throw an ",(0,n.jsx)(t.code,{children:"Oplock failure"})," error."]}),"\n"]}),"\n",(0,n.jsxs)(t.admonition,{type:"note",children:[(0,n.jsx)(t.p,{children:"The SQL in this example only updates 1 row at a time, so is pretty straight forward."}),(0,n.jsxs)(t.p,{children:["The SQL that Joist generates at runtime will be more complex, because it batches all ",(0,n.jsx)(t.code,{children:"UPDATE"}),"s for a single table together into 1 SQL call, but the effect is the same: the bulk ",(0,n.jsx)(t.code,{children:"UPDATE"}),"s still check the individual/per-row ",(0,n.jsx)(t.code,{children:"updated_at"})," values."]})]}),"\n",(0,n.jsx)(t.h3,{id:"oplock-granularity",children:"Oplock Granularity"}),"\n",(0,n.jsxs)(t.p,{children:["Currently, Joist's oplock granularity is at the entity/row level, because it uses the row-level ",(0,n.jsx)(t.code,{children:"updated_at"})," column to detect conflicts."]}),"\n",(0,n.jsx)(t.p,{children:"So if you have two clients that are trying to simultaneously update separate columns, i.e.:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-sql",children:"-- thread 1, sets first name\nUPDATE authors SET first_name = 'bob'\n  WHERE id = 1 AND updated_at = '...10:00am...'\n\n-- thread 2, sets last name\nUPDATE authors SET last_name = 'smith'\n  WHERE id = 1 AND updated_at = '...10:00am...'\n"})}),"\n",(0,n.jsx)(t.p,{children:"These two statements will still conflict, and only 1 will win."}),"\n",(0,n.jsx)(t.p,{children:"There are two interpretations of this behavior:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["That it's incorrect because each ",(0,n.jsx)(t.code,{children:"UPDATE"})," touched separate columns, so they should have been allowed to interleave."]}),"\n",(0,n.jsxs)(t.li,{children:["That it's correct because the person/business logic changing ",(0,n.jsx)(t.code,{children:"last_name"})," might have needed to know that the ",(0,n.jsx)(t.code,{children:"first_name"})," they observed at read time is actually incorrect (or vice versa, that the person/business logic ",(0,n.jsx)(t.code,{children:"first_name"})," might have needed to know that the ",(0,n.jsx)(t.code,{children:"last_name"}),' it observed is incorrect), and so they should "redo" their update/logic with the latest values.']}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Unfortunately, which of these interpretations is right likely changes on a case-by-case basis."}),"\n",(0,n.jsxs)(t.p,{children:["However, the 2nd interpretation is safer (i.e. \"just in case\", let's have one of the writers retry), and it's also the most convenient to implement, because a singular ",(0,n.jsx)(t.code,{children:"updated_at"})," column can't support per-field versioning (which would be required to implement the 1st interpretation)."]}),"\n",(0,n.jsxs)(t.p,{children:['So, for now, Joist uses the 2nd interpretation, and does not allow "technically setting separate columns" ',(0,n.jsx)(t.code,{children:"UPDATE"}),"s to interleave."]}),"\n",(0,n.jsxs)(t.p,{children:["Eventually Joist could support per-field versioning, perhaps with a ",(0,n.jsx)(t.code,{children:"columns_at"})," ",(0,n.jsx)(t.code,{children:"jsonb"})," column that is a map of ",(0,n.jsx)(t.code,{children:"columnName -> timestamp"}),", with some careful crafting of ",(0,n.jsx)(t.code,{children:"UPDATE"})," statements to check and maintain the per-column values."]}),"\n",(0,n.jsx)(t.h3,{id:"when-will-errors-like-this-happen",children:"When Will Errors Like This Happen?"}),"\n",(0,n.jsxs)(t.p,{children:["In theory, you should rarely see ",(0,n.jsx)(t.code,{children:"Oplock failure"})," errors, and when you do it should be one of two conditions:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:"A longer-running process did a read, briefly paused due to business/logic/etc., and then when writing the data, another process had changed the data."}),"\n",(0,n.jsx)(t.p,{children:"This is a valid detection of the oplock feature preventing data overwrites; ideally the long running process can be implemented with retries to just try again."}),"\n"]}),"\n",(0,n.jsxs)(t.li,{children:["\n",(0,n.jsx)(t.p,{children:'Two incoming requests happened simultaneously, and it\'s possible a client is "double tapping" saves, i.e. issuing two requests when it should only be issuing one.'}),"\n"]}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"integrating-locks-with-the-client",children:"Integrating Locks with the Client"}),"\n",(0,n.jsxs)(t.p,{children:['By default/currently, Joist\'s op locks are only "held" between the read & write of a single ',(0,n.jsx)(t.code,{children:"EntityManager"}),", i.e.:"]}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["An HTTP request comes in with ",(0,n.jsx)(t.code,{children:"firstName=bob"})]}),"\n",(0,n.jsxs)(t.li,{children:["We load ",(0,n.jsx)(t.code,{children:'author = await em.load(Author, "a:1")'})]}),"\n",(0,n.jsxs)(t.li,{children:["We call ",(0,n.jsx)(t.code,{children:'author.firstName = "bob"'})]}),"\n",(0,n.jsxs)(t.li,{children:["We save ",(0,n.jsx)(t.code,{children:"em.flush()"})]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Because steps 2 and 4 are probably ~milliseconds apart, it is fairly unlikely another user/request will have written to ",(0,n.jsx)(t.code,{children:"a:1"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["However, a potentially useful way to leverage optimistic locks is to have the HTTP request ",(0,n.jsxs)(t.em,{children:["specify which version of ",(0,n.jsx)(t.code,{children:"a:1"})," the user was viewing when they made the change"]}),"."]}),"\n",(0,n.jsx)(t.p,{children:"For example, if:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["User A loads the page ",(0,n.jsx)(t.code,{children:"/author?id=a:1"})," at 10:00am"]}),"\n",(0,n.jsxs)(t.li,{children:["User A decides that ",(0,n.jsx)(t.code,{children:"firstName=bob"})," is a good change to make"]}),"\n",(0,n.jsxs)(t.li,{children:["User B quickly loads ",(0,n.jsx)(t.code,{children:"/author?id=a:1"}),", makes a change, hits save at 10:02am"]}),"\n",(0,n.jsx)(t.li,{children:'User A finally hits "Save Author" at 10:05am'}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["On step 4, the ",(0,n.jsx)(t.code,{children:"saveAuthor"}),' request could specify "the user is saving ',(0,n.jsx)(t.code,{children:"a:1"}),", but 'as of' ",(0,n.jsx)(t.code,{children:"updated_at=...2:00am..."}),'".']}),"\n",(0,n.jsxs)(t.p,{children:["This approach would catch that User A is potentially writing over User B's changes, i.e. and fail User A's update with an ",(0,n.jsx)(t.code,{children:"Oplock failure"}),"."]}),"\n",(0,n.jsxs)(t.p,{children:["That said, this example is theoretical at this point, because Joist does not currently have a way to load an entity but then say you want the ",(0,n.jsx)(t.code,{children:"updated_at"})," to be the prior/incoming ",(0,n.jsx)(t.code,{children:"updated_at"}),' / "as of" value. See ',(0,n.jsx)(t.a,{href:"https://github.com/joist-orm/joist-orm/issues/204",children:"#204"})," for tracking that feature."]})]})}function h(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},1670:(e,t,i)=>{i.d(t,{Z:()=>r,a:()=>a});var n=i(7378);const s={},o=n.createContext(s);function a(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);