"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9214],{3023:(e,t,s)=>{s.d(t,{R:()=>o,x:()=>l});var n=s(3696);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}},3635:e=>{e.exports=JSON.parse('{"permalink":"/blog/evolution-of-defaults","source":"@site/blog/2024-11-13-evolution-of-defaults.md","title":"Evolution of Defaults","description":"Joist\'s mission is to model your application\'s business logic, with first-class support for domain modeling features & concepts.","date":"2024-11-13T00:00:00.000Z","tags":[],"readingTime":7.365,"hasTruncateMarker":false,"authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png","socials":{},"key":null,"page":null}],"frontMatter":{"title":"Evolution of Defaults","slug":"evolution-of-defaults","authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"tags":[]},"unlisted":false,"nextItem":{"title":"Recursive Relations","permalink":"/blog/recursive-relations"}}')},9565:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>c,frontMatter:()=>o,metadata:()=>n,toc:()=>d});var n=s(3635),i=s(2540),a=s(3023);const o={title:"Evolution of Defaults",slug:"evolution-of-defaults",authors:[{name:"Stephen Haberman",url:"https://github.com/stephenh",image_url:"https://github.com/stephenh.png"}],tags:[]},l=void 0,r={authorsImageUrls:[void 0]},d=[{value:"Version 1. Schema Defaults",id:"version-1-schema-defaults",level:3},{value:"Version 2. beforeCreate hooks",id:"version-2-beforecreate-hooks",level:3},{value:"Version 3: Adding setDefault",id:"version-3-adding-setdefault",level:3},{value:"Version 4: Dependency Aware",id:"version-4-dependency-aware",level:3},{value:"Version 5: Teaching Factories!",id:"version-5-teaching-factories",level:3},{value:"Version Next: findOrCreates",id:"version-next-findorcreates",level:3},{value:"Slow Grind to Perfection",id:"slow-grind-to-perfection",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Joist's mission is to model your application's business logic, with first-class support for domain modeling features & concepts."}),"\n",(0,i.jsxs)(t.p,{children:["A great example of this is Joist's support for something as simple as default values: for example, the ",(0,i.jsx)(t.code,{children:"Author.status"})," field should default to ",(0,i.jsx)(t.code,{children:"Active"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:['Joist\'s default values support grew from "the simplest thing possible" (requiring adhoc patterns that engineers would copy/paste around) to a robust, first-class feature (an explicit ',(0,i.jsx)(t.code,{children:"setDefault"}),' API that "just works").']}),"\n",(0,i.jsx)(t.p,{children:'This is a microcosm of Joist\'s goal to identify the repeated patterns and pain points involved in "building a domain model", and provide elegant features with a great DX.'}),"\n",(0,i.jsx)(t.h3,{id:"version-1-schema-defaults",children:"Version 1. Schema Defaults"}),"\n",(0,i.jsxs)(t.p,{children:['Joist\'s initial defaults support was purposefully "as simple as possible", and limited to ',(0,i.jsx)(t.code,{children:"DEFAULT"}),"s declared in the database schema, i.e. an ",(0,i.jsx)(t.code,{children:"is_archived"})," field that defaults to ",(0,i.jsx)(t.code,{children:"FALSE"}),", or a ",(0,i.jsx)(t.code,{children:"status_id"})," that defaults to ",(0,i.jsx)(t.code,{children:"DRAFT"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-sql",children:"CREATE TABLE example_table (\n    id SERIAL PRIMARY KEY,\n    is_archived BOOL DEFAULT false,\n    status_id INTEGER DEFAULT 1,\n);\n"})}),"\n",(0,i.jsx)(t.p,{children:'Joist\'s codegen would recognize these, and "apply them immediately" when creating an entity:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"const a = em.create(Author, {});\nexpect(a.status).toBe(AuthorStatus.Draft); // already Draft\nexpect(a.isArchived).toBe(false); // already false\n"})}),"\n",(0,i.jsx)(t.p,{children:"This was super-simple, and had a few pros:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Pro: The ",(0,i.jsx)(t.code,{children:"status"})," is immediately within the ",(0,i.jsx)(t.code,{children:"em.create"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["I.e. you don't have to wait for an ",(0,i.jsx)(t.code,{children:"em.flush"}),' to "see the database default"']}),"\n",(0,i.jsx)(t.li,{children:"Any business logic can immediately start using the default"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.li,{children:'Pro: No duplication of "draft is the default" between the database schema & TypeScript code'}),"\n",(0,i.jsxs)(t.li,{children:["Con: Only supports static, hard-coded values","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Ideally we'd like to write lambdas to calculate defaults, based on business logic"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"version-2-beforecreate-hooks",children:"Version 2. beforeCreate hooks"}),"\n",(0,i.jsxs)(t.p,{children:["Being limited to static ",(0,i.jsx)(t.code,{children:"DEFAULT"}),' values is not great, so the first way of implementing more complicated "dynamic defaults" was using Joist\'s ',(0,i.jsx)(t.code,{children:"beforeCreate"})," hooks:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:'/** Any author created w/non-zero amount of books defaults to Published. */\nauthorConfig.beforeCreate("books", a => {\n  if (a.status === undefined) {\n    a.status = a.books.get.length > 0 ? AuthorStatus.Published : AuthorStatus.Draft;\n  }  \n})\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This was a quick-win b/c Joist already supported ",(0,i.jsx)(t.code,{children:"beforeCreate"})," hooks, but had a few cons:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Pro: Supports arbitrary business logic","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The load hint easily enables cross-entity calculations"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Con: The default logic isn't ran until ",(0,i.jsx)(t.code,{children:"em.flush"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Harder for business logic to rely on"}),"\n",(0,i.jsxs)(t.li,{children:['Creates inconsistency between "hard-coded defaults" (applied immediately in ',(0,i.jsx)(t.code,{children:"em.create"}),') and "dynamic defaults" (applied during ',(0,i.jsx)(t.code,{children:"flush"}),")"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Con: Susceptible to hook ordering issues","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["If our default's value depends on ",(0,i.jsx)(t.em,{children:"other"}),' defaults, it is hard to ensure the other "runs first"']}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Con: Boilerplate/imperative (not really a first-class feature)","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The code has to 1st check if ",(0,i.jsx)(t.code,{children:"a.status"})," is already set (not a huge deal, but boilerplate)"]}),"\n",(0,i.jsx)(t.li,{children:'There is nothing in the code/API that identifies "this is a default", instead we just have an adhoc pattern of "this is how our app sets defaults"'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Con: Caused duplication with test factories","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:['Our test factories often wanted "the same defaults" applied, but Joist\'s factories are synchronous, which meant any logic that was "set in ',(0,i.jsx)(t.code,{children:"beforeCreate"}),"\" wouldn't be seen right away."]}),"\n",(0,i.jsx)(t.li,{children:'To work around this, we often "wrote twice" default logic across our entities & test factories--not great!'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"version-3-adding-setdefault",children:"Version 3: Adding setDefault"}),"\n",(0,i.jsx)(t.p,{children:'We lived with the Version 1 & 2 options for several years, because they were "good enough", but for the 3rd version, we wanted to start "setting defaults" on the road to being "more than just good enough".'}),"\n",(0,i.jsxs)(t.p,{children:['Specifically, we wanted a first-class, idiomatic way to "declaratively specify a field\'s default value" instead of the previous "manually check the field in a ',(0,i.jsx)(t.code,{children:"beforeCreate"}),' hook".']}),"\n",(0,i.jsxs)(t.p,{children:["So we added ",(0,i.jsx)(t.code,{children:"config.setDefault"}),", which accepts the field name, it's dependencies (if any), and a lambda that would calculate the default value:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:'/** Calculate the Author.status default, based on number of books. */\nauthorConfig.setDefault("status", "books", (a) => {\n  // a.books.get is available, but a.firstName is not, b/c it\'s not listed as a dependency\n  return a.books.get.length > 0 ? AuthorStatus.Published : AuthorStatus.Draft;\n})\n'})}),"\n",(0,i.jsx)(t.p,{children:"This was a great start, but we pushed it out knowingly half-baked:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Pro: Provided scaffolding of a better future","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'Gave an idiomatic way to "declare defaults"'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Pro: The type system enforces that the lambda only calls fields explicitly listed in the dependency param","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["This reused our ",(0,i.jsx)(t.code,{children:"ReactiveField"})," infra and is great for ensuring dependencies aren't missed"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Con: The dependencies weren't actually used yet","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'"...ship early!"'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["Con: ",(0,i.jsx)(t.code,{children:"setDefault"})," lambdas were still not invoked until ",(0,i.jsx)(t.code,{children:"em.flush"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'So we still had the "write defaults twice" problem with test factories'}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"version-4-dependency-aware",children:"Version 4: Dependency Aware"}),"\n",(0,i.jsxs)(t.p,{children:["After having the ",(0,i.jsx)(t.code,{children:"setDefault"}),' API in production for a few months, the next improvement was to capitalize on "knowing our dependencies" and allow defaults to depend on other defaults.']}),"\n",(0,i.jsxs)(t.p,{children:["For example, maybe our ",(0,i.jsx)(t.code,{children:"Author.status"})," default needs to know whether any of the books are published (which itself is a default):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:'// In `Author.ts`\nauthorConfig.setDefault("status", { books: "status" }, a => {\n  const anyBookPublished = a.books.get.some(b => b.status === BookStatus.Published);\n  return anyBookPublished ? AuthorStatus.Published : AuthorStatus.Draft;\n})\n\n// In `Book.ts`\nbookConfig.setDefault("status", {}, b => {\n  // Some business logic that dynamically determines the status\n  return BookStatus.Published;\n});\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Now, if both a ",(0,i.jsx)(t.code,{children:"Book"})," and an ",(0,i.jsx)(t.code,{children:"Author"})," are created at the same time, ",(0,i.jsx)(t.code,{children:"em.flush"})," will ensure that the ",(0,i.jsx)(t.code,{children:"Book.status"})," is calculated before invoking the ",(0,i.jsx)(t.code,{children:"Author.status"})," default--",(0,i.jsx)(t.em,{children:"we've solved our ordering issue!"})]}),"\n",(0,i.jsx)(t.p,{children:"This was a major accomplishment--cross-entity defaults had been a thorn in our side for years."}),"\n",(0,i.jsx)(t.p,{children:'(Fwiw we readily admit this is a rare/obscure need--in our domain model of 100s of entities, we have only ~2-3 of these "cross-entity defaults", so we want to be clear this is not necessarily a "must have" feature--but, when you need it, it\'s extremely nice to have!)'}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Pro: Finally unlocked cross-entity defaults"}),"\n",(0,i.jsx)(t.li,{children:'Con: Still have the "write defaults twice" problem with factories'}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"version-5-teaching-factories",children:"Version 5: Teaching Factories!"}),"\n",(0,i.jsx)(t.p,{children:'The next DX iteration was solving the duplication of "factories want the defaults too!".'}),"\n",(0,i.jsxs)(t.p,{children:["Looking more closely at this issue, Joist's test factories are synchronous, which means we can create test data easily without any ",(0,i.jsx)(t.code,{children:"await"}),"s:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:'// Given an author\nconst a = newAuthor(em);\n// And a book \nconst b = newBook(em, { author: a });\n// And setup something else using b.title\n// ...if there is "default title logic", it will not have ran yet, which\n// can be confusing for tests/other logic expecting that behavior \nconsole.log(b.title);\n'})}),"\n",(0,i.jsxs)(t.p,{children:["The lack of ",(0,i.jsx)(t.code,{children:"await"}),"s is very nice! But it does mean, if we really wanted ",(0,i.jsx)(t.code,{children:"b.title"})," to ",(0,i.jsx)(t.em,{children:"immediately"})," reflect its production default, we had recode the default logic into the ",(0,i.jsx)(t.code,{children:"newBook"})," factory:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:'export function newBook(em: EntityManager): DeepNew<Book> {\n  return newTestInstance(em, Book, {\n    title: "recode the Book default logic here",\n  });\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:['As before, for a while this was "good enough"--but finally in this iteration, we taught the factories to leverage their "each test\'s data is already in memory" advantage and just invoke the defaults immediately during the ',(0,i.jsx)(t.code,{children:"newTestInstance"})," calls."]}),"\n",(0,i.jsxs)(t.p,{children:["This works even for ",(0,i.jsx)(t.code,{children:"setDefault"}),'s that use load hints, like "author status depends on its books":']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:'// In `Author.ts`\nauthorConfig.setDefault("status", { books: "status" }, a => {\n  const anyBookPublished = a.books.get.some(b => b.status === BookStatus.Published);\n  return anyBookPublished ? AuthorStatus.Published : AuthorStatus.Draft;\n})\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In production, Joist can't assume \"the author's books are already in-memory\", so ",(0,i.jsx)(t.code,{children:"em.flush"})," would first load / ",(0,i.jsx)(t.code,{children:"await"})," for the ",(0,i.jsx)(t.code,{children:"a.books"})," to be loaded, and then invoke the lambda."]}),"\n",(0,i.jsxs)(t.p,{children:["However, because our tests know that ",(0,i.jsx)(t.code,{children:"a.books"})," is already in memory, they can skip this ",(0,i.jsx)(t.code,{children:"await"}),", and immediately invoke the lambda."]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'Pro: We finally can remove the factory\'s "write it twice" defaults'}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"version-next-findorcreates",children:"Version Next: findOrCreates"}),"\n",(0,i.jsxs)(t.p,{children:["Always looking ahead, the next itch we have is that, currently, default lambdas that call async methods like ",(0,i.jsx)(t.code,{children:"em.find"})," or ",(0,i.jsx)(t.code,{children:"em.findOrCreate"})," are still skipped during ",(0,i.jsx)(t.code,{children:"newTestInstance"})," and only run during ",(0,i.jsx)(t.code,{children:"em.flush"}),"."]}),"\n",(0,i.jsx)(t.p,{children:'Which means, for these defaults, we still have remnants of the "write it twice" defaults anti-pattern--albeit very few of them!'}),"\n",(0,i.jsxs)(t.p,{children:["We should be able to lift this restriction as well, with a little bit of work (...maybe ","\ud83e\udd14",", the ",(0,i.jsx)(t.code,{children:"newBook"})," call is fundamentally synchronous, so maybe not)."]}),"\n",(0,i.jsx)(t.h2,{id:"slow-grind-to-perfection",children:"Slow Grind to Perfection"}),"\n",(0,i.jsxs)(t.p,{children:["Wrapping up, besides a \"walk down memory lane\", the larger point of this post is highlighting Joist's journey of continually grinding on DX polish--we're about five years into ",(0,i.jsx)(t.a,{href:"https://www.joelonsoftware.com/2001/07/21/good-software-takes-ten-years-get-used-to-it/",children:"Joel's Good Software Takes 10 Years"}),", so only another 5 to go! ","\ud83d\ude04"]}),"\n",(0,i.jsxs)(t.p,{children:["Of course, it'd be great for this evolution to happen more quickly--i.e. if we had a dependency-aware, factory-aware, amazing ",(0,i.jsx)(t.code,{children:"setDefault"})," API from day one."]}),"\n",(0,i.jsx)(t.p,{children:'But, often times jumping to an abstraction can be premature, and result in a rushed design--so sometimes it doesn\'t hurt to "sit with the itch" for a little while, evolve it through multiple iterations of "good enough", until finally a pleasant/robust solution emerges.'}),"\n",(0,i.jsxs)(t.p,{children:["And, perhaps most pragmatically, small iterations helps spread the implementation out over enough hack days that it can actually get shipped. ","\ud83d\udea2"]})]})}function c(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);