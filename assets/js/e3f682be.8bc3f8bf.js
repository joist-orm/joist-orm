"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[679],{8898:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>r});var i=s(4246),t=s(1670);const l={title:"Fields",sidebar_position:1},d=void 0,a={id:"modeling/fields",title:"Fields",description:"Fields are the primitive columns in your domain model, so all of the (non-foreign key) int, varchar, datetime, etc. columns.",source:"@site/docs/modeling/fields.md",sourceDirName:"modeling",slug:"/modeling/fields",permalink:"/docs/modeling/fields",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/modeling/fields.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Fields",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Great Tests",permalink:"/docs/goals/great-tests"},next:{title:"Relations",permalink:"/docs/modeling/relations"}},o={},r=[{value:"Optional vs Required",id:"optional-vs-required",level:2},{value:"Using <code>undefined</code> instead of <code>null</code>",id:"using-undefined-instead-of-null",level:3},{value:"Type Checked Construction",id:"type-checked-construction",level:3},{value:"Partial Updates Semantics",id:"partial-updates-semantics",level:3},{value:"Protected Fields",id:"protected-fields",level:2},{value:"Field Defaults",id:"field-defaults",level:2},{value:"Schema Defaults",id:"schema-defaults",level:3},{value:"Dynamic Defaults",id:"dynamic-defaults",level:3},{value:"Hooks",id:"hooks",level:3}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,t.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Fields are the primitive columns in your domain model, so all of the (non-foreign key) ",(0,i.jsx)(n.code,{children:"int"}),", ",(0,i.jsx)(n.code,{children:"varchar"}),", ",(0,i.jsx)(n.code,{children:"datetime"}),", etc. columns."]}),"\n",(0,i.jsxs)(n.p,{children:["For these columns, Joist automatically adds getters & setters to your domain model, i.e. an ",(0,i.jsx)(n.code,{children:"authors.first_name"})," column will have getters & setters added to ",(0,i.jsx)(n.code,{children:"AuthorCodegen.ts"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-ts",children:'// This code is auto-generated\nclass AuthorCodegen {\n  get firstName(): string {\n    return getField(this, "firstName");\n  }\n\n  set firstName(firstName: string) {\n    setField(this, "firstName", firstName);\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"optional-vs-required",children:"Optional vs Required"}),"\n",(0,i.jsxs)(n.p,{children:["Joist's fields model ",(0,i.jsx)(n.code,{children:"null"})," and ",(0,i.jsx)(n.code,{children:"not null"})," appropriately, e.g. for a table like:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:'                     Table "public.authors"\n    Column    |           Type           | Nullable\n--------------+--------------------------+----------+\n id           | integer                  | not null |\n first_name   | character varying(255)   | not null |\n last_name    | character varying(255)   |          |\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"Author"})," domain object will type ",(0,i.jsx)(n.code,{children:"firstName"})," as a ",(0,i.jsx)(n.code,{children:"string"}),", and ",(0,i.jsx)(n.code,{children:"lastName"})," as ",(0,i.jsx)(n.code,{children:"string | undefined"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"class AuthorCodegen {\n  get firstName(): string { ... }\n  set firstName(firstName: string) { ... }\n  get lastName(): string | undefined { ... }\n  set lastName(lastName: string | undefined) { ... }\n}\n"})}),"\n",(0,i.jsxs)(n.h3,{id:"using-undefined-instead-of-null",children:["Using ",(0,i.jsx)(n.code,{children:"undefined"})," instead of ",(0,i.jsx)(n.code,{children:"null"})]}),"\n",(0,i.jsxs)(n.p,{children:["Joist uses ",(0,i.jsx)(n.code,{children:"undefined"})," to represent nullable columns, i.e. in the ",(0,i.jsx)(n.code,{children:"Author"})," example, the ",(0,i.jsx)(n.code,{children:"lastName"})," type is ",(0,i.jsx)(n.code,{children:"string | undefined"})," instead of ",(0,i.jsx)(n.code,{children:"string | null"})," or ",(0,i.jsx)(n.code,{children:"string | null | undefined"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:['The rationale for this is simplicity, and Joist\'s preference for "idiomatic TypeScript", which for the most part has eschewed the "when to use ',(0,i.jsx)(n.code,{children:"undefined"})," vs. ",(0,i.jsx)(n.code,{children:"null"}),' in JavaScript?" decision by going with "just use ',(0,i.jsx)(n.code,{children:"undefined"}),'."']}),"\n",(0,i.jsx)(n.h3,{id:"type-checked-construction",children:"Type Checked Construction"}),"\n",(0,i.jsxs)(n.p,{children:["The non-null ",(0,i.jsx)(n.code,{children:"Author.firstName"})," field is enforced as required on construction:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Valid\nnew Author(em, { firstName: "bob" });\n// Not valid\nnew Author(em, {});\n// Not valid\nnew Author(em, { firstName: null });\n// Not valid\nnew Author(em, { firstName: undefined });\n'})}),"\n",(0,i.jsxs)(n.p,{children:["And for updates made via the ",(0,i.jsx)(n.code,{children:"set"})," method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Valid\nauthor.set({ firstName: "bob" });\n// Valid, because `set` accepts a Partial\nauthor.set({});\n// Not valid\nauthor.set({ firstName: null });\n// Technically valid b/c `set` accepts a Partial, but is a noop\nauthor.set({ firstName: undefined });\n'})}),"\n",(0,i.jsx)(n.h3,{id:"partial-updates-semantics",children:"Partial Updates Semantics"}),"\n",(0,i.jsxs)(n.p,{children:["While within internal business logic ",(0,i.jsx)(n.code,{children:"null"})," vs. ",(0,i.jsx)(n.code,{children:"undefined"})," is not really a useful distinction, when building APIs ",(0,i.jsx)(n.code,{children:"null"}),' can be a useful value to signify "unset" (vs. ',(0,i.jsx)(n.code,{children:"undefined"}),' which typically signifies "don\'t change").']}),"\n",(0,i.jsxs)(n.p,{children:["For this use case, domain objects have a ",(0,i.jsx)(n.code,{children:".setPartial"})," that accepts null versions of properties:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// Partial update from an API operation\nconst updateFromApi = {\n  firstName: null\n};\n// Allowed\nauthor.setPartial(updateFromApi);\n// Outputs "undeifned" b/c null is still translated to undefined\nconsole.log(author.firstName);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Note that, when using ",(0,i.jsx)(n.code,{children:"setPartial"})," we have caused our ",(0,i.jsx)(n.code,{children:"Author.firstName: string"})," getter to now be incorrect, i.e. for a currently invalid ",(0,i.jsx)(n.code,{children:"Author"}),", clients might observe ",(0,i.jsx)(n.code,{children:"firstName"})," as ",(0,i.jsx)(n.code,{children:"undefined"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["See ",(0,i.jsx)(n.a,{href:"/docs/features/partial-update-apis",children:"Partial Update APIs"})," for more details."]}),"\n",(0,i.jsx)(n.h2,{id:"protected-fields",children:"Protected Fields"}),"\n",(0,i.jsxs)(n.p,{children:["You can mark a field as protected in ",(0,i.jsx)(n.code,{children:"joist-config.json"}),", which will make the setter ",(0,i.jsx)(n.code,{children:"protected"}),", so that only your entity's internal business logic can call it."]}),"\n",(0,i.jsx)(n.p,{children:"The getter will still be public."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "entities": {\n    "Author": {\n      "fields": {\n        "wasEverPopular": { "protected": true }\n      }\n    }\n  }\n}\n'})}),"\n",(0,i.jsx)(n.h2,{id:"field-defaults",children:"Field Defaults"}),"\n",(0,i.jsx)(n.h3,{id:"schema-defaults",children:"Schema Defaults"}),"\n",(0,i.jsxs)(n.p,{children:["If your database schema has default values for columns, i.e. an integer that defaults to 0, Joist will immediately apply those defaults to entities as they're created, i.e. via ",(0,i.jsx)(n.code,{children:"em.create"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["This gives your business logic immediate access to the default value that would be applied by the database, but without waiting for an ",(0,i.jsx)(n.code,{children:"em.flush"})," to happen."]}),"\n",(0,i.jsx)(n.h3,{id:"dynamic-defaults",children:"Dynamic Defaults"}),"\n",(0,i.jsxs)(n.p,{children:["If you need to use ",(0,i.jsx)(n.code,{children:"async"}),", cross-entity business logic to set field defaults, you can use the ",(0,i.jsx)(n.code,{children:"config.setDefault"})," method:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'/** Example of a synchronous default. */\nconfig.setDefault("notes", (b) => `Notes for ${b.title}`);\n\n/** Example of an asynchronous default. */\nconfig.setDefault("order", { author: "books" }, (b) => b.author.get.books.get.length);\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Any ",(0,i.jsx)(n.code,{children:"setDefault"})," without a load hint (the 1st example) must be synchronous, and will be ",(0,i.jsx)(n.em,{children:"applied immediately"})," upon creation, i.e. ",(0,i.jsx)(n.code,{children:"em.create"})," calls, just like the schema default values."]}),"\n",(0,i.jsxs)(n.p,{children:["Any ",(0,i.jsx)(n.code,{children:"setDefault"})," with a load hint (the 2nd exmaple) can be asynchronous, and will ",(0,i.jsxs)(n.em,{children:["not be applied until ",(0,i.jsx)(n.code,{children:"em.flush()"})]}),", because the ",(0,i.jsx)(n.code,{children:"async"})," nature means we have to wait to invoke them."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["We could probably add an async ",(0,i.jsx)(n.code,{children:"em.assignDefaults"}),", similar to ",(0,i.jsx)(n.code,{children:"em.assignNewIds"}),", to allow code to trigger async default assignment, without kicking off an ",(0,i.jsx)(n.code,{children:"em.flush"}),"."]})}),"\n",(0,i.jsx)(n.h3,{id:"hooks",children:"Hooks"}),"\n",(0,i.jsxs)(n.p,{children:["You can also use ",(0,i.jsx)(n.code,{children:"beforeCreate"})," hooks to apply defaults, but ",(0,i.jsx)(n.code,{children:"setDefault"})," is preferred because it's the most accurate modeling of intent, and follows our general recommendation to use hooks sparingly."]})]})}function h(e={}){const{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},1670:(e,n,s)=>{s.d(n,{Z:()=>a,a:()=>d});var i=s(7378);const t={},l=i.createContext(t);function d(e){const n=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:d(e.components),i.createElement(l.Provider,{value:n},e.children)}}}]);