"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[364],{3547:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>d,toc:()=>l});var t=n(4246),i=n(1670);const r={title:"JSONB Fields",sidebar_position:9},o=void 0,d={id:"modeling/jsonb-fields",title:"JSONB Fields",description:"Postgres has rich support for storing JSON, which Joist supports.",source:"@site/docs/modeling/jsonb-fields.md",sourceDirName:"modeling",slug:"/modeling/jsonb-fields",permalink:"/docs/modeling/jsonb-fields",draft:!1,unlisted:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/modeling/jsonb-fields.md",tags:[],version:"current",sidebarPosition:9,frontMatter:{title:"JSONB Fields",sidebar_position:9},sidebar:"tutorialSidebar",previous:{title:"Derived Fields",permalink:"/docs/modeling/derived-fields"},next:{title:"Entity Manager",permalink:"/docs/features/entity-manager"}},c={},l=[{value:"Optional Strong Typing",id:"optional-strong-typing",level:3},{value:"Approach",id:"approach",level:3},{value:"Zod",id:"zod",level:4},{value:"Superstruct",id:"superstruct",level:4},{value:"Current Limitations",id:"current-limitations",level:3}];function a(e){const s={a:"a",code:"code",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(s.p,{children:["Postgres has rich support for ",(0,t.jsx)(s.a,{href:"https://www.postgresql.org/docs/current/datatype-json.html",children:"storing JSON"}),", which Joist supports."]}),"\n",(0,t.jsx)(s.h3,{id:"optional-strong-typing",children:"Optional Strong Typing"}),"\n",(0,t.jsxs)(s.p,{children:["While Postgres does not apply a schema to ",(0,t.jsx)(s.code,{children:"jsonb"})," columns, this can often be useful when you do actually have/know a schema for a ",(0,t.jsx)(s.code,{children:"jsonb"})," column, but are using the ",(0,t.jsx)(s.code,{children:"jsonb"})," column as a more succinct/pragmatic way to store nested/hierarchical data than as strictly relational tables and columns."]}),"\n",(0,t.jsxs)(s.p,{children:["To support this, Joist supports both the ",(0,t.jsx)(s.a,{href:"https://docs.superstructjs.org/",children:"superstruct"})," library and ",(0,t.jsx)(s.a,{href:"https://zod.dev/",children:"Zod"}),", which can describe both the TypeScript type for a value (i.e. ",(0,t.jsx)(s.code,{children:"Address"})," has both as a ",(0,t.jsx)(s.code,{children:"street"})," and a ",(0,t.jsx)(s.code,{children:"city"}),"), as well as do runtime validation and parsing of address values."]}),"\n",(0,t.jsxs)(s.p,{children:["That said, if you do want to use the ",(0,t.jsx)(s.code,{children:"jsonb"})," column effectively as an ",(0,t.jsx)(s.code,{children:"any"})," object, the additional typing is optional, and you'll just work with ",(0,t.jsx)(s.code,{children:"Object"}),"s instead."]}),"\n",(0,t.jsx)(s.h3,{id:"approach",children:"Approach"}),"\n",(0,t.jsxs)(s.p,{children:["We'll use an example of storing an ",(0,t.jsx)(s.code,{children:"Address"})," with ",(0,t.jsx)(s.code,{children:"street"})," and ",(0,t.jsx)(s.code,{children:"city"})," fields within a single ",(0,t.jsx)(s.code,{children:"jsonb"})," column."]}),"\n",(0,t.jsx)(s.h4,{id:"zod",children:"Zod"}),"\n",(0,t.jsxs)(s.p,{children:["First, define a ",(0,t.jsx)(s.a,{href:"https://zod.dev/",children:"Zod"})," schema for the data you're going to store in ",(0,t.jsx)(s.code,{children:"src/entities/types.ts"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-typescript",children:'import { z } from "zod";\n\nexport const Address = z.object({\n  street: z.string(),\n  city: z.string(),\n});\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Then tell Joist to use this ",(0,t.jsx)(s.code,{children:"Address"})," schema for the ",(0,t.jsx)(s.code,{children:"Author.address"})," field in ",(0,t.jsx)(s.code,{children:"joist-config.json"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-json",children:'{\n  "entities": {\n    "Author": {\n      "fields": {\n        "address": {\n          "zodSchema": "Address@src/entities/types"\n        }\n      },\n      "tag": "a"\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Now just run ",(0,t.jsx)(s.code,{children:"joist-codegen"})," and the ",(0,t.jsx)(s.code,{children:"AuthorCodegen"}),"'s ",(0,t.jsx)(s.code,{children:"address"})," field use the ",(0,t.jsx)(s.code,{children:"Address"})," schema using Zod's ",(0,t.jsx)(s.code,{children:"z.input"})," and ",(0,t.jsx)(s.code,{children:"z.output"})," inference in setter and getter respectively."]}),"\n",(0,t.jsx)(s.h4,{id:"superstruct",children:"Superstruct"}),"\n",(0,t.jsxs)(s.p,{children:["First, define a ",(0,t.jsx)(s.a,{href:"https://docs.superstructjs.org/",children:"superstruct"})," type for the data you're going to store in ",(0,t.jsx)(s.code,{children:"src/entities/types.ts"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-typescript",children:'import { Infer, object, string } from "superstruct";\n\nexport type Address = Infer<typeof address>;\n\nexport const address = object({\n  street: string(),\n  city: string(),\n});\n'})}),"\n",(0,t.jsx)(s.p,{children:"Where:"}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"address"})," is a structure that defines the schema/shape of the data to store"]}),"\n",(0,t.jsxs)(s.li,{children:[(0,t.jsx)(s.code,{children:"Address"})," is the TypeScript type system that Superstruct will derive for us"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["Then tell Joist to use this ",(0,t.jsx)(s.code,{children:"Address"})," type for the ",(0,t.jsx)(s.code,{children:"Author.address"})," field in ",(0,t.jsx)(s.code,{children:"joist-config.json"}),":"]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-json",children:'{\n  "entities": {\n    "Author": {\n      "fields": {\n        "address": {\n          "superstruct": "address@src/entities/types"\n        }\n      },\n      "tag": "a"\n    }\n  }\n}\n'})}),"\n",(0,t.jsxs)(s.p,{children:["Note that we're pointing Joist at the ",(0,t.jsx)(s.code,{children:"address"})," const."]}),"\n",(0,t.jsxs)(s.p,{children:["Now just run ",(0,t.jsx)(s.code,{children:"joist-codegen"})," and the ",(0,t.jsx)(s.code,{children:"AuthorCodegen"}),"'s ",(0,t.jsx)(s.code,{children:"address"})," field use the ",(0,t.jsx)(s.code,{children:"Address"})," type."]}),"\n",(0,t.jsx)(s.h3,{id:"current-limitations",children:"Current Limitations"}),"\n",(0,t.jsxs)(s.p,{children:["There are few limitations to Joist's current ",(0,t.jsx)(s.code,{children:"jsonb"})," support:"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Joist currently doesn't support querying / filtering against ",(0,t.jsx)(s.code,{children:"jsonb"})," columns, i.e. in ",(0,t.jsx)(s.code,{children:"EntityManager.find"})," clauses."]}),"\n",(0,t.jsxs)(s.p,{children:["In theory this is doable, but just hasn't been implemented yet; Postgres supports quite a few operations on ",(0,t.jsx)(s.code,{children:"jsonb"})," columns, so it might be somewhat involved. See ",(0,t.jsx)(s.a,{href:"https://github.com/stephenh/joist-ts/issues/230",children:"jsonb filtering support"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["Instead, for now, can you use raw SQL/knex queries and use ",(0,t.jsx)(s.code,{children:"EntityManager.loadFromQuery"})," to turn the low-level ",(0,t.jsx)(s.code,{children:"authors"})," rows into ",(0,t.jsx)(s.code,{children:"Author"})," entities."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:["Joist currently loads all columns for a row (i.e. ",(0,t.jsx)(s.code,{children:"SELECT * FROM authors WHERE id IN (...)"}),"), so if you have particularly large ",(0,t.jsx)(s.code,{children:"jsonb"})," values in an entity's row, then any load of that entity will also return the ",(0,t.jsx)(s.code,{children:"jsonb"})," data."]}),"\n",(0,t.jsxs)(s.p,{children:["Eventually ",(0,t.jsx)(s.a,{href:"https://github.com/stephenh/joist-ts/issues/178",children:"lazy column support"})," should resolve this, and allow marking ",(0,t.jsx)(s.code,{children:"jsonb"})," columns as lazy, such that they would not be automatically fetched with an entity unless explicitly requested as a load hint."]}),"\n"]}),"\n"]})]})}function h(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(a,{...e})}):a(e)}},1670:(e,s,n)=>{n.d(s,{Z:()=>d,a:()=>o});var t=n(7378);const i={},r=t.createContext(i);function o(e){const s=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function d(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:s},e.children)}}}]);