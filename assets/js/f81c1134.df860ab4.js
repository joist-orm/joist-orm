"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"evolution-of-defaults","metadata":{"permalink":"/blog/evolution-of-defaults","source":"@site/blog/2024-11-13-evolution-of-defaults.md","title":"Evolution of Defaults","description":"Joist\'s mission is to model your application\'s business logic, with first-class support for domain modeling features & concepts.","date":"2024-11-13T00:00:00.000Z","tags":[],"readingTime":7.365,"hasTruncateMarker":false,"authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png","key":null,"page":null}],"frontMatter":{"title":"Evolution of Defaults","slug":"evolution-of-defaults","authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"tags":[]},"unlisted":false,"nextItem":{"title":"Recursive Relations","permalink":"/blog/recursive-relations"}},"content":"Joist\'s mission is to model your application\'s business logic, with first-class support for domain modeling features & concepts.\\n\\nA great example of this is Joist\'s support for something as simple as default values: for example, the `Author.status` field should default to `Active`.\\n\\nJoist\'s default values support grew from \\"the simplest thing possible\\" (requiring adhoc patterns that engineers would copy/paste around) to a robust, first-class feature (an explicit `setDefault` API that \\"just works\\").\\n\\nThis is a microcosm of Joist\'s goal to identify the repeated patterns and pain points involved in \\"building a domain model\\", and provide elegant features with a great DX.\\n\\n### Version 1. Schema Defaults\\n\\nJoist\'s initial defaults support was purposefully \\"as simple as possible\\", and limited to `DEFAULT`s declared in the database schema, i.e. an `is_archived` field that defaults to `FALSE`, or a `status_id` that defaults to `DRAFT`:\\n\\n```sql\\nCREATE TABLE example_table (\\n    id SERIAL PRIMARY KEY,\\n    is_archived BOOL DEFAULT false,\\n    status_id INTEGER DEFAULT 1,\\n);\\n```\\n\\nJoist\'s codegen would recognize these, and \\"apply them immediately\\" when creating an entity:\\n\\n```ts\\nconst a = em.create(Author, {});\\nexpect(a.status).toBe(AuthorStatus.Draft); // already Draft\\nexpect(a.isArchived).toBe(false); // already false\\n```\\n\\nThis was super-simple, and had a few pros:\\n\\n* Pro: The `status` is immediately within the `em.create`\\n  - I.e. you don\'t have to wait for an `em.flush` to \\"see the database default\\"\\n  - Any business logic can immediately start using the default\\n* Pro: No duplication of \\"draft is the default\\" between the database schema & TypeScript code\\n* Con: Only supports static, hard-coded values \\n  - Ideally we\'d like to write lambdas to calculate defaults, based on business logic\\n\\n### Version 2. beforeCreate hooks\\n\\nBeing limited to static `DEFAULT` values is not great, so the first way of implementing more complicated \\"dynamic defaults\\" was using Joist\'s `beforeCreate` hooks:\\n\\n```ts\\n/** Any author created w/non-zero amount of books defaults to Published. */\\nauthorConfig.beforeCreate(\\"books\\", a => {\\n  if (a.status === undefined) {\\n    a.status = a.books.get.length > 0 ? AuthorStatus.Published : AuthorStatus.Draft;\\n  }  \\n})\\n```\\n\\nThis was a quick-win b/c Joist already supported `beforeCreate` hooks, but had a few cons:\\n\\n* Pro: Supports arbitrary business logic\\n  - The load hint easily enables cross-entity calculations\\n* Con: The default logic isn\'t ran until `em.flush`\\n  - Harder for business logic to rely on\\n  - Creates inconsistency between \\"hard-coded defaults\\" (applied immediately in `em.create`) and \\"dynamic defaults\\" (applied during `flush`)\\n* Con: Susceptible to hook ordering issues\\n  * If our default\'s value depends on *other* defaults, it is hard to ensure the other \\"runs first\\"\\n* Con: Boilerplate/imperative (not really a first-class feature)\\n  * The code has to 1st check if `a.status` is already set (not a huge deal, but boilerplate)\\n  * There is nothing in the code/API that identifies \\"this is a default\\", instead we just have an adhoc pattern of \\"this is how our app sets defaults\\"\\n* Con: Caused duplication with test factories\\n  * Our test factories often wanted \\"the same defaults\\" applied, but Joist\'s factories are synchronous, which meant any logic that was \\"set in `beforeCreate`\\" wouldn\'t be seen right away.\\n  * To work around this, we often \\"wrote twice\\" default logic across our entities & test factories--not great!\\n\\n### Version 3: Adding setDefault\\n\\nWe lived with the Version 1 & 2 options for several years, because they were \\"good enough\\", but for the 3rd version, we wanted to start \\"setting defaults\\" on the road to being \\"more than just good enough\\".\\n\\nSpecifically, we wanted a first-class, idiomatic way to \\"declaratively specify a field\'s default value\\" instead of the previous \\"manually check the field in a `beforeCreate` hook\\".\\n\\nSo we added `config.setDefault`, which accepts the field name, it\'s dependencies (if any), and a lambda that would calculate the default value:\\n\\n```ts\\n/** Calculate the Author.status default, based on number of books. */\\nauthorConfig.setDefault(\\"status\\", \\"books\\", (a) => {\\n  // a.books.get is available, but a.firstName is not, b/c it\'s not listed as a dependency\\n  return a.books.get.length > 0 ? AuthorStatus.Published : AuthorStatus.Draft;\\n})\\n```\\n\\nThis was a great start, but we pushed it out knowingly half-baked:\\n\\n* Pro: Provided scaffolding of a better future\\n  - Gave an idiomatic way to \\"declare defaults\\"\\n* Pro: The type system enforces that the lambda only calls fields explicitly listed in the dependency param\\n  - This reused our `ReactiveField` infra and is great for ensuring dependencies aren\'t missed\\n* Con: The dependencies weren\'t actually used yet\\n  - \\"...ship early!\\"\\n* Con: `setDefault` lambdas were still not invoked until `em.flush`\\n  * So we still had the \\"write defaults twice\\" problem with test factories \\n\\n### Version 4: Dependency Aware\\n\\nAfter having the `setDefault` API in production for a few months, the next improvement was to capitalize on \\"knowing our dependencies\\" and allow defaults to depend on other defaults.\\n\\nFor example, maybe our `Author.status` default needs to know whether any of the books are published (which itself is a default):\\n\\n```ts\\n// In `Author.ts`\\nauthorConfig.setDefault(\\"status\\", { books: \\"status\\" }, a => {\\n  const anyBookPublished = a.books.get.some(b => b.status === BookStatus.Published);\\n  return anyBookPublished ? AuthorStatus.Published : AuthorStatus.Draft;\\n})\\n\\n// In `Book.ts`\\nbookConfig.setDefault(\\"status\\", {}, b => {\\n  // Some business logic that dynamically determines the status\\n  return BookStatus.Published;\\n});\\n```\\n\\nNow, if both a `Book` and an `Author` are created at the same time, `em.flush` will ensure that the `Book.status` is calculated before invoking the `Author.status` default--_we\'ve solved our ordering issue!_\\n\\nThis was a major accomplishment--cross-entity defaults had been a thorn in our side for years.\\n\\n(Fwiw we readily admit this is a rare/obscure need--in our domain model of 100s of entities, we have only ~2-3 of these \\"cross-entity defaults\\", so we want to be clear this is not necessarily a \\"must have\\" feature--but, when you need it, it\'s extremely nice to have!)\\n\\n* Pro: Finally unlocked cross-entity defaults\\n* Con: Still have the \\"write defaults twice\\" problem with factories\\n\\n### Version 5: Teaching Factories!\\n\\nThe next DX iteration was solving the duplication of \\"factories want the defaults too!\\".\\n\\nLooking more closely at this issue, Joist\'s test factories are synchronous, which means we can create test data easily without any `await`s:\\n\\n```ts\\n// Given an author\\nconst a = newAuthor(em);\\n// And a book \\nconst b = newBook(em, { author: a });\\n// And setup something else using b.title\\n// ...if there is \\"default title logic\\", it will not have ran yet, which\\n// can be confusing for tests/other logic expecting that behavior \\nconsole.log(b.title);\\n```\\n\\nThe lack of `await`s is very nice! But it does mean, if we really wanted `b.title` to *immediately* reflect its production default, we had recode the default logic into the `newBook` factory:\\n\\n```ts\\nexport function newBook(em: EntityManager): DeepNew<Book> {\\n  return newTestInstance(em, Book, {\\n    title: \\"recode the Book default logic here\\",\\n  });\\n}\\n```\\n\\nAs before, for a while this was \\"good enough\\"--but finally in this iteration, we taught the factories to leverage their \\"each test\'s data is already in memory\\" advantage and just invoke the defaults immediately during the `newTestInstance` calls.\\n\\nThis works even for `setDefault`s that use load hints, like \\"author status depends on its books\\":\\n\\n```ts\\n// In `Author.ts`\\nauthorConfig.setDefault(\\"status\\", { books: \\"status\\" }, a => {\\n  const anyBookPublished = a.books.get.some(b => b.status === BookStatus.Published);\\n  return anyBookPublished ? AuthorStatus.Published : AuthorStatus.Draft;\\n})\\n```\\n\\nIn production, Joist can\'t assume \\"the author\'s books are already in-memory\\", so `em.flush` would first load / `await` for the `a.books` to be loaded, and then invoke the lambda.\\n\\nHowever, because our tests know that `a.books` is already in memory, they can skip this `await`, and immediately invoke the lambda.\\n\\n* Pro: We finally can remove the factory\'s \\"write it twice\\" defaults\\n\\n### Version Next: findOrCreates\\n\\nAlways looking ahead, the next itch we have is that, currently, default lambdas that call async methods like `em.find` or `em.findOrCreate` are still skipped during `newTestInstance` and only run during `em.flush`.\\n\\nWhich means, for these defaults, we still have remnants of the \\"write it twice\\" defaults anti-pattern--albeit very few of them!\\n\\nWe should be able to lift this restriction as well, with a little bit of work (...maybe :thinking:, the `newBook` call is fundamentally synchronous, so maybe not).\\n\\n## Slow Grind to Perfection\\n\\nWrapping up, besides a \\"walk down memory lane\\", the larger point of this post is highlighting Joist\'s journey of continually grinding on DX polish--we\'re about five years into [Joel\'s Good Software Takes 10 Years](https://www.joelonsoftware.com/2001/07/21/good-software-takes-ten-years-get-used-to-it/), so only another 5 to go! :smile:\\n\\nOf course, it\'d be great for this evolution to happen more quickly--i.e. if we had a dependency-aware, factory-aware, amazing `setDefault` API from day one.\\n\\nBut, often times jumping to an abstraction can be premature, and result in a rushed design--so sometimes it doesn\'t hurt to \\"sit with the itch\\" for a little while, evolve it through multiple iterations of \\"good enough\\", until finally a pleasant/robust solution emerges.\\n\\nAnd, perhaps most pragmatically, small iterations helps spread the implementation out over enough hack days that it can actually get shipped. :ship:"},{"id":"recursive-relations","metadata":{"permalink":"/blog/recursive-relations","source":"@site/blog/2024-07-20-recursive-relations.md","title":"Recursive Relations","description":"Joist\'s development is currently very incremental, and doesn\'t have \\"big release\\" milestones & release notes, but we recently released a notable new featuretada:","date":"2024-07-20T00:00:00.000Z","tags":[],"readingTime":0.145,"hasTruncateMarker":false,"authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png","key":null,"page":null}],"frontMatter":{"title":"Recursive Relations","slug":"recursive-relations","authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"tags":[]},"unlisted":false,"prevItem":{"title":"Evolution of Defaults","permalink":"/blog/evolution-of-defaults"},"nextItem":{"title":"Is Joist the Best ORM, Ever?","permalink":"/blog/the-best-orm-ever"}},"content":"Joist\'s development is currently very incremental, and doesn\'t have \\"big release\\" milestones & release notes, but we recently released a notable new feature: [recursive relations](/docs/advanced/recursive-relations). Check them out! :tada:"},{"id":"the-best-orm-ever","metadata":{"permalink":"/blog/the-best-orm-ever","source":"@site/blog/2024-05-11-best-orm-ever.md","title":"Is Joist the Best ORM, Ever?","description":"A thought experiment on whether Joist is the best ORM ever.","date":"2024-05-11T00:00:00.000Z","tags":[],"readingTime":9.585,"hasTruncateMarker":false,"authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png","key":null,"page":null}],"frontMatter":{"title":"Is Joist the Best ORM, Ever?","description":"A thought experiment on whether Joist is the best ORM ever.","slug":"the-best-orm-ever","authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"tags":[]},"unlisted":false,"prevItem":{"title":"Recursive Relations","permalink":"/blog/recursive-relations"},"nextItem":{"title":"New NextJS Sample App","permalink":"/blog/nextjs-sample-app"}},"content":"I\'ve been working on the Joist docs lately, specifically a [Why Joist?](/docs/why-joist) page, which ended up focusing more on \\"why Domain Models?\\" than a feature-by-feature description of Joist.\\n\\nWhich is fine, but a good friend (and early Joist user) proofread it, and afterward challenged me that I was being too humble, and I should be more assertive about Joist being \\"THE BEST ORM FOR TYPESCRIPT AND POSTGRES\\" (his words), as he listed off his own personal highlights:\\n\\n1. If it compiles, it works. \\"If you love TypeScript, you\'ll love Joist.\\"\\n2. It\'s \\"really effing fast\\" ([no N+1s](/docs/goals/avoiding-n-plus-1s), ever).\\n3. We solve many common problems for you ([auto-batching updates](/docs/features/entity-manager#auto-batch-updates), handling the insertion order of related entities, and have many patterns for [enums](/docs/modeling/enum-tables), [polymorphic relations](/docs/modeling/relations#polymorphic-references), etc.)\\n4. [Factories](/docs/testing/test-factories) make testing amazing.\\n\\nAll of these are true.\\n\\nBut in thinking about his challenge, of pitching Joist specifically as \\"the best ORM for TypeScript & Postgres\\", I actually think I can be even more bullish and assert Joist is, currently, **the best ORM, in any language, ever, TypeScript or otherwise**.\\n\\nWhich is crazy, right? How could I possibly assert this?\\n\\nI have three reasons; admittedly the first two are not technically unique to Joist, but both foundational to its design and implementation, and the third that is one of Joist\'s \\"special sauces\\":\\n\\n1. JavaScript\'s ability to solve N+1s via the event loop, and\\n2. TypeScript\'s ability to model loaded-ness in its type system.\\n3. Joist\'s \\"backend reactivity\\"\\n\\n## No N+1s: JavaScript\'s Event Loop\\n\\nI\'ve used many ORMs over the years, going back to Java\'s Hibernate, Ruby\'s ActiveRecord, and a few bespoke ones in between.\\n\\nInvariably, they all suffer from N+1s.\\n\\nI don\'t want to repeat Joist\'s existing [Avoiding N+1s](/docs/goals/avoiding-n-plus-1s) docs, but basically \\"entities are objects with fields/methods that incrementally lazy-load their relations from the database\\" is almost \\"too ergonomic\\", and tempts programmers into using the abstraction when they shouldn\'t (i.e. in a loop), at which point N+1s are inevitable.\\n\\nAgain as described in \\"Avoiding N+1s\\", JavaScript\'s event loop forcing all I/O calls to \\"wait just a sec\\", until the end of the event loop tick, gives Joist an amazing opportunity, of course via [dataloader](https://github.com/graphql/dataloader), to de-dupe all the N+1s into a single SQL call.\\n\\nFor everything.\\n\\nThis works so well, that personally **I don\'t know that I ever want to work in a programming language/tech stack that cannot use this trick** (at least to build backend/line-of-business applications).\\n\\nGranted, JavaScript is not the only language with an event loop--async Rust is a thing, Python has asyncio, and even [Vert.x](https://vertx.io/) on the JVM provides it (I prototyped \\"dataloader ported to Vert.x\\" several years ago), and either Rust or the JVM (Scala!) would be pretty tempting just in terms of \\"faster than JavaScript\\" performance.\\n\\nBut the event loop is only part of the story--another critical part is TypeScript\'s type system.\\n\\n:::info\\n\\nOther TypeScript ORMs like Prisma & Drizzle \\"solve\\" N+1s by just not modeling your domain as entities (with lazy-loaded relations), and instead force/assume a single/large up-front query that returns an immutable tree of POJOs.\\n\\nThis does remove the most obvious N+1 footgun (lazy-loaded relations), but it also fundamentally restricts your ability to decompose business logic into smaller/reusable methods, because now any logic that touches the database must be done \\"in bulk\\" directly by your code, and often crafted in SQL specifically to how each individual endpoint is accessing the data.\\n\\n(Concretely, if you had a `saveAuthor` endpoint with logic/queries to validate \\"this author is valid\\", and now write a batch `saveAuthors` endpoint, you could not reuse the \\"written for one entity\\" logic without rewriting it to work at the new endpoint\'s grouped/batch level of granularity. Or similar for `saveBook` logic that you want to use within a `saveAuthor` that also upserts multiple children books.)\\n\\nInstead, Joist\'s auto-batching lets you ergonomically write code at the individual entity abstraction level (whether in a loop, or in per-entity validation rules or lifecycle hooks), but still get performant-by-default batched queries.\\n\\n:::\\n\\n## Loaded Subgraphs: TypeScript\'s Type System\\n\\nAfter solving N+1s with the event loop, the next biggest ergonomic problem in traditional, entity-based ORMs is tracking (or basically not tracking) loaded-ness in the type system.\\n\\nBecause you can\'t have your entire relational database in memory, domain models must incrementally load their data from the database, as your business logic\'s codepaths decide which parts they need to read.\\n\\nThis was another downfall of the Hibernate/ActiveRecord ORMs: there was no notion of \\"is this relation loaded yet?\\", and so any random relation access could trigger the surprise of an expensive database I/O call, as that relation was lazy-loaded from the database.\\n\\nJoist solves this by [statically typing all relations](/docs/goals/load-safe-relations) as \\"unloaded\\" by default, i.e. accessing an Author\'s books requires calling `a1.books.load()`, which returns a `Promise` (which is also key to the N+1 prevention above).\\n\\nWhich is great, I/O calls are now obvious, but \\"do an `await` for every relation access\\" would really suck (we tried that), so Joist goes further and uses TypeScript\'s type system to not only track individual relation loaded-ness (like `author1.books` or `book2.authors`), but mark **entire subgraphs** of entities as populated/loaded relations and hence synchronously accessible:\\n\\n```ts\\n// Load the Author plus the specific books + reviews subgrpah\\nconst a1 = await em.load(Author, \\"a:1\\", {\\n  populate: { books: { reviews: \\"comments\\" } },\\n});\\n\\n// a1 is typed as Loaded<Author, { books: { reviews: \\"comments\\" } }>\\n// Tada, no more await Promise.all\\na1.books.get.forEach((book) => {\\n  book.reviews.get.forEach((review) => {\\n    console.log(review.comments.get.length);\\n  });\\n})\\n```\\n\\nThis combination of:\\n\\n* Explicit `.load()` / `await` calls for any I/O, but leveraging\\n* Mapped types to allow compiler-checked __synchronous__ access\\n\\nFor me, is also something that **I never want to work without again**. It\'s just so nice.\\n\\nUnlike JavaScript not having a monopoly on the event loop, for these mapped types I believe TypeScript effectively does have a lock on this capability, from a programming language/type system perspective.\\n\\nCreating \\"new types\\" in other programming languages is generally handled by macros (Scala and Rust), or I suppose Haskell\'s higher-kinded-types. But, as far as I know, none of them can combine TypeScript \\"mapped type + conditional type\\" features in a way that would allow this \\"take my user-defined type (Author)\\" and \\"this user-defined populate hint type\\" and fuse them together into a new type, that is \\"the author with this specific subgraph of fields marked as loaded\\". \\n\\nI\'m happy to be corrected on this, but I think TypeScript is the only mainstream programming language that can really power Joist\'s `Loaded<Author, { books: \\"reviews\\" }>`-style adhoc typing of subgraphs, or at least this easily.\\n\\n:::info\\n\\nOther TypeScript ORMs (Prisma, Drizzle, Kysley, etc.) also leverage TypeScript\'s mapped types to create dynamic shapes of data, which is legitimately great.\\n\\nHowever, they all have the fundamental approach of issuing \\"one-shot\\" queries that return immutable trees of POJOs, directly mapped from your SQL tables, and not subgraphs of entities that can have non-SQL abstractions & be further incrementally loaded as/if needed (see [Why Joist](/docs/why-joist) for more on this).\\n\\nYou can generally see, for both issues covered so far (N+1s and statically-typed loaded-ness), most TypeScript ORMs have \\"solved\\" these issues by just removing the features all together, and restricting themselves to be \\"sophisticated query builders\\".\\n\\nJoist\'s innovation is keeping the entity-based, incremental-loading mental model that is historically very popular/idiomatic for ORMs (particularly Ruby\'s ActiveRecord), and just fundamentally fixing it to not suck.\\n\\n:::\\n\\n## Joist\'s Backend Reactivity\\n\\nThis 3rd section is the first feature that is unique to Joist itself: Joist\'s \\"backend reactivity\\".\\n\\nMany ORMs have lifecycle hooks (this entity was created, updated, or deleted--which Joist [does as well](/docs/modeling/lifecycle-hooks)), to organize side effects/business logic of \\"when X changes, do Y\\".\\n\\nBut just lifecycle hooks by themselves can become tangled, complicated, and a well-known morass of complexity and \\"spooky action at a distance\\".\\n\\nThis is because they\'re basically \\"Web 1.0\\" imperative spaghetti code, where you have to manually instrument each mutation that might trigger a side effect.\\n\\n(Concretely, lets say you have a rule that needs to look at both an author and its books. With raw lifecycle hooks, you must separately instrument both the \\"author update\\" and \\"book update\\" hooks to call your \\"make sure this author + books combination is still valid\\" logic. This can become tedious and error-prone, to get all the right hooks instrumented.)\\n\\nInstead, Joist\'s [reactive fields](/docs/modeling/reactive-fields) and [reactive validation rules](/docs/modeling/validation-rules)  take the lessons of \\"declarative reactivity\\" from the Mobx/Solid/reactivity-aware frontend world, and bring it to the backend: reactive rules & fields declare in one place what their \\"upstream dependencies\\" are, and Joist just handles wiring up the necessary cross-entity reactivity.\\n\\nThis brings a level of ease, specificity, and rigor to what are still effectively lifecycle hooks under the hood, that really makes them pleasant to work with.\\n\\n:::info\\n\\nThe declarative nature of Joist\'s domain model-wide reactivity graph is also very amenable to DX tooling & documentation generation, but we\'ve not yet deeply explored/delivered any functionality that leverages it.\\n\\n:::\\n\\n## Conclusion: Best ORM Ever?\\n\\nSo, these three features are what back up my exaggerated \\"best ORM ever\\" assertion.\\n\\nIf tomorrow, I suddenly could not use Joist, and had to find another ORM to use (or, in general, build any sort of application backend on top of a relational database), in any current/mainstream programming language, without a doubt I would want:\\n\\n1. Bullet-proof N+1 prevention,\\n2. Tracking loaded relation/subgraph state in the type system, and\\n3. Backend reactivity, for declarative cross-entity validation rules and reactive fields.\\n\\nAnd Joist is the only ORM that does all three of these: two of which are uniquely enabled by the JavaScript/TypeScript stack, and the third just part of Joist\'s own innovation.\\n\\n## Disclaimer 1: Uncomfortably Bold Claims\\n\\nI usually don\'t like making bold/absolutist claims, like \\"this or that framework is \'the best\'\\" or \\"technology x/y/z is terrible\\" or what not.\\n\\nI did enough of that early in my career, and at this point I\'m more interested in \\"what are the trade-offs?\\" and \\"what\'s the best tool for this specific use case?\\"\\n\\nSo, I hold two somewhat incongruent thoughts in my head, as I am both:\\n\\n- Very confident that Joist is \\"the best\\" way to build application backends on top of a relational database, for a large majority of use cases/teams/codebases, but I also\\n- Recognize it\'s \\"framework\\" / entity approach (see [Why Joist](/docs/why-joist)) might be either too opinionated or too much abstraction for some people\'s tastes, and just in general choices & alternatives are always great to have.\\n\\nMy guess is if you tried Joist, you would quickly come to like it, but it\'s also perfectly fine if not!\\n\\n## Disclaimer 2: Still a Lot To Do\\n\\nSimilar to the two incongruent thoughts above, another two semi-contradictory thoughts is the disclaimer that:\\n\\n- Joist\'s core is very solid and vetted by 4+ years of production usage & continual iteration at [Homebound](https://www.homebound.com/), but also\\n- There\'s still a lot of work to do, obviously supporting other databases, but also the myriad fun, incremental improvement ideas we\'re tracking in the issue tracker, and of course even more that we\'ve not thought of yet.\\n\\n## Feedback\\n\\nIf you have thoughts, questions, or feedback, please let us know! Feel free to join the [Joist discord](https://discord.gg/ky9VTQugqu), or file issues on the GitHub repo if you try Joist and run into any issues.\\n\\nDespite all the hubris in this post, we are still a very small project & community, and so have a lot of growth and improvement ahead of us.\\n\\nThanks for the read!"},{"id":"nextjs-sample-app","metadata":{"permalink":"/blog/nextjs-sample-app","source":"@site/blog/2024-04-21-nextjs-sample.md","title":"New NextJS Sample App","description":"We\'ve added a new NextJS sample app to the Joist repository.","date":"2024-04-21T00:00:00.000Z","tags":[],"readingTime":6.67,"hasTruncateMarker":false,"authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png","key":null,"page":null}],"frontMatter":{"title":"New NextJS Sample App","description":"We\'ve added a new NextJS sample app to the Joist repository.","slug":"nextjs-sample-app","authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"tags":[]},"unlisted":false,"prevItem":{"title":"Is Joist the Best ORM, Ever?","permalink":"/blog/the-best-orm-ever"},"nextItem":{"title":"Welcome","permalink":"/blog/welcome-blog"}},"content":"We\'ve added a new [NextJS + Joist](https://github.com/joist-orm/joist-nextjs-sample/) sample app that shows how Joist can be used in a NextJS application, with several benefits:\\n\\n- Automatic N+1 Prevention\\n- JSON Payload/Props Creation\\n- Optional Join-based Preloading\\n\\nThis post gives a short overview; if you\'d like to watch a video, we also have a [YouTube video](https://youtu.be/H_qJdKUS9D0) that walks through the sample app.\\n\\n<div style={{ display: \'grid\', placeItems: \'center\' }}>\\n  <iframe width=\\"750\\" height=\\"420\\" src=\\"https://www.youtube.com/embed/H_qJdKUS9D0?si=qUiRr0GTMrQCgayC\\" title=\\"YouTube video player\\" frameborder=\\"0\\" allow=\\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\\" referrerpolicy=\\"strict-origin-when-cross-origin\\" allowfullscreen></iframe>\\n</div>\\n\\n## Two Render Tree Approaches\\n\\nWhile building the sample app, we found two fundamental ways of structuring a NextJS app\'s render tree:\\n\\n1. Fewer React Server Components, that prop drill data to the Client Components\\n   - Shown on the left, see `author-rcc-card.tsx` and `book-rcc-preview.tsx`\\n2. Mostly React Server Components, with Client Components only at the bottom\\n   - Shown on the right, see `author-rsc-card.tsx` and `book-rsc-preview.tsx`\\n\\n<div style={{ padding: \'24px\' }}>\\n  <img src=\\"/images/nextjs-sample-single-multiple-rscs.png\\" />\\n</div>\\n\\nThe top-level `Table` / `table.tsx` component renders each of these side-by-side, so we can see the differences, and observe some pros/cons of each approach.\\n\\n- With mostly RSC components, it\'s easy to decompose data loading away from the top-level component.\\n\\n  For example, the `AuthorRscCard` can make its own data loading calls, and even if it\'s render many pages on the page, Joist will de-dupe across the `N` sibling `AuthorRscCard`s, and batch into a single SQL call.\\n\\n  ```tsx\\n  type AuthorCardProps = {\\n    /** RSCs can accept the domain model enities as a prop. */\\n    author: Author;\\n    addBook: (id: string) => Promise<void>;\\n  };\\n\\n  /** The RSC version of AuthorCard can load it\'s own data. */\\n  export async function AuthorRscCard({ author, addBook }: AuthorCardProps) {\\n    // This will be auto-batched if many cards render at once\\n    const books = await author.books.load();\\n    // Or if you wanted a tree of data, this will also be auto-batched\\n    const loaded = await author.populate({ books: { reviews: \\"ratings\\" } });\\n    return <div>...jsx</div>;\\n  }\\n  ```\\n\\n  This is nice because it allows the `AuthorRscCard` to be more self-sufficient, and allow the parent table component to be unaware of its children loading details.\\n\\n- With mostly Client components, the opposite happens, and only the parent can make database / `EntityManager` calls, and so is responsible for loading all the data for its children, and passing it as JSON via props:\\n\\n  ```tsx\\n  type AuthorCardProps = {\\n    /** RCCs must accept a POJO of `Author` + all nested data. */\\n    author: AuthorPayload;\\n    addBook: (id: string) => Promise<void>;\\n  };\\n\\n  /** The RCC version of AuthorCard accepts the `AuthorPayload`. */\\n  export function AuthorRccCard({ author, addBook }: AuthorCardProps) {\\n    // can only use data already available on `author` \\n  }\\n  ```\\n\\n  Even though the up-front data load can become awkward, it does give more opportunities for optimizations; for example Joist can use join-based preloading to load a single tree of `Author` + `Book` + `Review` entities in a single SQL call, which is even better optimization than the \\"one query per layer\\" N+1 prevention of the RSC-based approach.\\n\\n## Automatic N+1 Prevention\\n\\nIn either approach, Joist\'s N+1 prevention auto-batches database calls, even if they are made across separate component renders. I.e. in the RSC components:\\n\\n- The top-level `Table` component makes 1 SQL call for all `Author` entities.\\n- All 2nd-level `AuthorRscCard` cards each make their own `author.books.load()` (or `author.populate(...)`) call, but because they\'re all rendered in the same event loop, Joist batches all the `load` calls into 1 SQL call\\n- Any 3rd-level components would have their `load` calls batched as well.\\n\\nIn the React Client Component approach, this auto-batching is admittedly not as necessary, assuming a singular top-level component, like `Table`, loads all the data at once anyway (although, as mentioned later, Joist can optimize that as well).\\n\\nSee the [Avoiding N+1s](/docs/goals/avoiding-n-plus-1s) section of our docs for more information.\\n\\n## JSON Payload/Props Creation\\n\\nSince the client components cannot make their own async data calls, the top-level `Table` components is responsible for loading all the data into a JSON payload, and passing it down to the children as props.\\n\\nJoist entities have an easy way of doing this is, via a `toJSON` method that takes the shape of data to create:\\n\\n```ts\\n// Define the shape of data to create\\nexport const authorHint = {\\n  id: true,\\n  firstName: true,\\n  books: {\\n    id: true,\\n    title: true,\\n    reviews: [\\"id\\", \\"rating\\"],\\n  },\\n  customField: (a) => a.id + a.title,\\n} satisfies JsonHint<Author>;\\n\\n// This typedef can be used in the client-side props, or to match any\\n// endpoint-based respones types like for REST/OpenAPI.\\nexport type AuthorPayload = JsonPayload<Author, typeof authorHint>;\\n\\nconst payload = await a.toJSON(authorHint);\\n```\\n\\nThe `toJSON` implementation will:\\n\\n- Load any relations that are not yet loaded from the database\\n- Output only the keys that are requested in the `authorHint`\\n- Call any lambdas like `customField` to generate custom values\\n\\nAs with previous examples, all data loading is N+1 safe, and also potentially join-based preloaded.\\n\\nSee the [toJSON](/docs/advanced/json-payloads) docs for more information.\\n\\n:::info\\n\\nThis recursive `toJSON` payload generation is a relatively new feature of Joist, so if you have feature ideas that would make it more useful, please let us know!\\n\\n:::\\n\\n## Join-Based Preloading\\n\\nThe last optimization that Joist can do is join-based preloading, which can be used in either the RSC or RCC approach.\\n\\nThis is also a newer feature that requires opt-ing in to, but in `em.ts` you can add a `preloadPlugin`:\\n\\n```ts\\n/** Returns this request\'s `EntityManager` instance. */\\nexport const getEm = cache(() => {\\n  // Opt-in to preloading\\n  const preloadPlugin = new JsonAggregatePreloader();\\n  return new EntityManager({}, { driver, preloadPlugin });\\n});\\n```\\n\\nThis will allow Joist to load a deep tree/subgraph of entities in a single SQL call.\\n\\nFor example, normally a Joist `em.find` a call like:\\n\\n```ts\\nconst a = await em.find(\\n  Author,\\n  { id: 1 },\\n  {populate: { books: \\"reviews\\" } },\\n);\\n// Now access all the data in memory\\nconsole.log(a.books.get[0].reviews.get[0].rating)\\n```\\n\\nWill issue three SQL calls:\\n\\n```sql\\nSELECT * FROM authors WHERE id = 1;\\nSELECT * FROM books WHERE author_id = 1;\\nSELECT * FROM reviews WHERE book_id IN (1, 2, 3, ...);\\n```\\n\\nBut with the `preloadPlugin` enabled, it will use a single SQL call that uses `CROSS JOIN LATERAL` and `json_agg` to return the author\'s books, and the book\'s reviews (omitted for brevity) in a single row:\\n\\n```sql\\nselect a.id, _b._ as _b from authors as a\\n  cross join lateral\\n    -- create a tuple for each book, and aggregate then into an array of books\\n    select json_agg(json_build_array(_b.id, _b.title, _b.foreword, _b.author_id) order by _b.id) as _\\n    from books _b\\n    where _b.author_id = a.id\\n  ) _b\\n  where a.id = ? limit ?\\n```\\n\\n:::info\\n\\nJoist\'s join-based preloading is still a beta feature, so if you run into any issues, please let us know!\\n\\n:::\\n\\n## What about Complex Queries?\\n\\nSo far, our queries have focused on loading \\"just entities\\", and then putting those on the wire (or rendering them to HTML).\\n\\nThis is because Joist\'s focus is on building robust domain models, and specifically helping solve the \\"write-side\\" of your application\'s business logic (running the correct [validation rules](/docs/modeling/validation-rules), [lifecycle hooks](/docs/modeling/lifecycle-hooks), [reactive updates](/docs/modeling/reactive-fields)), and less so on the \\"read-side\\" of complex queries (i.e. that using aggregates using `GROUP BY`, multiple nested subqueries/projections/etc.).\\n\\nAs such, Joist does not yet have a sophisticated query builder that can create arbitrary SQL queries, like Kysley or Drizzle.\\n\\nInstead, Joist encourages an approach that uses its robust write-side features to create materialized columns in the database, such that the majority of your pages/responses really can be served by \\"super simple `SELECT` statements\\", instead of using complicated queries to calculate aggregates on-the-fly.\\n\\nAlthough you can of course use both approaches, and just use a lower-level query builder where needed.\\n\\n## Sample App Feedback\\n\\nJoist\'s roots come from the GraphQL world, so this sample app was our first foray into using it for a NextJS application. If we\'ve missed any key features that would make it easier to use Joist in a NextJS app, please let us know!"},{"id":"welcome-blog","metadata":{"permalink":"/blog/welcome-blog","source":"@site/blog/2024-04-13-first-post.md","title":"Welcome","description":"First post on the Joist blog.","date":"2024-04-13T00:00:00.000Z","tags":[],"readingTime":0.09,"hasTruncateMarker":false,"authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png","key":null,"page":null}],"frontMatter":{"title":"Welcome","description":"First post on the Joist blog.","slug":"welcome-blog","authors":[{"name":"Stephen Haberman","url":"https://github.com/stephenh","image_url":"https://github.com/stephenh.png","imageURL":"https://github.com/stephenh.png"}],"tags":[]},"unlisted":false,"prevItem":{"title":"New NextJS Sample App","permalink":"/blog/nextjs-sample-app"}},"content":"Hello! This is just a \\"Hello World\\" post to show the Joist blog, using [**Docusaurus**](https://docusaurus.io/), is working :tada:."}]}}')}}]);