"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[141],{5789:(e,o,s)=>{s.r(o),s.d(o,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var n=s(4246),t=s(1670);const i={title:"Lifecycle Hooks",sidebar_position:4},a=void 0,r={id:"modeling/lifecycle-hooks",title:"Lifecycle Hooks",description:'Joist supports hooks that can run business logic at varies stages in an entity\'s lifecycle, for example to implement business logic like "when an Author entity is updated, always do x/y/z".',source:"@site/docs/modeling/lifecycle-hooks.md",sourceDirName:"modeling",slug:"/modeling/lifecycle-hooks",permalink:"/docs/modeling/lifecycle-hooks",draft:!1,unlisted:!1,editUrl:"https://github.com/joist-orm/joist-orm/edit/main/docs/docs/modeling/lifecycle-hooks.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Lifecycle Hooks",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Validation Rules",permalink:"/docs/modeling/validation-rules"},next:{title:"Enums",permalink:"/docs/modeling/enum-tables"}},l={},d=[{value:"Setup",id:"setup",level:3},{value:"Available Hooks",id:"available-hooks",level:3},{value:"Allowed Behavior",id:"allowed-behavior",level:3},{value:"Wire Calls",id:"wire-calls",level:4},{value:"Hooks vs. Validation Rules",id:"hooks-vs-validation-rules",level:3}];function c(e){const o={a:"a",admonition:"admonition",code:"code",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,t.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(o.p,{children:["Joist supports hooks that can run business logic at varies stages in an entity's lifecycle, for example to implement business logic like \"when an ",(0,n.jsx)(o.code,{children:"Author"}),' entity is updated, always do x/y/z".']}),"\n",(0,n.jsxs)(o.p,{children:["Hooks are not immediately ran on ",(0,n.jsx)(o.code,{children:"em.create"})," or entity modifications, and only run as part of ",(0,n.jsx)(o.code,{children:"em.flush()"})," because ",(0,n.jsx)(o.code,{children:"em.flush()"})," is an async method, and this allows hooks to themselves have async behavior, i.e. load additional entities from the database."]}),"\n",(0,n.jsx)(o.h3,{id:"setup",children:"Setup"}),"\n",(0,n.jsxs)(o.p,{children:["All hooks are set up by the entity's ",(0,n.jsx)(o.code,{children:"config"})," API:"]}),"\n",(0,n.jsx)(o.pre,{children:(0,n.jsx)(o.code,{className:"language-typescript",children:'import { authorConfig as config } from "./entities";\n\nexport class Author extends AuthorCodegen {}\n\n// Create a draft book for all authors\nconfig.beforeCreate("books", (a, { em }) => {\n  if (a.books.get.length === 0) {\n    em.create(Book, { author: a, status: BookStatus.Draft });\n  }\n});\n'})}),"\n",(0,n.jsxs)(o.admonition,{type:"info",children:[(0,n.jsx)(o.p,{children:"At first, it seems odd that Joist's hooks are not methods on the class itself, as this would be a more traditional place for ORM-driven business logic."}),(0,n.jsxs)(o.p,{children:["However, being added via the ",(0,n.jsx)(o.code,{children:"config"})," API has a few benefits:"]}),(0,n.jsxs)(o.ol,{children:["\n",(0,n.jsxs)(o.li,{children:["\n",(0,n.jsxs)(o.p,{children:["The hook methods all take load hints, i.e. ",(0,n.jsx)(o.code,{children:'"books"'})," in the above ",(0,n.jsx)(o.code,{children:"beforeCreate"})," example, which makes the ",(0,n.jsx)(o.code,{children:"a"})," param typed as ",(0,n.jsx)(o.code,{children:'Loaded<Author, "books">'})," instead of ",(0,n.jsx)(o.code,{children:"Author"}),"."]}),"\n",(0,n.jsxs)(o.p,{children:["This allows the hook's business logic to be written with as few ",(0,n.jsx)(o.code,{children:"await"}),"s as possible, such that ideally the lambda itself can be synchronous (although you can make it ",(0,n.jsx)(o.code,{children:"async"})," if necessary)."]}),"\n",(0,n.jsxs)(o.p,{children:["If ",(0,n.jsx)(o.code,{children:"beforeCreate"})," was written as a method, then an additional local variable (similar to ",(0,n.jsx)(o.code,{children:"a"}),") would need to be created, as ",(0,n.jsx)(o.code,{children:"this"})," is not aware of the hook's load hint."]}),"\n"]}),"\n",(0,n.jsxs)(o.li,{children:["\n",(0,n.jsxs)(o.p,{children:["It's easier to keep business logic small & decoupled, because if you have multiple operations to perform on ",(0,n.jsx)(o.code,{children:"beforeCreate"}),", you can have two entirely separate hooks, each with separate load hints and their own lambdas."]}),"\n",(0,n.jsxs)(o.p,{children:["If ",(0,n.jsx)(o.code,{children:"beforeCreate"})," was a single ",(0,n.jsx)(o.code,{children:"Author.beforeCreate"})," method, then its implementation would just get bigger and more complex as it handles additional business requirements."]}),"\n"]}),"\n",(0,n.jsxs)(o.li,{children:["\n",(0,n.jsx)(o.p,{children:"It's trivial to reuse hook logic across entities without relying on multiple inheritance."}),"\n",(0,n.jsxs)(o.p,{children:["For example, we could have a method like ",(0,n.jsx)(o.code,{children:"addSoftDeleteHooks(config)"})," that, for any given entity's config, adds some shared business logic to the entity."]}),"\n"]}),"\n"]})]}),"\n",(0,n.jsx)(o.h3,{id:"available-hooks",children:"Available Hooks"}),"\n",(0,n.jsxs)(o.p,{children:["Joist supports the following hooks, listed in the order that they are fired during ",(0,n.jsx)(o.code,{children:"em.flush"}),":"]}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"beforeCreate"})," fired when an entity is created / ",(0,n.jsx)(o.code,{children:"INSERT"}),"-d for the first time"]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"beforeUpdate"})," fired when an entity is updated / ",(0,n.jsx)(o.code,{children:"UPDATE"}),"-d"]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"beforeFlush"})," fired when an entity is either created or updated (but not deleted)"]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"beforeDelete"})," fired when an entity is deleted / ",(0,n.jsx)(o.code,{children:"DELETE"}),"-d"]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"afterValidation"})," fired after an entity is created or updated, and all validation rules have passed"]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"beforeCommit"})," fired when an entity is created, or updated, or deleted and the transaction is about to commit, can abort the transaction by throwing an error"]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"afterCommit"})," fired when an entity is created, or updated, or deleted and the transaction has committed"]}),"\n"]}),"\n",(0,n.jsx)(o.h3,{id:"allowed-behavior",children:"Allowed Behavior"}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.code,{children:"beforeCreate"}),", ",(0,n.jsx)(o.code,{children:"beforeUpdate"}),", ",(0,n.jsx)(o.code,{children:"beforeFlush"}),", and ",(0,n.jsx)(o.code,{children:"beforeDelete"})," hooks are allowed to create/update/delete other entities."]}),"\n",(0,n.jsxs)(o.p,{children:["For example, a new ",(0,n.jsx)(o.code,{children:"Author"})," can use a ",(0,n.jsx)(o.code,{children:"beforeCreate"})," hook to automatically ",(0,n.jsx)(o.code,{children:"em.create"})," the author's first/default ",(0,n.jsx)(o.code,{children:"Book"}),". Or a deleted ",(0,n.jsx)(o.code,{children:"Author"})," could ",(0,n.jsx)(o.code,{children:"em.delete"})," its ",(0,n.jsx)(o.code,{children:"Book"}),"s in an ",(0,n.jsx)(o.code,{children:"Author.beforeDelete"})," hook (Joist also has a dedicated ",(0,n.jsx)(o.code,{children:"config.cascadeDelete"})," API, but ",(0,n.jsx)(o.code,{children:"beforeDelete"})," can handle more custom behavior)."]}),"\n",(0,n.jsx)(o.p,{children:"Any entities that are created/updated/deleted by a hook will themselves have their appropriate hooks ran, although only if those entity's hooks have not already been run (to avoid cycles of a book-touches-author/author-touches-book infinitely recursing)."}),"\n",(0,n.jsxs)(o.p,{children:[(0,n.jsx)(o.code,{children:"afterValidation"}),", ",(0,n.jsx)(o.code,{children:"beforeCommit"}),", and ",(0,n.jsx)(o.code,{children:"afterCommit"})," are not allowed to mutate entities."]}),"\n",(0,n.jsx)(o.h4,{id:"wire-calls",children:"Wire Calls"}),"\n",(0,n.jsx)(o.p,{children:"Making RPC calls to 3rd party systems can be problematic, and so we recommend:"}),"\n",(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsxs)(o.li,{children:["\n",(0,n.jsxs)(o.p,{children:["Do not make RPC calls from any non-",(0,n.jsx)(o.code,{children:"afterCommit"})," hook."]}),"\n",(0,n.jsxs)(o.p,{children:["It is very likely that hooks (like ",(0,n.jsx)(o.code,{children:"beforeFlush"}),") will run, but then your ",(0,n.jsx)(o.code,{children:"em.flush"})," later fails due to validation rules, at which point your transaction/changes won't be committed, and you've likely made an unnecessary/incorrect wire call."]}),"\n"]}),"\n",(0,n.jsxs)(o.li,{children:["\n",(0,n.jsxs)(o.p,{children:["Only pragmatically make wire calls in the ",(0,n.jsx)(o.code,{children:"afterCommit"})," hook."]}),"\n",(0,n.jsxs)(o.p,{children:["While ",(0,n.jsx)(o.code,{children:"afterCommit"}),' is the "safest" place to make a wire call, because it\'s only called after the transaction has been committed, there is still a chance that either a) ',(0,n.jsx)(o.code,{children:"em.flush"})," commits but the machine crashes before running ",(0,n.jsx)(o.code,{children:"afterCommit"}),", or b) your ",(0,n.jsx)(o.code,{children:"afterCommit"})," fails but now will not retry."]}),"\n"]}),"\n"]}),"\n",(0,n.jsxs)(o.p,{children:["Because of these wrinkles, our best advice is to use the ",(0,n.jsx)(o.a,{href:"https://brandur.org/job-drain",children:"job drain"})," pattern, and use a ",(0,n.jsx)(o.code,{children:"beforeCommit"})," hook to transactionally enqueue jobs in your primary database."]}),"\n",(0,n.jsxs)(o.p,{children:["The ",(0,n.jsx)(o.code,{children:"beforeCommit"})," hook runs after entities have been ",(0,n.jsx)(o.code,{children:"INSERT"}),"d or ",(0,n.jsx)(o.code,{children:"UPDATE"}),"d, and so will have access to entity ids, which can be used for background job parameters/payloads."]}),"\n",(0,n.jsxs)(o.p,{children:['These background jobs create "intentions of work to be done", and since the job is atomically saved to the database in the same transaction as your business logic writes (for example inserting a ',(0,n.jsx)(o.code,{children:"sendOnboardingEmail"})," job into the ",(0,n.jsx)(o.code,{children:"jobs"})," table and ",(0,n.jsx)(o.code,{children:"INSERT"}),"ing a new ",(0,n.jsx)(o.code,{children:"authors"})," row), they are both guaranteed to complete or not-complete. And then the background job runner can separately invoke (and retry if necessary) the intended action of calling/syncing with the 3rd party system."]}),"\n",(0,n.jsx)(o.h3,{id:"hooks-vs-validation-rules",children:"Hooks vs. Validation Rules"}),"\n",(0,n.jsx)(o.p,{children:"Hooks run before validation rules, and are allowed to mutate entities that may currently be invalid."}),"\n",(0,n.jsx)(o.p,{children:"Validation rules run after hooks, and are not allowed to mutate entities: they must be side effect free."}),"\n",(0,n.jsxs)(o.p,{children:['For example, you could have a validation rule of "Author must have at least one book", and a hook that "creates a default book for new authors", and when you do ',(0,n.jsx)(o.code,{children:"em.create(Author)"})," without any books, then first the hook would run and create a single book, such that when the validation rule runs, it passes."]}),"\n",(0,n.jsx)(o.p,{children:"Similarly, hooks can set required fields before the missing values trigger validation rules."}),"\n",(0,n.jsxs)(o.p,{children:["Validation rules are only ran once per ",(0,n.jsx)(o.code,{children:"em.flush"}),", and only after all hooks, and all transitively-ran hooks, have finished."]}),"\n",(0,n.jsxs)(o.admonition,{type:"info",children:[(0,n.jsx)(o.p,{children:'The term "transitively-ran" hooks describes the scenario of:'}),(0,n.jsxs)(o.ul,{children:["\n",(0,n.jsxs)(o.li,{children:["An endpoint/user code creates 5 new ",(0,n.jsx)(o.code,{children:"Author"})," entities and calls ",(0,n.jsx)(o.code,{children:"em.flush"})]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"em.flush"}),' "runs hooks" (',(0,n.jsx)(o.code,{children:"beforeCreate"})," and ",(0,n.jsx)(o.code,{children:"beforeFlush"}),") for all 5 new ",(0,n.jsx)(o.code,{children:"Author"}),"s entities"]}),"\n",(0,n.jsxs)(o.li,{children:["Each ",(0,n.jsx)(o.code,{children:"Author"}),"'s ",(0,n.jsx)(o.code,{children:"beforeCreate"})," hook creates a new draft ",(0,n.jsx)(o.code,{children:"Book"})," entity"]}),"\n",(0,n.jsxs)(o.li,{children:[(0,n.jsx)(o.code,{children:"em.flush"})," notices the newly-created ",(0,n.jsx)(o.code,{children:"Book"}),' entities, and so "runs hooks again", but only against the 5 ',(0,n.jsx)(o.code,{children:"Book"})," entities"]}),"\n"]}),(0,n.jsx)(o.p,{children:'So, this process is transitive as mutating the initial set of entities may cause, via custom logic in hooks, a subsequent set of entities to be mutated, which themselves might cause an additional set of entities to be mutated, until the process "settles".'}),(0,n.jsxs)(o.p,{children:["Note that because ",(0,n.jsx)(o.code,{children:"em.flush"})," marks which entities have had hooks ran, and will not invoke hooks twice on a given entity, this process is guaranteed to finish, i.e. there is not a risk of infinite loops between hooks."]})]})]})}function h(e={}){const{wrapper:o}={...(0,t.a)(),...e.components};return o?(0,n.jsx)(o,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},1670:(e,o,s)=>{s.d(o,{Z:()=>r,a:()=>a});var n=s(7378);const t={},i=n.createContext(t);function a(e){const o=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),n.createElement(i.Provider,{value:o},e.children)}}}]);