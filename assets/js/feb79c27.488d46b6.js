"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[483],{5535:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>a});var s=t(4246),o=t(1670);const r={title:"Full Text Search",sidebar_position:35},i=void 0,c={id:"advanced/full-text-search",title:"Full Text Search",description:"Postgres has rich support for full text search functionality, which can be a replacement for more dedicated solutions such as Elasticsearch.",source:"@site/docs/advanced/full-text-search.md",sourceDirName:"advanced",slug:"/advanced/full-text-search",permalink:"/docs/advanced/full-text-search",draft:!1,unlisted:!1,editUrl:"https://github.com/stephen/joist-ts/edit/main/docs/docs/advanced/full-text-search.md",tags:[],version:"current",sidebarPosition:35,frontMatter:{title:"Full Text Search",sidebar_position:35},sidebar:"tutorialSidebar",previous:{title:"Class Table Inheritance",permalink:"/docs/advanced/class-table-inheritance"},next:{title:"graphql-filters",permalink:"/docs/advanced/graphql-filters"}},d={},a=[{value:"Adding Search Index Columns",id:"adding-search-index-columns",level:2},{value:"Configuring the Persisted Field",id:"configuring-the-persisted-field",level:2},{value:"Querying the <code>tsvector</code> type <code>ts_search</code> Column",id:"querying-the-tsvector-type-ts_search-column",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["Postgres has rich support for ",(0,s.jsx)(n.a,{href:"https://www.postgresql.org/docs/current/functions-textsearch.html",children:"full text search functionality"}),", which can be a replacement for more dedicated solutions such as Elasticsearch."]}),"\n",(0,s.jsxs)(n.p,{children:["One of the challenges of implementing a Postgres ",(0,s.jsx)(n.code,{children:"tsvector"})," search index is keeping the index data in sync with changes, especially across tables. Consider a search endpoint for ",(0,s.jsx)(n.code,{children:"Books"}),", in addition to being able to search for the ",(0,s.jsx)(n.code,{children:"Book"})," by ",(0,s.jsx)(n.code,{children:"title"}),", we may also want to search for the ",(0,s.jsx)(n.code,{children:"Book"})," by the related ",(0,s.jsx)(n.code,{children:"Author"})," ",(0,s.jsx)(n.code,{children:"name"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["The conventional approach would be to use triggers to react to updates and keep the index in sync, but Joist can improve on the ergonomics of this approach through the use of ",(0,s.jsx)(n.a,{href:"/docs/modeling/derived-fields",children:"Persisted Derived Fields"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"adding-search-index-columns",children:"Adding Search Index Columns"}),"\n",(0,s.jsx)(n.p,{children:"First, we'll start by creating 2 columns:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["A plain ",(0,s.jsx)(n.code,{children:"text"})," column to derive the search string."]}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"tsvector"})," type ",(0,s.jsx)(n.code,{children:"DERIVED"})," column that will cast our ",(0,s.jsx)(n.code,{children:"text"})," search column ",(0,s.jsx)(n.code,{children:"to_tsvector"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { addColumns } from "joist-migration-utils";\nimport { MigrationBuilder } from "node-pg-migrate";\n\nexport async function up(b: MigrationBuilder): Promise<void> {\n  addColumns(b, "books", { search: { type: "text" }});\n\n  // Then create a "generated" column, allowing postgres to handle the `to_tsvector` word stemming.\n  b.sql(`\n    ALTER TABLE books\n    ADD COLUMN ts_search tsvector\n    GENERATED ALWAYS AS (to_tsvector(\'english\', coalesce(search, \'\'))) STORED;\n\n    CREATE INDEX ts_search_idx ON books USING GIN (ts_search);\n  `);\n}\n'})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsx)(n.p,{children:"Even though two columns looks odd here, so far we've found it to be the best solution that allows both:"}),(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Joist to control the ",(0,s.jsx)(n.code,{children:"search"}),' field, i.e. on both reads & writes be able to see/diff/update "just the plain text" value, while']}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:["Letting Postgres fully control the ",(0,s.jsx)(n.code,{children:"to_tsvector"})," application."]}),"\n"]}),"\n"]})]}),"\n",(0,s.jsx)(n.h2,{id:"configuring-the-persisted-field",children:"Configuring the Persisted Field"}),"\n",(0,s.jsxs)(n.p,{children:["We'll now set up the ",(0,s.jsx)(n.code,{children:"Book.search"})," field as an ",(0,s.jsx)(n.a,{href:"/docs/modeling/derived-fields#asynchronous-persisted-fields",children:"Asynchronous Persisted Derived Field"})," within ",(0,s.jsx)(n.code,{children:"joist-config.json"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "entities": {\n    "Book": {\n      "fields": {\n        "search": { "derived": "async" }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["And then implement our logic in the ",(0,s.jsx)(n.code,{children:"Book"})," domain model. This will keep the values we want indexed for search for the ",(0,s.jsx)(n.code,{children:"Book"})," in sync:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { ReactiveField, hasReactiveField } from "joist-orm";\n\nreadonly search: ReactiveField<Book, string> = hasReactiveField(\n  "search",\n  { author: ["firstName", "lastName"], title: {} },\n  (book) => {\n    const author = book.author.get;\n    return `${book.title} ${author.firstName} ${author.lastName}`\n  },\n);\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"querying-the-tsvector-type-ts_search-column",children:["Querying the ",(0,s.jsx)(n.code,{children:"tsvector"})," type ",(0,s.jsx)(n.code,{children:"ts_search"})," Column"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"// Use the buildQuery method to create a base query to build off of\nconst query = buildQuery(knex, Book, {});\n\n// Use knex raw methods to craft the search query against the `ts_search` generated column \n// and (optionally) sort by the rank\nvoid query\n  .whereRaw(`ts_search @@ plainto_tsquery('english', '${searchTerm}')`)\n  .orderByRaw(`ts_rank(ts_search, plainto_tsquery('english', '${searchTerm}')) DESC`);\n\n// Then load the books for the custom search query\nconst books = await em.loadFromQuery(Book, query);\n"})}),"\n",(0,s.jsxs)(n.admonition,{type:"info",children:[(0,s.jsxs)(n.p,{children:["We're using Knex and ",(0,s.jsx)(n.code,{children:"buildQuery"})," here because, currently, Joist's ",(0,s.jsx)(n.code,{children:"em.find"})," syntax does not support raw query conditions."]}),(0,s.jsxs)(n.p,{children:["See ",(0,s.jsx)(n.a,{href:"https://github.com/stephenh/joist-ts/issues/699",children:"#699"})," which will add support for this."]})]})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>i});var s=t(7378);const o={},r=s.createContext(o);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);