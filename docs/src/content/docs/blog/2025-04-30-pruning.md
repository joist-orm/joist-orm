---
title: Query Pruning for the Win
slug: blog/pruning
date: 2025-05-20
authors: shaberman
tags: []
_excerpt: ...
---

A key feature of ORMs, whether Knex-style query builders or a Joist-style [domain models](https://joist-orm.io/modeling/why-entities/), is issuing queries; specifically the API or "DSL" (domain specific language) to "find rows" in the database.

These can be as simple as raw SQL strings or tagged literals in [postgres.js](https://github.com/porsager/postgres) (not really "an ORM", but for illustration purposes):

```ts
const rows = await sql`SELECT * FROM users WHERE name = ${name}`;
```

To fluent "incrementally build SQL strings via method chaining" APIs like Knex or Kysely:

```ts
// Knex
await knex("users").where("name", "=", name);
// Kysely
await db.selectFrom('users').where('name', '=', name).execute();
// Drizzle
await db.select().from(users).where(eq(users.name, name));
```

To Joist's own `em.find`:

```ts
const authors = await em.find(User, { name });
```

This is a high-emotion topic as:

- What "looks idiomatic" depends on the host programming language

  I.e. an idiomatic DSL for TypeScript, looks different than an idiomatic DSL for Java, looks different than an idiomatic DSL for Golang.

- What "looks idiomatic" depends on where the ORM itself situates itself on the "raw string driver" to "query builder" to "entity domain modeling" spectrum.

- What "looks idiomatic" is fundamentally a personal judgement call.

  (Except for on Reddit, where only correct answer is "raw SQL".)

This post covers Joist's `em.find` DSL, and specifically its novel "pruning" feature makes for surprisingly succinct, idiomatic queries, that, for us, are a big part of what makes Joist a joy to use.

## Looking at Static Examples

Often query DSLs are documented and evaluated by looking at static examples, like a low-complexity query like "find authors for publisher with id & name, at least one book that is published, and one book review is highly rated".

More concretely, we might have a REST endpoint of `GET /authors` that accepts a query string filter, which our web framework provides to us as:

```ts
type AuthorsQueryString = {
  name?: string;
  publisherName?: string;
  publisherStatus?: string;
  bookStatus?: int;
  highRating?: boolean;
};

// Called by our web framework, i.e. a call like
// `GET /authors?name=foo&publisherName=bar&bookStatus=published&highRating=true`
// Passes `filter` with the decoded query string
function getAuthors(filter: AuthorsQueryString): Author[] {
  // ...impl our database lookup here...
}
```

The "completely static" implementations of this endpoint, implemented with raw SQL, might look like:

```ts title="postgres.js"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  const rows = await sql<Author[]>`
    SELECT DISTINCT ON (a.id) a.*
    FROM authors a
      JOIN publishers p ON a.publisher_id = p.id
      LEFT JOIN books b ON a.id = b.author_id
      LEFT JOIN book_reviews br ON b.id = br.book_id
      WHERE p.id = ${publisherId}
        AND p.name = '${publisherName}'
        AND b.status_id = ${bookStatusId}
        AND br.rating = ${highRating ? 3 : 1};
  `;
  // assume `a.*` matches our `Author` type
  return rows;
}
```

Or in Knex:

```ts title="Knex"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  return await knex
    .select('a.*')
    .distinct('a.id')
    .from('authors as a')
    .join('publishers as p', 'a.publisher_id', '=', 'p.id')
    .leftJoin('books as b', 'a.id', '=', 'b.author_id')
    .leftJoin('book_reviews as br', 'b.id', '=', 'br.book_id')
    .where({
      'p.id': publisherId,
      'p.name': publisherName,
      'b.status_id': bookStatusId,
      'br.rating': highRating ? 3 : 1
    });
}
```

And finally in Joist:

```ts title="Joist"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  await em.find(Author, {
    publisher: { id: publisherId, name: publisherName },
    books: {
      status: bookStatusId,
      reviews: { rating: highRating ? 3 : 1 },
    },
  });
}
```

Joist's DSL that lets you embed conditions within the join hashes is cute, and succinct, but not necessarily unique--we'll get to the unique part next.

## Looking at Dynamic Examples

These static examples are a good starting point, but in practice we often have to build up queries _dynamically_, where joins & conditions are conditional and based on user input.

For example, we had hardcoded our `getAuthors` to assume that every filter is passed everytime--but actually the caller can pick & choose which filters to send, so we need to dynamically check "which filters are set".

**These dynamic use cases are an important wrinkle that can make or break whether a DSL is still "pleasant" or "infuriating" to work with.**

So let's revisit our implementations, starting with the crowd-favorite raw SQL:

```ts title="postgres.js"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  return await sql<Author[]>`
    SELECT DISTINCT ON (a.id) a.*
    FROM authors a
      ${publisherId || publisherName ? 'JOIN publishers p ON a.publisher_id = p.id' : ''}
      ${bookStatusId || highRating !== undefined ? 'LEFT JOIN books b ON a.id = b.author_id' : ''}
      ${highRating !== undefined ? 'LEFT JOIN book_reviews br ON b.id = br.book_id' : ''}
    WHERE 1 = 1
      ${publisherId ? sql`AND p.id = ${publisherId}` : sql``}
      ${publisherName ? sql`AND p.name = ${publisherName}` : sql``}
      ${bookStatusId ? sql`AND b.status_id = ${bookStatusId}` : sql``}
      ${highRating !== undefined ? sql`AND br.rating = ${highRating ? 3 : 1}` : sql``};
  `;
}
```

A few notes:

* We include a dummy `1 = 1` so that all our conditional predicates can always use an `AND` prefix.

  Without this hack, we'd have to dynamically track "what is the 1st predicate that needs `AND` added", which would be even more tedious (this ack was ChatGTP's idea :-)).

* Each conditional join check needs to know not just "are filters from my table in use" (i.e. if `bookStatusId` is used, include `books`), but also "are filters from any tables *downstream of me* in use" (i.e. if `highRating` is used, include `books` so that the `book_reviews` join works).

Now lets look as Knex, which should be representative method-chaining style query builders:

```ts title="Knex"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  // Start building the query
  const query = knex.select('a.*').distinct('a.id').from('authors as a');
  // Add conditional JOINs
  if (publisherId || publisherName) {
    query.join('publishers as p', 'a.publisher_id', '=', 'p.id');
  }
  if (bookStatusId || highRating !== undefined) {
    query.leftJoin('books as b', 'a.id', '=', 'b.author_id');
  }
  if (highRating !== undefined) {
    query.leftJoin('book_reviews as br', 'b.id', '=', 'br.book_id');
  }
  // Add conditional WHERE clauses
  if (publisherId) query.where('p.id', publisherId);
  if (publisherName) query.where('p.name', publisherName);
  if (bookStatusId) query.where('b.status_id', bookStatusId);
  if (highRating !== undefined) query.where('br.rating', highRating ? 3 : 1);
  return await query as Author[];
}
```

Now Prisma (disclaimer this is from Claude, please let me know if there is a more idiomatic, type-safe way of doing this):

```ts title="Prisma"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  // Build the where conditions based on provided filters
  const where: any = {};
  // Handle publisher conditions (if either exists)
  if (publisherId || publisherName) {
    where.publisher = {};
    // We need to structure the publisher conditions differently if both exist
    if (publisherId && publisherName) {
      where.publisher.OR = [
        { id: publisherId },
        { name: publisherName }
      ];
    } else {
      // Only one condition exists
      if (publisherId) where.publisher.id = publisherId;
      if (publisherName) where.publisher.name = publisherName;
    }
  }
  // Handle book and review conditions
  if (bookStatusId || highRating !== undefined) {
    where.books = { some: {} };
    if (bookStatusId) {
      where.books.some.statusId = bookStatusId;
    }
    if (highRating !== undefined) {
      where.books.some.bookReviews = { some: { rating: highRating ? 3 : 1 } };
    }
  }
  return await prisma.author.findMany({ distinct: ['id'], where });
}
```

Finally here's the dynamic Joist version:

```ts title="Joist"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  await em.find(Author, {
    publisher: { id: publisherId, name: publisherName },
    books: {
      status: bookStatusId,
      reviews: { rating: highRating ? 3 : 1 },
    },
  });
}
```

...which is exactly the same Joist code as before. How does that work?

## Joist's Trick: Usage Tracking

Joist's realization is that, for a majority of "dynamic query" use cases, the _structure_ of the query is usually extremely stable, it's just that *parts within the structure* are "turned on/off" based on conditional input.

Most query DSLs cannot "turn off" parts of the query on their own, and so it's left to _our code_ to handle this boilerplate by **fundamentally altering the query structure** via tedious conditionals--`if` checks, ternaries, or altering our method chains (often the most complicated, in my experience).

As you can see from the postgres.js, Knex, and Prisma examples above, this often "blows up" our code with boilerplate condition checking.

Except for Joist--Joist is smart enough to track "which conditions are actually used", and then "prunes" any unused conditions & _and unused joins_ from the query.

How do we know what is "unused"? Ironically, we leverage the JavaScript [wat](https://www.destroyallsoftware.com/talks/wat) of having "both `null` and `undefined`" and treat any "condition that uses `undefined`" as "unused" (and so prune it), while letting `null` mean `NULL`.

:::tip[Info]

Joist also leverages `null` vs. `undefined` for [partial-update APIs](/features/partial-update-apis/), where calling `createOrUpdatePartial` with `{ firstName: undefined }` means "leave the `firstName` field alone", and `{ firstName: null }` means "unset".

This ends up working out really well with most web frameworks, GraphQL mutations, etc. that will deserialize a `SaveAuthor` command with `firstName: undefined` for the "the caller did not send this field" behavior.

:::

Here are some examples of conditions that are either pruned, or not pruned, based on the values at runtime:

```ts title="Joist"
const lastName = undefined;
const publisherId = null;
await em.find(Author, {
  name: { eq: undefined }, // pruned
  statusId: { in: undefined }, // pruned
  age: { gte: undefined }, // pruned
  lastName, // pruned
  statusId: null, // not pruned
  publisher: { id: publisherId }, // not pruned
});
```

And we take a two-step process:

1. Prune any conditions that are "checking `undefined`", then
2. Prune any joins that no longer have any conditions

## Complex Conditions

So far we've looked at how Joist prunes `em.find` "inline conditions", which are predicates inlined directly in joins hash--all of which become top-level `AND`s in the query.

If we need complex ANDs/ORs, Joist has a `contitions` property that accepts `{ and: [...] }` and `{ or: [...] }` data structures:

```ts title="Joist"
const [a, b] = aliases(Author, Book);
await em.find(
  Author,
  // This 2nd arg is the "joins hash" that defines the structure of joins
  {
    // `as` binds the `authors` table to our `a` const for later usage in the ANDs/ORs
    as: a,
    // These are inline conditions that become top-level ANDs
    firstName: { eq: "bob" }, // not pruned
    // This joins into books, and may/may not be pruned based on conditions
    books: { as: b }, // not pruned b/c b.title is used below
  },
  // This 3rd arg includes the `conditions` for complex ANDs/ORs conditions
  {
    conditions: {
      or: [
        a.lastName.eq(undefined), // pruned
        b.title.eq("foo"), // not pruned
      ],
    },
  },
);
```

As indicated by the comments, any `.eq` or `.in` or `.gt` is passed `undefined` will be pruned.

If an `{ or: [...] }` or `{ and: [...] }` list is empty (because all conditions within the list have been pruned), the `OR`/`AND` clause itself will also be pruned. 

This setup of a stable "joins hash" (the 2nd arg) and either "simple inline" or "complex AND/OR conditions" that all work together, to "turn off" unused conditions & joins **without creating boilerplate in your code** delivers surprisingly succinct, pleasant queries.

## Production Examples

To show how succinct Joist queries are in practice, here are two queries copy/pasted from our production codebase:

The first is for a GraphQL query, `query { items }` that accepts a filter:

```graphql title="GraphQL"
# I.e. `query { items(filter: { version: 2 }) { name } }
input ItemFilter {
  id: [ID!]
  version: [Int!]
  costCode: [ID!]
  isSelection: Boolean
  status: [ItemStatus!]
}
```

And it's implemented by a **1-liner** in our resolver:

```ts title="Joist"
export const items: Pick<QueryResolvers, "items"> = {
  items(root, { filter }, { em }) {
    const { costCode, version = [1], ...other } = filter ?? {};
    return em.findGql(Item, { ...other, costCode: { id: costCode, version } }, { orderBy: { name: "ASC" } });
  },
};
```

The 2nd example is a similar "query for the `CostCode` entity with some filters", but has a `OR` for one of its conditions, the `tradePartnerIds`:

```ts title="Joist"
export const costCodes: Pick<QueryResolvers, "costCodes"> = {
  costCodes(root, { filter }, { em }) {
    const { tradePartnerIds, version = [1], ...others } = filter ?? {};
    const [c, cco, bc] = aliases(Commitment, Commitment, BidContract);
    return em.findGql(
      CostCode,
      {
        // Pass along most of our filters 1:1
        ...others,
        version,
        // The `WHERE` for tradePartnerIds requires joining down into several tables, so
        // setup those joins here, and let them be pruned if tradePartnerIds isn't used.
        // Specifically trades have Purchase Orders (Commitments) & Bids that each "have
        // cost codes", so we want to join from the Cost Code down to the trades usage/exposure
        // to the cost codes, so we can show them only cost codes they care about.
        items: {
          projectItems: {
            commitmentLineItems: {
              commitment: { as: c },
              changeOrder: { commitment: { as: cco } },
            },
          },
          bidItems: {
            bidContractLineItems: { revision: { bidContract: { as: bc } } },
          },
        },
      },
      {
        conditions: {
          // If we have any trade partner ids, we need to filter by them
          or: [
            c.tradePartner.in(tradePartnerIds),
            cco.tradePartner.in(tradePartnerIds),
            bc.tradePartner.in(tradePartnerIds),
          ],
        },
        orderBy: { number: "ASC" },
      },
    );
  },
};
```

This query is not "a 1-liner", *but* hopefully we can still envision how relatively clean it is, in terms of setting up the "static structure" in the join hash, and then letting the `or: [...]` on `tradePartnerIds` drive the conditionality without cluttering up our code.

It's also worth calling out the easy-to-miss `...others`, which pass "the rest of the filters" that map 1:1 between the GraphQL filter and the database, on into Joist for default handling.

This highlights a key principle of Joist: 80-90% of your API (whether a REST endpoint, gRPC service, or GraphQL type) is usually 80-90% 1:1 with the database, and so:

- The 80-90% 1:1 cases should be as succinct/boilerplate-free as possible, but
- The 10-20% one-off cases should still be handled easily without "fighting" against the framework.

## Disclaimer

Joist's `em.find` DSL has one large disclaimer: it only supports fetching entire entities (i.e. `Author`s or `Book`s), and does not support truly arbitrary SQL with aggregates like `SUM`s, group bys that return arbitrary [POJO](https://masteringjs.io/tutorials/fundamentals/pojo)s of data.

This has been solely a pragmatic decision--given Joist's heavy focus on entities, we have not yet prioritized a low-level SQL builder (see [this issue](https://github.com/joist-orm/joist-orm/issues/188) tracking it), as `em.find` "fetching entities" is what 95% of our codebase's queries want to do anyway.

There are also many low-level query builders on the market (Knex, Kysely, Drizzle, Prisma, etc.), so it's not differentiating for Joist to compete in that space.

Currently, for the 5% of our SQL queries that need SUMs/aggregates/group bys, we currently just drop down to Knex, albeit usually after using Joist's `buildKnexQuery` utility to take the `em.find`-style joins/conditions and bootstrap an initial Knex `QueryBuilder`, which we then mutate as needed.

That said, the core idea of "usage tracking" and "condition & join pruning" can definitely apply to lower-level queries, and will be used in Joist's low-level SQL builder, when it shows up. And we anticipate this leading to the same best-in-class, idiomatic queries that we have with `em.find` today.



