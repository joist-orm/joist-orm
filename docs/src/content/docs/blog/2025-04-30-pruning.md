---
title: Query Pruning for the Win
slug: blog/pruning
date: 2025-05-20
authors: shaberman
tags: []
_excerpt: ...
---

A key feature of ORMs, whether Knex-style query builders or a Joist-style [domain models](https://joist-orm.io/modeling/why-entities/), is issuing queries; specifically the API or "DSL" (domain specific language) to "find rows" in the database.

These can be as simple as raw SQL strings or tagged literals in [postgres.js](https://github.com/porsager/postgres) (not really "an ORM", but for illustration purposes):

```ts
const rows = await sql`SELECT * FROM users WHERE name = ${name}`;
```

To fluent "incrementally build SQL strings via method chaining" APIs like Knex or Kysely:

```ts
// Knex
await knex("users").where("name", "=", name);
// Kysely
await db.selectFrom('users').where('name', '=', name).execute();
// Drizzle
await db.select().from(users).where(eq(users.name, name));
```

To Joist's own `em.find`:

```ts
const authors = await em.find(User, { name });
```

This is a high-emotion topic as:

- What "looks idiomatic" depends on the host programming language

  I.e. an idiomatic DSL for TypeScript, looks different than an idiomatic DSL for Java, looks different than an idiomatic DSL for Golang.

- What "looks idiomatic" depends on where the ORM itself situates itself on the "raw string driver" to "query builder" to "entity domain modeling" spectrum.

- What "looks idiomatic" is fundamentally a personal judgement call.

  (Except for on Reddit, where only correct answer is "raw SQL".)

This post covers Joist's `em.find` DSL, and specifically its novel "pruning" feature makes for surprisingly succinct, idiomatic queries, that, for us, are a big part of what makes Joist a joy to use.

## Looking at Static Examples

Often query DSLs are documented and evaluated by looking at static examples, like a low-complexity query like "find authors for publisher with id & name, at least one book that is published, and one book review is highly rated".

More concretely, we might have a REST endpoint of `GET /authors` that accepts a query string filter, which our web framework provides to us as:

```ts
type AuthorsQueryString = {
  name?: string;
  publisherName?: string;
  publisherStatus?: string;
  bookStatus?: int;
  highRating?: boolean;
};

// Called by our web framework
function getAuthors(filter: AuthorsQueryString): Author[] {
  // `filter` is the decoded values from the query string of
  // `GET /authors?name=foo&publisherName=bar&bookStatus=published&highRating=true`
  // ...impl our database lookup here...
}
```

The "completely static" implementations of this endpoint, implemented with raw SQL, might look like:

```ts title="postgres.js"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  const rows = await sql<Author[]>`
    SELECT DISTINCT ON (a.id) a.*
    FROM authors a
      JOIN publishers p ON a.publisher_id = p.id
      LEFT JOIN books b ON a.id = b.author_id
      LEFT JOIN book_reviews br ON b.id = br.book_id
      WHERE p.id = ${publisherId}
        AND p.name = '${publisherName}'
        AND b.status_id = ${bookStatusId}
        AND br.rating = ${highRating ? 3 : 1};
  `;
  // assume `a.*` matches our `Author` type
  return rows;
}
```

Or in Knex:

```ts title="Knex"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  return await knex
    .select('a.*')
    .distinct('a.id')
    .from('authors as a')
    .join('publishers as p', 'a.publisher_id', '=', 'p.id')
    .leftJoin('books as b', 'a.id', '=', 'b.author_id')
    .leftJoin('book_reviews as br', 'b.id', '=', 'br.book_id')
    .where({
      'p.id': publisherId,
      'p.name': publisherName,
      'b.status_id': bookStatusId,
      'br.rating': highRating ? 3 : 1
    });
}
```

And finally in Joist:

```ts title="Joist"
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  await em.find(Author, {
    publisher: { id: publisherId, name: publisherName },
    books: {
      status: bookStatusId,
      reviews: { rating: highRating ? 3 : 1 },
    },
  });
}
```

Joist's DSL that lets you embed conditions within the join hashes is cute, and succinct, but not necessarily unique--we'll get to the unique part next.

## Looking at Dynamic Examples

These static examples are a good starting point, but in practice we often have to build up queries _dynamically_, where joins & conditions are conditional and based on user input.

For example, we had hardcoded our `getAuthors` to assume that every filter is passed everytime--but instead the caller can pick & choose which filters to send, so we need to dynamically check "which filters are set".

These dynamic use cases are an important wrinkle that can make or break whether a DSL is still "pleasant" or "infuriating" to work with.

So let's revisit our implementations, starting with the crowd-favorite raw SQL:

```ts
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  const rows = await sql<Author[]>`
    SELECT DISTINCT ON (a.id) a.*
    FROM authors a
      ${publisherId || publisherName ? 'JOIN publishers p ON a.publisher_id = p.id' : ''}
      ${bookStatusId || highRating !== undefined ? 'LEFT JOIN books b ON a.id = b.author_id' : ''}
      ${highRating !== undefined ? 'LEFT JOIN book_reviews br ON b.id = br.book_id' : ''}
    WHERE 1 = 1
      ${publisherId ? sql`AND p.id = ${publisherId}` : sql``}
      ${publisherName ? sql`AND p.name = ${publisherName}` : sql``}
      ${bookStatusId ? sql`AND b.status_id = ${bookStatusId}` : sql``}
      ${highRating !== undefined ? sql`AND br.rating = ${highRating ? 3 : 1}` : sql``};
  `;
  // assume `a.*` matches our `Author` type
  return rows;
}
```

A few notes:

* We include a dummy `1 = 1` so that all our conditional predicates can always use an `AND` prefix.

  Without this hack, we'd have to dynamically track "what is the 1st predicate that needs `AND` added", which would be even more tedious (this ack was ChatGTP's idea :-)).

* Each conditional join check needs to know not just "are filters from my table in use" (i.e. if `bookStatusId` is used, include `books`), but also "are filters from any tables *downstream of me* in use" (i.e. if `highRating` is used, include `books` so that the `book_reviews` join works).

...include knex dynamic version...

Here's the dynamic Joist version:

```ts
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  await em.find(Author, {
    publisher: { id: publisherId, name: publisherName },
    books: {
      status: bookStatusId,
      reviews: { rating: highRating ? 3 : 1 },
    },
  });
}
```

...which is exactly the same Joist code as before. How does that work?

## Joist's Trick: Usage Tracking

Joist's realization is that, for a majority of "dynamic query" use cases, the _structure_ of the query is usually extremely stable, it's just that *parts within the structure* are turned on/off based on conditional input.

Most query DSLs cannot "turn off" parts of the query on their own, and so it's left to _our code_ to handle this boilerplate by **fundamentally altering the query structure** via tedious conditionals--`if` checks, ternaries, or altering our method chains (often the most complicated, in my experience).

Except for Joist--Joist is smart enough to track "which conditions are actually used", and then "prunes" any unused conditions & _and unused joins_ from the query.

How do we know what is "unused"? Ironically, we leverage the JavaScript [wat](https://www.destroyallsoftware.com/talks/wat) of having "both `null` and `undefined`" and treat any "condition that uses `undefined`" as "unused" (and so prune it), while letting `null` means `NULL`.

Here are some examples of conditions that are either pruned, or not pruned, based on the values at runtime:

```ts title="Joist"
const lastName = undefined;
const publisherId = null;
await em.find(Author, {
  name: { eq: undefined }, // pruned
  statusId: { in: undefined }, // pruned
  age: { gte: undefined }, // pruned
  lastName, // pruned
  statusId: null, // not pruned
  publisher: { id: publisherId }, // not pruned
});
```

And we take a two-step process:

1. Prune any conditions that are "checking `undefined`", then
2. Prune any joins that no longer have any conditions

:::tip[Info]

Joist also leverages `null` vs. `undefined` for [partial-update APIs](/features/partial-update-apis/), where calling `createOrUpdatePartial` with `{ firstName: undefined }` means "leave the `firstName` field alone", and `{ firstName: null }` means "unset".

This ends up working out really well with most web frameworks, GraphQL mutations, etc. that will deserialize a `SaveAuthor` command with `firstName: undefined` for the "the caller did not send this field" behavior.  

:::

## Complex Conditions

So far we've looked at how Joist prunes `em.find` "inline conditions", which are predicates inlined directly in joins hash--all of which become top-level `AND`s in the query.

If we need complex ANDs/ORs, Joist has a `contitions` property that accepts AND/OR expressions:

```ts title="Joist"
const [a, b] = aliases(Author, Book);
await em.find(
  Author,
  // This 2nd arg is the "joins hash" that defines the structure of joins
  {
    // `as` binds the `authors` table to our `a` const for later usage in the ANDs/ORs
    as: a,
    // These are inline conditions that become top-level ANDs
    firstName: { eq: "bob" }, // not pruned
    // This joins into books, and may/may not be pruned based on conditions
    books: { as: b }, // not pruned b/c b.title is used below
  },
  // This 3rd arg includes the `conditions` for complex ANDs/ORs conditions
  {
    conditions: {
      or: [
        a.lastName.eq(undefined), // pruned
        b.title.eq("foo"), // not pruned
      ],
    },
  },
);
```

As indicated by the comments, any `.eq` or `.in` or `.gt` is passed `undefined` will be pruned.

If an `{ or: [...] }` or `{ and: [...] }` list is empty (because all conditions within the list have been pruned), the `OR`/`AND` clause itself will also be pruned. 

This setup of a stable "joins hash" (the 2nd arg) and either "simple inline" or "complex AND/OR conditions" that all work together, to "turn off" unused conditions & joins **without creating boilerplate in your code** delivers surprisingly succinct, pleasant queries.

## Production Examples

Just to show how succinct this is in practice, here are two queries copy/pasted from our production codebase:

The first is for a GraphQL query, `query { items }` that accepts a filter

```graphql
# I.e. `query { items(filter: { version: 2 }) { name } }
input ItemFilter {
  id: [ID!]
  version: [Int!]
  costCode: [ID!]
  isSelection: Boolean
  status: [ItemStatus!]
}
```

And it's implemented by a **1-liner** in our resolver:

```ts title="Joist"
export const items: Pick<QueryResolvers, "items"> = {
  items(root, { filter }, { em }) {
    const { costCode, version = [1], ...other } = filter ?? {};
    return em.findGql(Item, { ...other, costCode: { id: costCode, version } }, { orderBy: { name: "ASC" } });
  },
};
```

The 2nd example is a similar "query for the `CostCode` entity with some filters", but has a `OR` for one of its conditions:

```ts title="Joist"
export const costCodes: Pick<QueryResolvers, "costCodes"> = {
  costCodes(root, { filter }, { em }) {
    const { tradePartnerIds, version = [1], ...others } = filter ?? {};
    const [c, cco, bc] = aliases(Commitment, Commitment, BidContract);
    return em.findGql(
      CostCode,
      {
        ...others,
        version,
        items: {
          projectItems: {
            commitmentLineItems: {
              commitment: { as: c },
              changeOrder: { commitment: { as: cco } },
            },
          },
          bidItems: {
            bidContractLineItems: { revision: { bidContract: { as: bc } } },
          },
        },
      },
      {
        conditions: {
          // If we have any trade partner ids, we need to filter by them
          or: tradePartnerIds?.nonEmpty
            ? [
              c.tradePartner.in(tradePartnerIds),
              cco.tradePartner.in(tradePartnerIds),
              bc.tradePartner.in(tradePartnerIds),
            ]
            : [],
        },
        orderBy: { number: "ASC" },
      },
    );
  },
};
```


- join tracking
- condition tracking -- include soft-deletes
- include production example?

... include a loop with conditions
