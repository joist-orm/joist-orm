---
title: Joist's Pruning-Based Query DSL
slug: blog/pruning
date: 2025-04-20
authors: shaberman
tags: []
_excerpt: ...
---

## Intro

A key feature of ORMs, whether Knex-style query builders or a Joist-style [domain models](https://joist-orm.io/modeling/why-entities/), is issuing queries; specifically the "DSL" (domain specific language) to "find rows" in the database.

These can be as simple as tagged literals in [postgres.js](https://github.com/porsager/postgres) (not really "an ORM", but for illustration purposes):

```ts
const rows = await sql`SELECT * FROM users WHERE name = ${name}`;
```

To fluent "incrementally build SQL strings via method chaining" APIs like Knex or Kysely:

```ts
const rows = await knex('users')
  .where('name', '=', name);
```

To Joist's own `em.find`:

```ts
const authors = await em.find(Author, { name });
```

This is of course a high-emotion topic, as each DSL depends on:

- The host programming language; i.e. an "idiomatic DSL" for TypeScript, will look different then an idiomatic DSL for TypeScript, which will look different then an idiomatic DSL for Golang.

- Where the ORM places itself on the "raw string" to "query builder" to "entity"  spectrum.

## The Problem is Conditionality


kkkkkkkkkkkkkkk

The *structure* is stable, what's dynamic is which parts of the structure are turned on/off.

* join tracking
* condition tracking -- include soft-deletes
* include production example?
