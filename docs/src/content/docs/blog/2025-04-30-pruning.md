---
title: Query Pruning for the Win
slug: blog/pruning
date: 2025-05-20
authors: shaberman
tags: []
_excerpt: ...
---

A key feature of ORMs, whether Knex-style query builders or a Joist-style [domain models](https://joist-orm.io/modeling/why-entities/), is issuing queries; specifically the API or "DSL" (domain specific language) to "find rows" in the database.

These can be as simple as raw SQL strings or tagged literals in [postgres.js](https://github.com/porsager/postgres) (not really "an ORM", but for illustration purposes):

```ts
const rows = await sql`SELECT * FROM users WHERE name = ${name}`;
```

To fluent "incrementally build SQL strings via method chaining" APIs like Knex or Kysely:

```ts
const rows = await knex("users").where("name", "=", name);
```

To Joist's own `em.find`:

```ts
const authors = await em.find(User, { name });
```

This is a high-emotion topic as:

- What "looks idiomatic" depends on the host programming language

  I.e. an idiomatic DSL for TypeScript, looks different than an idiomatic DSL for Java, looks different than an idiomatic DSL for Golang.

- What "looks idiomatic" depends on where the ORM itself situates itself on the "raw string driver" to "query builder" to "entity domain modeling" spectrum.

- What "looks idiomatic" is fundamentally a personal judgement call.

  (Except for on Reddit, where only correct answer is "raw SQL".)

This post covers Joist's `em.find` DSL, and specifically its novel "pruning" feature makes for surprisingly succinct, idiomatic queries, that, for us, are a big part of what makes Joist a joy to use.

## Looking at Static Examples

Often query DSLs are documented and evaluated by looking at static examples, like a low-complexity query like "find authors for publisher with id & name, at least one book that is published, and one book review is highly rated".

More concretely, we might have a REST endpoint of `GET /authors` that accepts a query string filter, which our web framework provides to us as:

```ts
type AuthorsQueryString = {
  name?: string;
  publisherName?: string;
  publisherStatus?: string;
  bookStatus?: int;
  highRating?: boolean;
};

// Called by our web framework
function getAuthors(filter: AuthorsQueryString): Author[] {
  // `filter` is the decoded values from the query string of
  // `GET /authors?name=foo&publisherName=bar&bookStatus=published&highRating=true`
  // ...impl our database lookup here...
}
```

The "completely static" implementations of this endpoint, implemented with raw SQL, might look like:

```ts
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  const rows = await sql<Author[]>`
    SELECT DISTINCT ON (a.id) a.*
    FROM authors a
      JOIN publishers p ON a.publisher_id = p.id
      LEFT JOIN books b ON a.id = b.author_id
      LEFT JOIN book_reviews br ON b.id = br.book_id
      WHERE p.id = ${publisherId}
        AND p.name = '${publisherName}'
        AND b.status_id = ${bookStatusId}
        AND br.rating = ${highRating ? 3 : 1};
  `;
  // assume `a.*` matches our `Author` type
  return rows;
}
```

...include knex example...

And in Joist:

```ts
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  await em.find(Author, {
    publisher: { id: publisherId, name: publisherName },
    books: {
      status: bookStatusId,
      reviews: { rating: highRating ? 3 : 1 },
    },
  });
}
```

Joist's DSL that lets you embed conditions within the join hashes is cute, and succinct, but not necessarily unique--we'll get to the unique part next.

## Looking at Dynamic Examples

These static examples are a good starting point, but in practice we often have to build up queries _dynamically_, where joins & conditions are conditional and based on user input.

For example, we had hardcoded our `getAuthors` to assume that every filter is passed everytime--but instead the caller can pick & choose which filters to send, so we need to dynamically check "which filters are set".

These dynamic use cases are an important wrinkle that can make or break whether a DSL is still "pleasant" or "infuriating" to work with.

So let's revisit our implementations, starting with the crowd-favorite raw SQL:

```ts
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  const rows = await sql<Author[]>`
    SELECT DISTINCT ON (a.id) a.*
    FROM authors a
      ${publisherId || publisherName ? 'JOIN publishers p ON a.publisher_id = p.id' : ''}
      ${bookStatusId || highRating !== undefined ? 'LEFT JOIN books b ON a.id = b.author_id' : ''}
      ${highRating !== undefined ? 'LEFT JOIN book_reviews br ON b.id = br.book_id' : ''}
    WHERE 1 = 1
      ${publisherId ? sql`AND p.id = ${publisherId}` : sql``}
      ${publisherName ? sql`AND p.name = ${publisherName}` : sql``}
      ${bookStatusId ? sql`AND b.status_id = ${bookStatusId}` : sql``}
      ${highRating !== undefined ? sql`AND br.rating = ${highRating ? 3 : 1}` : sql``};
  `;
  // assume `a.*` matches our `Author` type
  return rows;
}
```

A few notes:

* We include a dummy `1 = 1` so that all our conditional predicates can always use an `AND` prefix.

  Without this hack, we'd have to dynamically track "what is the 1st predicate that needs `AND` added", which would be even more tedious (this ack was ChatGTP's idea :-)).

* Each conditional join check needs to know not just "are filters from my table in use" (i.e. if `bookStatusId` is used, include `books`), but also "are filters from any tables *downstream of me* in use" (i.e. if `highRating` is used, include `books` so that the `book_reviews` join works).

...include knex dynamic version...

Here's the dynamic Joist version:

```ts
async function getAuthors(filter: AuthorsQueryString): Promise<Author[]> {
  const { publisherId, publisherName, bookStatusId, highRating } = filter;
  await em.find(Author, {
    publisher: { id: publisherId, name: publisherName },
    books: {
      status: bookStatusId,
      reviews: { rating: highRating ? 3 : 1 },
    },
  });
}
```

...which is exactly the same Joist code as before. How does that work?

## Joist's Trick: Usage Tracking

Joist's realization is that, for a majority of "dynamic query" use cases, the _structure_ of the query is usually extremely stable, it's just that *parts within the structure* are turned on/off based on conditional input.

Most query DSLs cannot "turn off" parts of the query on their own, and so it's left to _our code_ to handle this boilerplate by **altering the fundamental query structure** via tedious conditionals--`if` checks, ternaries, or altering our method chains (often the most complicated, in my experience).

Except for Joist--Joist is smart enough to track "which conditions are actually used", and then "prunes" any unused conditions & unused joins from the query.

How does it know what is "unused"? Any condition that is passed `undefined` is considered unused and skipped/pruned from the query. For example:

```ts
const lastName = undefined;
const publisherId = null;
await em.find(Author, {
  name: { eq: undefined }, // pruned
  statusId: { in: undefined }, // pruned
  lastName, // pruned
  publisher: { id: publisherId }, // not pruned
});
```

This extends to joins as well, we can list as many joins as we want--but if no conditions are left that require that join, Joist will opportunistically prune it from the query.

:::tip[Info]

call out to partial updates

:::

## Complex Conditions

So far we've looked at pruning `em.find`-s "inline conditions", which are predicates inlined directly in joins hash--all of which are always included as `AND`s in the query.

If we want to support complex ANDs/ORs, Joist has a `contitions` property that accepts AND/OR expressions:

```ts
const [a, b] = aliases(Author, Book);
await em.find(Author, {
  as: a,
  firstName: { eq: "bob" }, // not pruned
  books: b, // join is not pruned b/c b.title is used
}, {
  condition: {
    or: [
      a.lastName.eq(undefined), // pruned
      b.title.eq("foo"), // not pruned
    ],
  },
});
```

As indicated by the comments, any `.eq` or `.in` or `.gt` is passed `undefined` will be pruned.

If an `or: [...]` or `and: [...]` list is empty, it will also be pruned. 

## Production Examples

Just to show how succinct this is in practice, this query is copy/pasted from our production codebase:

We have a GraphQL filter defined for the `Item` entity in our database:

```graphql
input ItemFilter {
  id: [ID!]
  version: [Int!]
  costCode: [ID!]
  isSelection: Boolean
  status: [ItemStatus!]
  designPackageLocation: DesignPackageLocation
}
```

And it's implemented by a 1-liner in our resolver:

```ts
export const items: Pick<QueryResolvers, "items"> = {
  items(root, { filter }, { em }) {
    const { costCode, version = [1], ...other } = filter ?? {};
    return em.findGql(Item, { ...other, costCode: { id: costCode, version } }, { orderBy: { name: "ASC" } });
  },
};
```


- join tracking
- condition tracking -- include soft-deletes
- include production example?

... include a loop with conditions
