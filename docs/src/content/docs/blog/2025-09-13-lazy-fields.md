---
title: Lazy Fields without Decorators or Transforms
slug: blog/lazy-fields
date: 2025-09-13
authors: shaberman
tags: []
excerpt: Joist leverages JavaScript's prototypes to blend great developer ergonomics/DX with performance.
---

Joist is an [ActiveRecord](https://guides.rubyonrails.org/active_record_basics.html)-style ORM, such that we purposefully mimic how Rails declares relations, i.e. as class fields:

```typescript
// simplified example
class Author {
  books = hasMany("books");
}
```

This is very ergonomic, i.e. no decorators (which we [do not care for](/blog/avoiding-decorators/)), so much so that at [Homebound](https://www.homebound.com/), we've written (or codegen-d) literally thousands of these class fields-based relations in our domain models.

The class fields/relations are great because they allow business logic to incrementally crawl/walk through the object graph/domain model, and only load the data that the business logic actually needs for its computation--very standard, albeit old school, ORM behavior.

## Eager Initialization

This approach has worked really well, with the only downside being that JavaScript's class fields are eagerly initialized.

This means when `new Author` is called, all of the relations in `class Author`, like `books = hasMany(...)` above, another `publisher = hasOne(...)`, etc., are created & allocated in memory, even if the code that called `new Author` doesn't end up using the `books` relation (maybe it only uses `publisher`).

This is fine when `Author` has a handful of relations, but in sufficiently-complicated domain models, some of our core entities have 30 relations, and the cost of creating 30 relations `x` 1,000 of rows can start to add up.

So our goal has been to keep the `books = hasMany("books")` syntax, but make the fields lazy.

## First Approach: Codegen

Not surprisingly for Joist, our first solution was to leverage code generation.

For an application's default, foreign-key-based relations like one-to-many, many-to-one, etc., Joist already generates a `AuthorCodegen` class that has all of the boilerplate relations defined for free.

So in these `...Codegen` classes, it was easy to just swap the field-based code over to getters:

```ts
// in AuthorCodegen.ts, generated by joist
class AuthorCodegen {
  // lazy cache of relations
  #relations: Record<string, any> = {}

  // Not a field anymore, but looks like one to callers
  get books(): OneToMany<Book> {
    return this.#relations ??= hasMany("books");
  }
}

// in Author.ts, written by the user
class Author extends AuthorCodegen {
  // we get the lazy relations for free
}
```

This works great! We get lazy initization and no one cares that the generated output is a little longer/more verbose.

However, Joist also has a robust set of user-defined relations, for things like [ReactiveField]():

```ts
class Author {
  numberOfBooks = hasReactiveField(...);
}
```

And because this line is fundamentally a user-/engineer-written relation, we couldn't apply our usual codegen hammer.

## Second Approach: AST Transformers

Given we want "this field turned into a getter", that sounded like a good job for AST rewriting!

So our next approach was using [ts-patch](https://github.com/nonara/ts-patch) to run a custom transform during the `tsc` compilation process that scanned the AST for fields following our `has...` convention, and rewrote them to getters.

This was pretty good!

The pros/cons were:

* Pro: We achieved lazy initization
* Pro: Engineers kept writing the ergonomic `relation = hasSome(...)` field syntax
* Pro: No runtime overhead
* Con: Potentially different test vs. production behavior, if tests did not use `ts-jest` & invoke the transformer
* Con: We're tightly coupled to `ts-patch` and `tsc`-driven output

This last con has been becoming more painful, as more alterative performance-first solutions to "transpile/load TypeScript" have been popping up.

We're fans of tsx, Bun, and Node's built-in TypeScript support--all of which are amazingly fast, but all have spotty or missing transform support (likely on purpose, b/c transforms themselves would only slow things down), and so we've not been able to leverage these newer tools.

This had been fine, but as our majestic monolith codebase grows (and grows), we're becoming increasingly motivated to switch to a faster build/load process--without giving up the lazy fields performance optimization.

## Final Approach: JavaScript Prototypes

We spent awhile brainstorming how to "keep fields...but not have them initialized".

We were willing to use proxies, or subtypes, or really any magic--but could not think of a way to avoid `field = has...` from running when the constructor is called.

We tactically need to achieve two things:

1. Create an instance without the fields
2. Move the relations onto the prototype

When articulated this way, a native-JavaScript solution starts to emerge, and even become obvious in retrospect.

### Side-stepping fields with Object.create

The insight to avoid field initializers is they happen "when the constructor is called"--what if we just don't call the constructor (i.e. don't call `new Author`)?

What if we could create a empty `author` instance (no fields assigned), but hooked up to the class's prototype, so it would still "quack like an Author"?

Turns out in JavaScript is a one-liner:

```ts
const empty = Object.create(Author.prototype);
```

And it has all the behaviors we're looking for:

```ts
console.log(empty instanceof Author); // true!
console.log(empty.someGetter); // works
console.log(empty.someField); // undefined
```

Granted, "don't use `new Author`" sounds like a weird approach, but Joist already requires all entity instantiation to go through the `EntityManager`, i.e.:

```ts
const newAuthor = em.create(Author);
const oldAuthor = await em.load(Author, "a:1");
```

So our codebases are already decoupled from the `new` operator, and using `em.create` / `em.load` instead, as these methods allow us to precisely control (and optimize) the entity creation/lifecycle.

Really this was almost too easy--we've got an empty `author`, but now of course `author.books.load()` will not work (it was a field that we skipped), so how do we get that back?

### Moving Relations to the Prototype

Adding fields to the prototype is also very easy in JavaScript, just an `Object.defineProperty`:

```ts
Object.defineProperty(Author.prototype, "books", {
  configurable: true,
  get(this: any) {
    return (this.relations["books"] ??= hasBooks());
  },
});
```

And the only thing we're missing is "what is the list of fields/relations for this `Author` or `Book`, each entity, to move to the prototype"?

Who can tell us what the fields are? Turns out the constructor, which we're trying hard to avoid, can easily tell us--and we only need to ask it once.

We end up with a process like:

1. Create a "fake" `new Author` to let it assign fields like `books = hasMany(...)` during the traditional object instantiation process
2. Teach `hasBooks(...)` return a `RelationMarker` that isn't the true relation, but a lazy version that lets us identify (`instanceof`) "this `author.books` value is a relation"
3. For every `Object.entries(author)` where `value intanceof RelationMarker`, do an `Object.defineProperties` to "move" that relation to the prototype, and call `relationMarker.create()` when lazily accessed

And that's it--we've done a one-time/on-boot "probe" of `new Author`, to find its fields/relations, moved them to the prototype, and now going forward we can do our constructor-avoiding `Object.create(Author.prototype)` call.

When callers access the relations like `author.books`, `author.publisher` they will still be there, and still "look like fields" to the type system, but they'll be lazily created.

## Achieved

Looking at what we've achieved, we've made lazy class fields in JavaScript, just by using the platform's native features--prototypes!

We didn't have to use decorators (no `@lazy` or `@hasMany`), and no syntax changes to our entities--it keeps the great DX that Joist strives for, and our engineers appreciate.

And, per DX, it enables our codebases to explore modern tooling, because we're back to being "just JavaScript". :tada:

:::tip

If you want to explore this approach in a minimal example, there is a proof-of-concept repository we used to prototype the approach [here](https://github.com/stephenh/lazy-ts-fields/tree/main/src).

:::
