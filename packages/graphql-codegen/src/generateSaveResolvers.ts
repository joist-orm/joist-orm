import { camelCase } from "change-case";
import { Config, DbMetadata } from "joist-codegen";
import { CodegenFile, code, imp } from "ts-poet";

const saveEntity = imp("saveEntity@src/resolvers/utils.ts");
const mutationResolvers = imp("t:MutationResolvers@src/generated/graphql-types.ts");
const makeRunInputMutation = imp("makeRunInputMutation@src/resolvers/testUtils.ts");

/**
 * Generates a save resolver.
 *
 * This basically preempts the Joist-agnostic resolvers generated by [1] b/c `joist-codegen`
 * will run first and put these Joist-aware resolvers in place first.
 *
 * Then when [1] runs, it will only output resolver scaffolding for non-entity resolvers.
 *
 * [1]: https://github.com/homebound-team/graphql-typescript-resolver-scaffolding
 */
export function generateSaveResolvers(config: Config, db: DbMetadata): CodegenFile[] {
  const entitiesPath = config.esm ? "src/entities/index.ts" : "src/entities";
  return db.entities.flatMap((e) => {
    const { name } = e;
    const camelName = camelCase(name);
    const type = imp(`${name}@${entitiesPath}`);
    const fileName = `save${name}Mutation`;
    const resolverConst = imp(`save${name}@src/resolvers/${camelName}/${fileName}.ts`);
    return [
      {
        name: `resolvers/${camelName}/${fileName}.ts`,
        overwrite: false,
        contents: code`
          export const save${name}: Pick<${mutationResolvers}, "save${name}"> = {
            async save${name}(_, args, ctx) {
              return { ${camelName}: await ${saveEntity}(ctx, ${type}, args.input) };
            },
          };
        `,
      },
      {
        name: `resolvers/${camelName}/${fileName}.test.ts`,
        overwrite: false,
        contents: code`
        describe("save${name}", () => {
          it.withCtx("can create", async (ctx) => {
            const result = await runSave(ctx, () => ({}));
            expect(result).toBeDefined()
          });
        });

        const runSave = ${makeRunInputMutation}(${resolverConst});
      `,
      },
    ];
  });
}
