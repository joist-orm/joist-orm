import ansiRegex from "ansi-regex";
import { ReactionLogger, setReactionLogging } from "joist-orm";
import { newAuthor } from "src/entities";
import { newEntityManager } from "src/testEm";

let output: string[] = [];

describe("ReactionLogging", () => {
  describe("validation", () => {
    it("sees primitive sets", async () => {
      const em = newEntityManager();
      newAuthor(em);
      await em.flush();
      expect(output).toMatchInlineSnapshot(`
       [
         "a#1.firstName changed, queuing a#1.direct↩",
         "a#1.firstName changed, queuing a#1.mentor.o2m↩",
         "a#1.firstName changed, queuing a#1.numberOfBooks↩",
         "a#1.firstName changed, queuing a#1.bookComments↩",
         "a#1.firstName changed, queuing a#1.menteesRecursive.mentorNames↩",
         "a#1.firstName changed, queuing a#1.mentorsRecursive.menteeNames↩",
         "a#1.firstName changed, queuing a#1.search↩",
         "a#1.firstName changed, queuing a#1.books.search↩",
         "a#1.firstName changed, queuing a#1.publisher@SmallPublisher.allAuthorNames↩",
         "a#1 created, queuing a#1.direct↩",
         "a#1 created, queuing a#1.m2o↩",
         "a#1 created, queuing a#1.o2m↩",
         "a#1 created, queuing a#1.mentor.o2m↩",
         "a#1 created, queuing a#1.m2m↩",
         "a#1 created, queuing a#1.rf↩",
         "a#1 created, queuing a#1.rr↩",
         "a#1 created, queuing a#1.setViaHook↩",
         "a#1 created, queuing a#1.immutable↩",
         "a#1 created, queuing a#1.observeNickNames↩",
         "a#1 created, queuing a#1.runOnce↩",
         "a#1 created, queuing a#1.Author.ts:454↩",
         "a#1 created, queuing a#1.numberOfBooks↩",
         "a#1 created, queuing a#1.bookComments↩",
         "a#1 created, queuing a#1.bookComments↩",
         "a#1 created, queuing a#1.nickNamesUpper↩",
         "a#1 created, queuing a#1.mentorNames↩",
         "a#1 created, queuing a#1.menteesRecursive.mentorNames↩",
         "a#1 created, queuing a#1.menteesRecursive.mentorNames↩",
         "a#1 created, queuing a#1.menteeNames↩",
         "a#1 created, queuing a#1.mentorsRecursive.menteeNames↩",
         "a#1 created, queuing a#1.mentorsRecursive.menteeNames↩",
         "a#1 created, queuing a#1.numberOfPublicReviews↩",
         "a#1 created, queuing a#1.numberOfPublicReviews2↩",
         "a#1 created, queuing a#1.tagsOfAllBooks↩",
         "a#1 created, queuing a#1.search↩",
         "a#1 created, queuing a#1.rangeOfBooks↩",
         "a#1 created, queuing a#1.rootMentor↩",
         "a#1 created, queuing a#1.menteesRecursive.rootMentor↩",
         "a#1 created, queuing a#1.menteesRecursive.rootMentor↩",
         "a#1 created, queuing a#1.favoriteBook↩",
         "a#1 created, queuing a#1.menteesClosure↩",
         "a#1 created, queuing a#1.mentorsRecursive.menteesClosure↩",
         "a#1 created, queuing a#1.mentorsRecursive.menteesClosure↩",
         "a#1 created, queuing a#1.bestReviews↩",
         "a#1 created, queuing a#1.books.search↩",
         "a#1 created, queuing a#1.books.reviews.isPublic↩",
         "a#1 created, queuing a#1.comments.parentTags↩",
         "a#1 created, queuing a#1.comments.parentTags↩",
         "a#1 created, queuing a#1.publisher.numberOfBookReviews↩",
         "a#1 created, queuing a#1.publisher.titlesOfFavoriteBooks↩",
         "a#1 created, queuing a#1.publisher.favoriteAuthor↩",
         "a#1 created, queuing a#1.publisher.group.numberOfBookReviewsFormatted↩",
         "a#1 created, queuing a#1.publisher@LargePublisher.numberOfBookReviews↩",
         "a#1 created, queuing a#1.publisher@LargePublisher.titlesOfFavoriteBooks↩",
         "a#1 created, queuing a#1.publisher@LargePublisher.favoriteAuthor↩",
         "a#1 created, queuing a#1.publisher@SmallPublisher.allAuthorNames↩",
         "a#1 created, queuing a#1.publisher@SmallPublisher.numberOfBookReviews↩",
         "a#1 created, queuing a#1.publisher@SmallPublisher.titlesOfFavoriteBooks↩",
         "a#1 created, queuing a#1.publisher@SmallPublisher.favoriteAuthor↩",
         "a#1 created, queuing a#1.publisher@SmallPublisher.group.numberOfBookReviewsFormatted↩",
         "a#1.nickNames changed, queuing a#1.observeNickNames↩",
         "a#1.nickNames changed, queuing a#1.runOnce↩",
         "a#1.nickNames changed, queuing a#1.nickNamesUpper↩",
         "Recalculating reactive fields values... (em.entities=1)↩",
         "  Walked 1 Author.(self) paths, found 1 Author.direct to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.numberOfBooks to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.bookComments to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.search to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.m2o to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.o2m to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.m2m to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.rf to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.rr to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.setViaHook to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.immutable to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.observeNickNames to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.runOnce to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.Author.ts:454 to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.bookComments to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.nickNamesUpper to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.mentorNames to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.menteeNames to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.numberOfPublicReviews to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.numberOfPublicReviews2 to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.tagsOfAllBooks to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.rangeOfBooks to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.rootMentor to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.favoriteBook to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.menteesClosure to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.bestReviews to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.mentor paths, found 0 Author.o2m to recalc↩",
         "  Walked 1 Author.menteesRecursive paths, found 0 Author.mentorNames to recalc↩",
         "  Walked 1 Author.mentorsRecursive paths, found 0 Author.menteeNames to recalc↩",
         "  Walked 1 Author.books paths, found 0 Book.search to recalc↩",
         "  Walked 1 Author.menteesRecursive paths, found 0 Author.mentorNames to recalc↩",
         "  Walked 1 Author.mentorsRecursive paths, found 0 Author.menteeNames to recalc↩",
         "  Walked 1 Author.menteesRecursive paths, found 0 Author.rootMentor to recalc↩",
         "  Walked 1 Author.menteesRecursive paths, found 0 Author.rootMentor to recalc↩",
         "  Walked 1 Author.mentorsRecursive paths, found 0 Author.menteesClosure to recalc↩",
         "  Walked 1 Author.mentorsRecursive paths, found 0 Author.menteesClosure to recalc↩",
         "  Walked 1 Author.comments paths, found 0 Comment.parentTags to recalc↩",
         "  Walked 1 Author.comments paths, found 0 Comment.parentTags to recalc↩",
         "  Walked 1 Author.publisher paths, found 0 Publisher.titlesOfFavoriteBooks to recalc↩",
         "  Walked 1 Author.publisher paths, found 0 Publisher.favoriteAuthor to recalc↩",
         "  Walked 1 Author.publisher@SmallPublisher paths, found 0 SmallPublisher.allAuthorNames to recalc↩",
         "  Walked 1 Author.books.reviews paths, found 0 BookReview.isPublic to recalc↩",
         "  Walked 1 Author.publisher@LargePublisher paths, found 0 LargePublisher.titlesOfFavoriteBooks to recalc↩",
         "  Walked 1 Author.publisher@LargePublisher paths, found 0 LargePublisher.favoriteAuthor to recalc↩",
         "  Walked 1 Author.publisher@SmallPublisher paths, found 0 SmallPublisher.titlesOfFavoriteBooks to recalc↩",
         "  Walked 1 Author.publisher@SmallPublisher paths, found 0 SmallPublisher.favoriteAuthor to recalc↩",
         "  Loading 25 actions... (em.entities=1)↩",
         "    Author.direct -> [ a#1 ]↩",
         "    Author.numberOfBooks -> [ a#1 ]↩",
         "    Author.bookComments -> [ a#1 ]↩",
         "    Author.search -> [ a#1 ]↩",
         "    Author.m2o -> [ a#1 ]↩",
         "    Author.o2m -> [ a#1 ]↩",
         "    Author.m2m -> [ a#1 ]↩",
         "    Author.rf -> [ a#1 ]↩",
         "    Author.rr -> [ a#1 ]↩",
         "    Author.setViaHook -> [ a#1 ]↩",
         "    Author.immutable -> [ a#1 ]↩",
         "    Author.observeNickNames -> [ a#1 ]↩",
         "    Author.runOnce -> [ a#1 ]↩",
         "    Author.Author.ts:454 -> [ a#1 ]↩",
         "    Author.nickNamesUpper -> [ a#1 ]↩",
         "    Author.mentorNames -> [ a#1 ]↩",
         "    Author.menteeNames -> [ a#1 ]↩",
         "    Author.numberOfPublicReviews -> [ a#1 ]↩",
         "    Author.numberOfPublicReviews2 -> [ a#1 ]↩",
         "    Author.tagsOfAllBooks -> [ a#1 ]↩",
         "    Author.rangeOfBooks -> [ a#1 ]↩",
         "    Author.rootMentor -> [ a#1 ]↩",
         "    Author.favoriteBook -> [ a#1 ]↩",
         "    Author.menteesClosure -> [ a#1 ]↩",
         "    Author.bestReviews -> [ a#1 ]↩",
         "a#1.numberOfBooks changed, queuing a#1.comments.parentTags↩",
         "    took 0 millis (em.entities=1)↩",
         "  Loading 1 actions... (em.entities=1)↩",
         "    Author.search -> [ a#1 ]↩",
         "a#1.search changed, queuing a#1.rf↩",
         "    took 0 millis (em.entities=1)↩",
         "  Walked 1 Author.(self) paths, found 1 Author.rf to recalc↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.comments paths, found 0 Comment.parentTags to recalc↩",
         "  Loading 1 actions... (em.entities=1)↩",
         "    Author.rf -> [ a#1 ]↩",
         "    took 0 millis (em.entities=1)↩",
         "Validating from 1 changed entities... (em.entities=1)↩",
         "  Walked 1 Author.(self) paths, found 1 Author.addRule(AuthorCodegen.ts:398) to validate↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.addRule(Author.ts:346) to validate↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.addRule(Author.ts:368) to validate↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.addRule(Author.ts:375) to validate↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.addRule(Author.ts:382) to validate↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.addRule(Author.ts:387) to validate↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.(self) paths, found 1 Author.addRule(Author.ts:395) to validate↩",
         "    [ a#1 ] -> [ a#1 ]↩",
         "  Walked 1 Author.books paths, found 0 Book.addRule(Book.ts:45) to validate↩",
         "  Walked 1 Author.books paths, found 0 Book.addRule(Book.ts:56) to validate↩",
         "  Walked 1 Author.publisher paths, found 0 Publisher.addRule(Publisher.ts:170) to validate↩",
         "  Walked 1 Author.publisher paths, found 0 Publisher.addRule(Publisher.ts:177) to validate↩",
         "  Walked 1 Author.publisher paths, found 0 Publisher.addRule(Publisher.ts:185) to validate↩",
         "  Walked 1 Author.publisher@SmallPublisher paths, found 0 SmallPublisher.addRule(SmallPublisher.ts:70) to validate↩",
         "Recalculating reactive queries values... (em.entities=1)↩",
         "  Walked 1 Author.publisher paths, found 0 Publisher.numberOfBookReviews to recalc↩",
         "  Walked 1 Author.publisher.group paths, found 0 PublisherGroup.numberOfBookReviewsFormatted to recalc↩",
         "  Walked 1 Author.publisher@LargePublisher paths, found 0 LargePublisher.numberOfBookReviews to recalc↩",
         "  Walked 1 Author.publisher@SmallPublisher paths, found 0 SmallPublisher.numberOfBookReviews to recalc↩",
         "  Walked 1 Author.publisher@SmallPublisher.group paths, found 0 SmallPublisherGroup.numberOfBookReviewsFormatted to recalc↩",
         "  Loading 0 actions... (em.entities=1)↩",
         "    took 0 millis (em.entities=1)↩",
         "Validating from 0 changed entities... (em.entities=1)↩",
       ]
      `);
    });
  });
});

beforeEach(() => {
  output = [];
  setReactionLogging(new StubReactionLogger());
});

class StubReactionLogger extends ReactionLogger {
  constructor() {
    super((line: string) => {
      output.push(line.replace(ansiRegex(), "").replace("\n", "↩"));
    });
  }
  // Ensure deterministic output
  now = () => 0;
}

afterAll(() => {
  setReactionLogging(false);
});
